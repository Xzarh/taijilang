
/*
  this file is based on coffeescript/src/command.coffee(https://github.com/jashkenas/coffeescript)
  Thanks to  Jeremy Ashkenas
  Some stuffs is added or modified for taiji langauge.
 */

/*
Copyright (c) 2009-2014 Jeremy Ashkenas
Copyright (c) 2014-2015 Caoxingming

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
 */
var BANNER, EventEmitter, SWITCHES, SourceMap, TaijiModule, baseFileName, compileOptions, compilePath, compileScript, exec, extend, findDirectoryIndex, forkNode, formatSourcePosition, fs, hidden, mkdirp, notSources, optionParser, optparse, opts, outputPath, parseOptions, path, printLine, printWarn, runCode, sourceCode, sources, spawn, taiji, timeLog, usage, useWinPathSep, utils, version, vm, wait, watchedDirs, writeJs, writeResult, _ref, _ref1,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  __hasProp = {}.hasOwnProperty;

fs = require('fs');

path = require('path');

vm = require('vm');

_ref = require('child_process'), spawn = _ref.spawn, exec = _ref.exec;

EventEmitter = require('events').EventEmitter;

mkdirp = require('mkdirp');

_ref1 = utils = require('./utils'), extend = _ref1.extend, baseFileName = _ref1.baseFileName;

optparse = require('./optparse');

taiji = require('./taiji');

TaijiModule = require('./module');

SourceMap = require('./sourcemap');

useWinPathSep = path.sep === '\\';

extend(taiji, new EventEmitter);

printLine = function(line) {
  return process.stdout.write(line + '\n');
};

printWarn = function(line) {
  return process.stderr.write(line + '\n');
};

hidden = function(file) {
  return /^\.|~$/.test(file);
};

BANNER = 'Usage: taiji [options] path/to/script.tj -- [args]\n\nIf called without options, taiji will run your script.';

SWITCHES = [['-a', '--parse', 'print out the json list that the parser produces'], ['-b', '--bare', 'compile without a top-level function wrapper'], ['-c', '--compile', 'compile to JavaScript and save as .js files'], ['-d', '--nodejs [ARGS]', 'pass options directly to the "node" binary'], ['-e', '--eval', 'pass a string from the command line as input'], ['-h', '--help', 'display this help message'], ['-i', '--interactive', 'run an interactive taiji repl'], ['-j', '--join [FILE]', 'concatenate the source taiji before compiling'], ['-m', '--map', 'generate source map and save as .map files'], ['-n', '--no-optimize', 'compile to javascript code without optimization'], ['-o', '--output [DIR]', 'set the output directory for compiled JavaScript'], ['-p', '--print', 'print out the compiled JavaScript'], ['-r', '--no-header', 'suppress the "Generated by" header'], ['-s', '--stdio', 'listen for and compile scripts over stdio'], ['-t', '--transforma', 'print out the internal expression after transforming'], ['-v', '--version', 'display the version number'], ['-w', '--watch', 'watch scripts for changes and rerun commands'], ['-z', '--optimize', 'print out the internal expression after optimizing']];

exports.testing = false;

exports.opts = opts = {};

sources = [];

sourceCode = [];

notSources = {};

watchedDirs = {};

optionParser = null;

exports.run = function() {
  var literals, replCliOpts, source, _i, _len, _ref2, _results;
  parseOptions();
  replCliOpts = {
    useGlobal: true
  };
  if (opts.nodejs) {
    return forkNode();
  }
  if (opts.help) {
    return usage();
  }
  if (opts.version) {
    return version();
  }
  if (opts.interactive) {
    return require('./repl').start(replCliOpts);
  }
  if (opts.stdio) {
    return compileStdio();
  }
  if (opts["eval"]) {
    return compileScript('compileCode', null, opts["arguments"][0]);
  }
  if (!opts["arguments"].length) {
    return require('./repl').start(replCliOpts);
  }
  literals = opts.run ? opts["arguments"].splice(1) : [];
  process.argv = process.argv.slice(0, 2).concat(literals);
  process.argv[0] = 'taiji';
  if (opts.output) {
    opts.output = path.resolve(opts.output);
  }
  _ref2 = opts["arguments"];
  _results = [];
  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
    source = _ref2[_i];
    source = path.resolve(source);
    if (opts.compile || opts.run) {
      if (opts.noOptimize) {
        compilePath('compileCodeWithoutOptimization', source, true, source);
      } else {
        compilePath('compile', source, true, source);
      }
    }
    if (opts.parse) {
      compilePath('parse', source, true, source);
    }
    if (opts.transform) {
      compilePath('transform', source, true, source);
    }
    if (opts.optimize) {
      _results.push(compilePath('optimize', source, true, source));
    } else {
      _results.push(void 0);
    }
  }
  return _results;
};

compilePath = function(action, source, topLevel, base) {
  var code, err, file, files, stats, _i, _len, _ref2, _results;
  if ((_ref2 = action + ' ' + source, __indexOf.call(sources, _ref2) >= 0) || watchedDirs[source] || !topLevel && (notSources[source] || hidden(source))) {
    return;
  }
  try {
    stats = fs.statSync(source);
  } catch (_error) {
    err = _error;
    if (err.code === 'ENOENT') {
      console.error("File not found: " + source);
      process.exit(1);
    }
    throw err;
  }
  if (stats.isDirectory()) {
    if (path.basename(source) === 'node_modules') {
      notSources[source] = true;
      return;
    }
    if (opts.run) {
      compilePath(action, findDirectoryIndex(source), topLevel, base);
      return;
    }
    if (opts.watch) {
      watchDir(source, base);
    }
    try {
      files = fs.readdirSync(source);
    } catch (_error) {
      err = _error;
      if (err.code === 'ENOENT') {
        return;
      } else {
        throw err;
      }
    }
    _results = [];
    for (_i = 0, _len = files.length; _i < _len; _i++) {
      file = files[_i];
      _results.push(compilePath(action, path.join(source, file), false, base));
    }
    return _results;
  } else if (topLevel || utils.isTaiji(source)) {
    sources.push(action + ' ' + source);
    sourceCode.push(null);
    delete notSources[action + ' ' + source];
    if (opts.watch) {
      watch(source, base);
    }
    try {
      code = fs.readFileSync(source);
    } catch (_error) {
      err = _error;
      if (err.code === 'ENOENT') {
        return;
      } else {
        throw err;
      }
    }
    return compileScript(action, source, code.toString(), base);
  } else {
    return notSources[action + ' ' + source] = true;
  }
};

findDirectoryIndex = function(source) {
  var err, ext, index, _i, _len, _ref2;
  _ref2 = taiji.FILE_EXTENSIONS;
  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
    ext = _ref2[_i];
    index = path.join(source, "index" + ext);
    try {
      if ((fs.statSync(index)).isFile()) {
        return index;
      }
    } catch (_error) {
      err = _error;
      if (err.code !== 'ENOENT') {
        throw err;
      }
    }
  }
  console.error("Missing index.taiji or index.littaiji in " + source);
  return process.exit(1);
};

compileScript = function(action, file, input, base) {
  var compiled, err, message, o, options, t, task;
  if (base == null) {
    base = null;
  }
  o = exports.opts;
  options = compileOptions(file, base);
  try {
    t = task = {
      file: file,
      input: input,
      options: options
    };
    taiji.emit('compile', task);
    if (o.run) {
      taiji.register();
      return runCode(t.input, t.options);
    } else {
      compiled = exports[action](t.input, new TaijiModule(file, taiji.rootModule), t.options);
      t.output = compiled;
      if (o.map) {
        t.output = compiled.js;
        t.sourceMap = compiled.v3SourceMap;
      }
      taiji.emit('success', task);
      if (o.print) {
        return printLine(t.output.trim());
      } else if (o.compile || o.map) {
        return writeJs(base, t.file, t.output, options.outputPath, t.sourceMap);
      } else {
        return writeResult(base, t.file, t.output, options.outputPath, action);
      }
    }
  } catch (_error) {
    err = _error;
    taiji.emit('failure', err, task);
    if (taiji.listeners('failure').length) {
      return;
    }
    message = err.stack || ("" + err);
    if (o.watch) {
      return printLine(message + '\x07');
    } else {
      printWarn(message);
      return process.exit(1);
    }
  }
};

outputPath = function(source, base, extension) {
  var basename, dir, srcDir;
  if (extension == null) {
    extension = ".js";
  }
  basename = utils.baseFileName(source, true, useWinPathSep);
  srcDir = path.dirname(source);
  if (!opts.output) {
    dir = srcDir;
  } else if (source === base) {
    dir = opts.output;
  } else {
    dir = path.join(opts.output, path.relative(base, srcDir));
  }
  return path.join(dir, basename + extension);
};

writeJs = function(base, sourcePath, js, jsPath) {
  var jsDir, processFile;
  jsDir = path.dirname(jsPath);
  processFile = function() {
    if (opts.compile) {
      if (js.length === 0) {
        js = ' ';
      }
      return fs.writeFile(jsPath, js, function(err) {
        if (err) {
          return printLine(err.message);
        } else if (opts.compile && opts.watch) {
          return timeLog("compiled " + sourcePath);
        }
      });
    }
  };
  return fs.exists(jsDir, function(itExists) {
    if (itExists) {
      return processFile();
    } else {
      return mkdirp(jsDir, processFile);
    }
  });
};

writeResult = function(base, sourcePath, obj, objPath, action) {
  var objDir, write;
  objDir = path.dirname(objPath);
  objPath = path.join(objDir, baseFileName(sourcePath, true, path.sep === '\\') + '.' + action + '.taiji.json');
  write = function() {
    if (obj.length === 0) {
      obj = ' ';
    }
    return fs.writeFile(objPath, obj, function(err) {
      if (err) {
        return printLine(err.message);
      } else if (opts.watch) {
        return timeLog(action + (" " + sourcePath));
      }
    });
  };
  return fs.exists(objDir, function(itExists) {
    if (itExists) {
      return write();
    } else {
      return mkdirp(objDir, write);
    }
  });
};

wait = function(milliseconds, func) {
  return setTimeout(func, milliseconds);
};

timeLog = function(message) {
  return console.log("" + ((new Date).toLocaleTimeString()) + " - " + message);
};

parseOptions = function() {
  var o;
  optionParser = new optparse.OptionParser(SWITCHES, BANNER);
  if (!exports.testing) {
    o = exports.opts = opts = optionParser.parse(process.argv.slice(2));
    o.compile || (o.compile = !!o.output);
    o.run = !(o.compile || o.print || o.map);
    return o.print = !!(o.print || (o["eval"] || o.stdio && o.compile));
  } else {
    return o = opts = exports.opts;
  }
};

compileOptions = function(filename, base) {
  var answer, cwd, jsDir, outPath;
  answer = {
    filename: filename,
    bare: opts.bare,
    header: opts.compile && !opts['no-header'],
    sourceMap: opts.map
  };
  if (filename) {
    if (base) {
      cwd = process.cwd();
      outPath = outputPath(filename, base);
      jsDir = path.dirname(outPath);
      answer = utils.merge(answer, {
        outputPath: outPath,
        sourceRoot: path.relative(jsDir, cwd),
        sourceFiles: [path.relative(cwd, filename)],
        generatedFile: utils.baseFileName(outPath, false, useWinPathSep)
      });
    } else {
      answer = utils.merge(answer, {
        sourceRoot: "",
        sourceFiles: [utils.baseFileName(filename, false, useWinPathSep)],
        generatedFile: utils.baseFileName(filename, true, useWinPathSep) + ".js"
      });
    }
  }
  return answer;
};

forkNode = function() {
  var args, nodeArgs, p;
  nodeArgs = opts.nodejs.split(/\s+/);
  args = process.argv.slice(1);
  args.splice(args.indexOf('--nodejs'), 2);
  p = spawn(process.execPath, nodeArgs.concat(args), {
    cwd: process.cwd(),
    env: process.env,
    customFds: [0, 1, 2]
  });
  return p.on('exit', function(code) {
    return process.exit(code);
  });
};

usage = function() {
  return printLine((new optparse.OptionParser(SWITCHES, BANNER)).help());
};

version = function() {
  return printLine("taiji version " + taiji.VERSION);
};

exports.parse = function(code, taijiModule, options) {
  return taiji.parse(code, taijiModule, taiji.builtins, options);
};

exports.transform = function(code, taijiModule, options) {
  return taiji.transform(code, taijiModule, taiji.builtins, options);
};

exports.optimize = function(code, taijiModule, options) {
  return taiji.optimize(code, taijiModule, taiji.builtins, options);
};

exports.compile = function(code, taijiModule, options) {
  return taiji.compile(code, taijiModule, taiji.builtins, options);
};

exports.runCode = runCode = function(code, options) {
  var answer, dir, filename, mainModule, _ref2;
  if (options == null) {
    options = {};
  }
  mainModule = require.main;
  mainModule.filename = process.argv[1] = options.filename ? fs.realpathSync(options.filename) : '.';
  mainModule.moduleCache && (mainModule.moduleCache = {});
  dir = options.filename ? path.dirname(fs.realpathSync(options.filename)) : fs.realpathSync('.');
  mainModule.paths = require('module')._nodeModulePaths(dir);
  if (!utils.isTaiji(mainModule.filename) || require.extensions) {
    filename = options.filename || '**evaluated taijilang code**';
    answer = exports.compile(code, new TaijiModule(filename, taiji.rootModule), options);
    code = (_ref2 = answer.js) != null ? _ref2 : answer;
  }
  return mainModule._compile(code, mainModule.filename);
};

exports.evalCode = function(code, options) {
  var Module, Script, js, k, o, r, sandbox, v, _i, _len, _module, _ref2, _ref3, _require;
  if (options == null) {
    options = {};
  }
  if (!(code = code.trim())) {
    return;
  }
  Script = vm.Script;
  if (Script) {
    if (options.sandbox != null) {
      if (options.sandbox instanceof Script.createContext().constructor) {
        sandbox = options.sandbox;
      } else {
        sandbox = Script.createContext();
        _ref2 = options.sandbox;
        for (k in _ref2) {
          if (!__hasProp.call(_ref2, k)) continue;
          v = _ref2[k];
          sandbox[k] = v;
        }
      }
      sandbox.global = sandbox.root = sandbox.GLOBAL = sandbox;
    } else {
      sandbox = global;
    }
    sandbox.__filename = options.filename || 'eval';
    sandbox.__dirname = path.dirname(sandbox.__filename);
    if (!(sandbox !== global || sandbox.module || sandbox.require)) {
      Module = require('module');
      sandbox.module = _module = new Module(options.modulename || 'eval');
      sandbox.require = _require = function(path) {
        return Module._load(path, _module, true);
      };
      _module.filename = sandbox.__filename;
      _ref3 = Object.getOwnPropertyNames(require);
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        r = _ref3[_i];
        if (r !== 'paths') {
          _require[r] = require[r];
        }
      }
      _require.paths = _module.paths = Module._nodeModulePaths(process.cwd());
      _require.resolve = function(request) {
        return Module._resolveFilename(request, _module);
      };
    }
  }
  o = {};
  for (k in options) {
    if (!__hasProp.call(options, k)) continue;
    v = options[k];
    o[k] = v;
  }
  o.bare = true;
  js = exports.compile(code, new TaijiModule('evaluated-code.tj', taiji.rootModule), o);
  if (sandbox === global) {
    return vm.runInThisContext(js);
  } else {
    return vm.runInContext(js, sandbox);
  }
};

formatSourcePosition = function(frame) {
  var as, column, fileLocation, fileName, functionName, isConstructor, isMethodCall, line, methodName, tp, typeName;
  fileName = void 0;
  fileLocation = '';
  if (frame.isNative()) {
    fileLocation = "native";
  } else {
    if (frame.isEval()) {
      fileName = frame.getScriptNameOrSourceURL();
      if (!fileName) {
        fileLocation = "" + (frame.getEvalOrigin()) + ", ";
      }
    } else {
      fileName = frame.getFileName();
    }
    fileName || (fileName = "<anonymous>");
    line = frame.getLineNumber();
    column = frame.getColumnNumber();
    fileLocation = "" + fileName + ":" + line + ":" + column;
  }
  functionName = frame.getFunctionName();
  isConstructor = frame.isConstructor();
  isMethodCall = !(frame.isToplevel() || isConstructor);
  if (isMethodCall) {
    methodName = frame.getMethodName();
    typeName = frame.getTypeName();
    if (functionName) {
      tp = as = '';
      if (typeName && functionName.indexOf(typeName)) {
        tp = "" + typeName + ".";
      }
      if (methodName && functionName.indexOf("." + methodName) !== functionName.length - methodName.length - 1) {
        as = " [as " + methodName + "]";
      }
      return "" + tp + functionName + as + " (" + fileLocation + ")";
    } else {
      return "" + typeName + "." + (methodName || '<anonymous>') + " (" + fileLocation + ")";
    }
  } else if (isConstructor) {
    return "new " + (functionName || '<anonymous>') + " (" + fileLocation + ")";
  } else if (functionName) {
    return "" + functionName + " (" + fileLocation + ")";
  } else {
    return fileLocation;
  }
};

Error.prepareStackTrace = function(err, stack) {
  var frame, frames;
  frames = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = stack.length; _i < _len; _i++) {
      frame = stack[_i];
      if (frame.getFunction() === exports.run) {
        break;
      }
      _results.push("  at " + (formatSourcePosition(frame)));
    }
    return _results;
  })();
  return "" + (err.toString()) + "\n" + (frames.join('\n')) + "\n";
};
