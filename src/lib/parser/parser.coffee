colors = require('colors')

{charset, isArray, wrapInfo1, wrapInfo2, str, entity} = require '../utils'

{extend, firstIdentifierChars, firstIdentifierCharSet, letterDigitSet, identifierChars,
digitCharSet, letterCharSet, identifierCharSet, firstSymbolCharset
taijiIdentifierCharSet, constant} = base = require './base'
digitChars = base.digits
letterChars = base.letters

{NUMBER,  STRING,  IDENTIFIER, SYMBOL, REGEXP,  HEAD_SPACES, CONCAT_LINE, PUNCTUATION, FUNCTION, C_BLOCK_COMMENT
PAREN, BRACKET, DATA_BRACKET, CURVE, INDENT_EXPRESSION
NEWLINE,  SPACES,  INLINE_COMMENT, SPACES_INLINE_COMMENT,
LINE_COMMENT, BLOCK_COMMENT, CODE_BLOCK_COMMENT,CONCAT_LINE
NON_INTERPOLATE_STRING, INTERPOLATE_STRING, EOI
INDENT, UNDENT, HALF_DENT, MODULE_HEADER, MODULE, SPACE_COMMENT, TAIL_COMMENT
SPACE, HASH, RIGHT_DELIMITER, KEYWORD, CONJUNCTION
CODE_BLOCK_COMMENT_LEAD_SYMBOL
PREFIX, SUFFIX, BINARY
END_INTERPOLATED_STRING

OPERATOR_EXPRESSION, COMPACT_CLAUSE_EXPRESSION, SPACE_CLAUSE_EXPRESSION, INTERPOLATE_EXPRESSION

} = constant

{prefixOperatorDict, suffixOperatorDict, binaryOperatorDict,
makeOperatorExpression, getOperatorExpression} = require './operator'

dict = (pairs...) ->
  d = {}; i = 0; pairsLength = pairs.length
  while i<pairsLength
    d[pairs[i]] = pairs[i+1]
    i += 2
  d

list2dict = (keys...) ->
  d = {}
  for k in keys then d[k] = 1
  d

exports.escapeNewLine = escapeNewLine = (s) -> (for c in s then (if c=='\n' then '\\n' else '\\r')).join('')

exports.keywordMap = keywordMap =
  'if': 1, 'try':1, 'switch':1, 'while':1, 'let':1, 'letrec!':1, 'letloop!':1, 'do':1, 'repeat':1
  'return':1, 'break':1, 'continue':1, 'throw':1,'function':1,'for':1
  'loop':1, 'class':1, 'var':1, 'for':1

keywordHasOwnProperty = Object.hasOwnProperty.bind(exports.keywordMap)

exports.isKeyword = isKeyword = (item) ->
  item and not item.escaped and hasOwnProperty.call(exports.keywordMap, item.text)

exports.conjMap = conjMap =
  'then':1, 'else':1, 'catch':1, 'finally':1, 'case':1, 'default':1, 'extends': 1
  'until':1, 'where':1, 'when':1
conjunctionHasOwnProperty = Object.hasOwnProperty.bind(exports.keywordMap)

exports.isConjunction = isConjunction = (item) ->
  item and not item.escaped and hasOwnProperty.call(exports.conjMap, item.text)

hasOwnProperty = Object::hasOwnProperty

begin = (exp) ->
  if not exp or not exp.push then return exp
  if exp.length==0 then ''
  else if exp.length==1 then exp[0]
  else exp.unshift('begin!'); exp

exports.Parser = ->
  parser = @; @predefined = predefined = {}
  unchangeable = ['cursor', 'setCursor', 'lineno', 'setLineno', 'atLineHead', 'atStatementHead', 'setAtStatementHead']

  # global variable used by lexer
  text = '' # text to be parsed
  textLength = 0 # total length of text to be parsed
  cursor = 0 # position pointer while do lexical parsing, use cur for local position pointer
  char = '' # current character, should assure char is the value of text[cursor] whenerver entering or leaving a function
  lineno = 0 # current line number, use line for local line number
  lineStart = 0 # start cursor of current line
  indent = 0 # global indent column of current line, use dent for local indent column
  atLineHead = true # global indicator to tell whether cursor is at the head of a line before any non space character
  interolateStringNumber = 0 # when entering interpolate string, increment by 1, when leaving, decrement by 1. when entering paren etc, multiplied by 2, when leaving, divided by 2 if even, (x-1)/2 if odd.

  token = undefined # global token generated by lexical parsing and used by the parser

  # global variable used by the syntax parser
  memoMap = {} # memorize the result for syntax matcher
  atStatementHead = true # whether is at head of statement
  environment = null # compiler environment used by dynamic evaluation while parsing
  endCursorOfDynamicBlockStack = [] # used by "then" block of ? clause to identifier end of dynamic block

  memoIndex = 0  # don't need be set in parser.init, memoMap need to be set instead.

  eof = {type:EOI, value:'', cursor: textLength, column: -1, indent: -1} # lineno wait to be filled
  eof.next = eof  # eof.next is always itself

  nextToken = ->
    if token.next then token = token.next
    else matchToken()

  #  tokenFnMap[char](char) and tokenOnSymbolChar should change the token
  @matchToken = matchToken = ->
    if not char
      if token==eof then return eof
      eof.lineno = lineno+1; lineStart = cursor; indent = -1
      token.next = eof
      return token = eof # while reaching the end of input, always return eof
    else if fn = tokenFnMap[char] then return token=fn(char)
    else return token=tokenOnSymbolChar()

  @token = -> token

  tokenFnMap = {}

  tokenOnSymbolChar = ->
    cur = cursor
    while char
      if symbolStopChars[char] then break

      # //, /*, /!
      # "/!" always start a regexp
      if char=='/' and ((c2=text[cursor+1])=='/' or c2=='*' or c2=='!') then break
      # else if c2=='.' # should not reach here, because this /. is always in the middle of the symbol, not in the front
      # "\" should not be concatenated symbol if following symbol characters
      #else if char=='\\' and ((c2=text[cursor+1])=='\n'  or c2=='\r') then break
      char = text[++cursor]

    token.next = {type:SYMBOL, value: text.slice(cur, cursor),
    cursor:cur, stopCursor:cursor, line: lineno, column:cursor-lineStart, indent:indent}

  symbolStopChars = extend charset(' \t\v\n\r()[]{},;:\'\".@\\'), identifierCharSet

  tokenFnMap['@'] = tokenFnMap['.'] = tokenOnAtChar = tokenOnDotChar = repeatedCharToken = ->
    cur = cursor; col = cursor-lineStart; first = char; char = text[++cursor]
    while char==first then char = text[++cursor]
    token.next = {type: SYMBOL, value: text.slice(cur, cursor),
    cursor:cur, stopCursor:cursor,
    line: lineno, column:col, indent:indent}

  tokenFnMap[':'] = tokenOnColonChar = ->
    cur = cursor; col = cursor-lineStart; first = char; char = text[++cursor]
    while char==first then char = text[++cursor]
    if cursor==cur+1 then type = PUNCTUATION else type = SYMBOL
    token.next = {type: type, value: text.slice(cur, cursor),
    cursor:cur, stopCursor:cursor,
    line: lineno, column:col, indent: indent}

  # the word "space" below maybe means not spacebar key or space character ' ' or '\t'
  # it means anything piece like white space, e.g. ' ', '\t', etc.

  concatenateLine = ->
    cur = cursor-1; col = cursor-lineStart; ind = indent
    if char=='\n'
      char = text[++cursor]
      if char=='\r' then char = text[++cursor]
    else if char=='\r'
      char = text[++cursor]
      if char=='\n' then char = text[++cursor]
    lineStart = cursor
    while (char=text[cursor]) and char==' ' then cursor++
    if char=='\t' then error 'do not allow use tab character "\t" at the head of line.'
    else if char=='\n' or char=='\r' then error 'should not follow empty line as concatenated line'
    else if not char then error 'unexpected end of input after concatenated line symbol "\"'
    indent = cursor-lineStart
    if indent<ind then error 'expect the same indent or more indent for the concatenated lines'
    skipInlineSpace()
    if (char=text[cursor])=='\n' or char=='\r'
      error 'concatenated line should not have only spaces and comments'
    return token.next = {type: SPACE, stopCursor: cursor,
    line:line, stopLine:lineno, column:col, stopColumn: cursor-lineStart, indent:ind, stopIndent:indent}

  # token started with ' ' and '\t'
  tokenFnMap[' '] = tokenFnMap['\t'] = tokenOnSpaceChar = ->
    cur = cursor; line = lineno; col = cursor-lineStart; dent = indent
    char = text[++cursor]
    skipInlineSpace(dent)
    if char=='\\'
      char = text[++cursor]
      if char=='\n' or c=='\r'
        token.next = tkn = concatenateLine()
        tkn.cursor = cur; tkn.col = col; tkn.value = text[cur...cursor]
        return tkn
      else
        cursor--
        return  token.next = {type:SPACE, value:text[cur...cursor], cursor:cur, stopCursor: cursor,
        line:line, stopLine:lineno, column:col, stopColumn: cursor-lineStart, indent: dent, stopIndent:indent}
    else if char=='\n' or char=='\r'
      skipSpaceLines(dent); indent = cursor-lineStart
      if not char then type = EOI
      else if indent>dent then type = INDENT
      else if indent<dent then type = UNDENT
      else type = NEWLINE
      return token.next = {type:type, value:text[cur...cursor], cursor:cur, line:line, column:col, indent: dent, stopIndent:indent}
    else
      return  token.next = {type:SPACE, value:text[cur...cursor], cursor:cur, stopCursor: cursor,
      line:line, stopLine:lineno, column:col, stopColumn: cursor-lineStart, indent: dent, stopIndent:indent}

  # should be called after a new line
  skipSpaceLines = (dent) ->
    if char=='\n'
      char = text[++cursor]
      if char=='\r' then char = text[++cursor]
    else if char=='\r'
      char = text[++cursor]
      if char=='\n' then char = text[++cursor]
    lineStart = cursor
    while 1
      if not char then return
      while char and char==' ' then cursor++; char = text[cursor]
      if char=='\t' then unexpectedTabCharAtLineHead()
      else if char=='\n'
        if char=='\r' then cursor += 2 else cursor++
        char = text[cursor];  lineno++; lineStart = cursor
        continue
      else if char=='\r'
        if char=='\n' then cursor += 2 else cursor++
        char = text[cursor];  lineno++; lineStart = cursor
        continue
      else if not char then break
      else if cursor-lineStart!=dent then break
      else if char=='/'
        if (c2=text[cursor+1])=='/'
          cursor += 2; char = text[cursor]
          # skip line tail
          while (char=text[cursor]) and char!='\n' and char!='\r' then cursor++; char = text[cursor]
          continue
        # indent block comment /. ... /
        else if c2=='.'
          if atLineHead then leftIndentBlockComment(dent); continue
          else break # will be normal symbol
        else if c2=='*'
          cursor += 2; char = text[cursor]; leftCBlockComment()
          skipInlineSpace()
          if char=='\n'
            if char=='\r' then cursor += 2 else cursor++
            char = text[cursor];  lineno++; lineStart = cursor
            continue
          else if char=='\r'
            if char=='\n' then cursor += 2 else cursor++
            char = text[cursor];  lineno++; lineStart = cursor
            continue
          else break

        # regexp /! ... /
        else if c2=='!' then break

        # else if atLineHead then break # switch to tokenOnForwardSlashChar to process code block comment start symbol
        else break
      else break

  # skipInlineSpace is called by tokenOnSpaceChar
  # skiptInlineSpace should not generate independent token and called independently
  skipInlineSpace = (dent) ->
    while 1
      while char==' ' or char=='\t' then char = text[++cursor]
      if char=='/'
        if (c2=text[cursor+1])=='*' then cursor +=2; char = text[cursor]; leftCBlockComment(dent); continue
        if c2=='/'
          # don't need to process column here, because want to skip characters until reaching new line
          cursor += 2; char = text[cursor]          
          while char!='\n' and char!='\r' then char = text[++cursor]; continue
          break
      break

  # \n\r, \r\n, \r, \n, don't eat spaces.
  @newline = newline = ->
    if (c=char)=='\r'
      cursor++;
      if (c2=text[cursor])=='\n' then cursor++; c2 = '\n'
      char = text[cursor]; lineno++; lineStart = cursor
    else if char=='\n'
      cursor++
      if (c2=text[cursor])=='\r' then cursor++; c2 = '\r'
      char = text[cursor]; lineno++; lineStart = cursor
    else return
    c+(c2 or '')

  # left indent block comment started with /., before entering this function, /. has been matched.
  leftIndentBlockComment = (dent) ->
    # skip line tail
    while char!='\n' and char!='\r' then cursor++; char = text[cursor]

    # skip lines that is empty or indent more spaces at the head
    while 1
      if char=='\n'
        if text[cursor+1]=='\r' then cursor+=2 else cursor++
        char = text[cursor]; lineno++; lineStart = cursor
        while char==' ' then cursor++; char = text[cursor]
        if char=='\n' or char=='\r' then continue
        if char=='\t' then unexpectedTabCharAtLineHead()
        if cursor-lineStart<=dent then break
      else if char=='\r'
        if text[cursor+1]=='\n' then cursor+=2 else cursor+=1
        char = text[cursor]; lineno++; lineStart = cursor
        while char==' ' then cursor++; char = text[cursor]
        if char=='\n' or char=='\r' then continue
        if char=='\t' then unexpectedTabCharAtLineHead()
        if cursor-lineStart<=dent then break
      else if not char then break

  # default /* some content */, can cross lines
  leftCBlockComment = (dent) ->
    # dent: the indent column of the line of '/*'
    while 1
      if char=='*' and text[cursor+1]=='/' then cursor += 2;  char = text[cursor]; break
      else if char=='\n'
        cursor++;  char = text[cursor]; lineno++
        if char=='\r' then cursor++;  char = text[cursor];
        lineStart = cursor
        while char==' ' then cursor++;  char = text[cursor]
        if char=='\t' then unexpectedTabCharAtLineHead()
        if char=='\n' or char=='\r' then continue
        else if not char then unexpectedEOI('while parsing c style block comment /* */')
        if lineStart-cursor<dent then expectMoreIndent(dent, 'while parsing c style block comment /* */')
      else if char=='\r'
        cursor++;  char = text[cursor]; lineno++
        if char=='\n' then cursor++; char = text[cursor]
        lineStart = cursor
        while char==' ' then cursor++;  char = text[cursor]
        if char=='\t' then unexpectedTabCharAtLineHead()
        if char=='\n' or char=='\r' then continue
        else if not char then unexpectedEOI('while parsing c style block comment /* */')
        if lineStart-cursor<dent then expectMoreIndent(dent)
      else if not char
        unexpectedEOI('while parsing c style block comment /* */')
      else cursor++;  char = text[cursor]

  leftRegexp = ->
    while char
      if char=='\\'
        if (c2=text[cursor+1]=='/') or c2=='\\' then cursor += 2; char = text[cursor]
        else char = text[cursor++]
      else if char=='\n' or char=='\r'
        error 'meet unexpected new line while parsing regular expression'
      else if char=='/'
        i = 0; char = text[++cursor]
        # console.log text.slice(cursor)
        while char
          if char=='i' or char=='g'or char=='m' then char = text[++cursor]; ++i
          else break
          if i>3 then error 'too many modifiers "igm" after regexp'
        return
      else char = text[++cursor]
    if not char then error 'unexpected end of input while parsing regexp'

  # back slash \ can be used to escape keyword, conjunction, symbol
  tokenFnMap['\\'] = tokenOnBackSlashChar = ->
    cur = cursor; col = cursor-lineStart; char = text[++cursor]
    if char=='\n' or char=='\r'
      token.next = tkn = concatenateLine()
      tkn.cursor = cur; tkn.column = col; tkn.value = text[cur...cursor]
      return tkn
    line = lineno
    if firstIdentifierCharSet[char]
      tkn = tokenOnIdentifierChar()
      tkn.escaped = true; tkn.cursor = cur
      return token.next = tkn
    else if firstSymbolCharset[char]
      tkn = tokenOnSymbolChar()
      tkn.escaped = true; tkn.cursor = cur; token.value = '\\'+token.value
      return token.next = tkn
    else if char==':'
      tkn = tokenOnColonChar()
      tkn.value = '\\'+tkn.value
      tkn.escaped = true; tkn.cursor = cur
      return token.next = tkn
    else if char=='@'
      tkn = tokenOnAtChar()
      tkn.value = '\\'+tkn.value
      tkn.escaped = true; tkn.cursor = cur
      return token.next = tkn
    else if char=='.'
      tkn = tokenOnDotChar()
      tkn.value = '\\'+tkn.value
      tkn.escaped = true; tkn.cursor = cur
      return token.next = tkn
    else if char=="'"
      tkn = tokenOnSingleQuoteChar()
      if text[cur+2]=="'" and text[cur+3]=="'"
        # do not escape '''...'''
        char = text[++cursor]
        return token.next = {type:SYMBOL, value:'\\', cursor:cur, stopCursor:cursor
        line:lineno, column:cur-lineStart, indent:indent, stopIndent:indent
        next:tkn}
      else
        for c in text[cur+2...tkn.stopCursor]
          if c=='\n' or c=='\r' then error 'unexpected new line characters in escaped string'
        tkn.escaped = true; tkn.cursor = cur
        return token.next = tkn
    # else if char=='"' # don't permit escape interpolated string
    else
      while char=text[++cursor]=='\\' then true
      return token.next = {type:SYMBOL, value:text[cur...cursor], cursor:cur, stopCursor:cursor
      line:lineno, column:cur-lineStart, indent:indent}

  tokenFnMap['/'] = tokenOnForwardSlashChar = ->
    # // start a line comment
    cur = cursor; col = cursor-lineStart; char = text[++cursor]; line = lineno; ind = indent
    if char=='/' # // leading line comment
      # skip line tail
      cursor++; char=text[cursor]
      while char and char!='\n' and char!='\r' then cursor++; char=text[cursor]
      skipSpaceLines(indent)
      if not char then type = EOI
      else if indent>ind then type = INDENT
      else if indent==ind then type = NEWLINE
      else type = UNDENT
      return token.next = {type:type, value: text[cur...cursor], cursor:cur, stopCursor:cursor, line:line, column:col, indent:ind, stopIndent:indent}
    # /* start a c style block comment
    else if char=='*'
      leftCBlockComment()
      skipInlineSpace()
      if not char then t = EOI
      else if char=='\n' or char=='\r'
        skipSpaceLines(ind)
        if not char then type = EOI
        else if indent>ind then type = INDENT
        else if indent==ind then type = NEWLINE
        else type = UNDENT
        return token.next = {type: type, value: text[cur...cursor], cursor:cur, stopCursor:cursor, line:line, column:col, indent:ind, stopIndent:indent}
      else
        type = SPACE
        return token.next = {type: type, value: text[cur...cursor], cursor:cur, stopCursor:cursor, line:line, column:col, indent:ind}
    # /! start a regexp
    else if char=='!'
      cur = cursor; cursor += 2; char = text[cursor]; col = cursor-lineStart
      leftRegexp()
      return token.next = {type:REGEXP, value:'/'+text[cur+1...cursor]
      cursor:cur, stopCursor:cursor, line:lineno, column: col}
    else if char=='.' # block comment /. multiple indented lines
      # block comment should never be generated at match_here
      # how to assure it?
      # when starting parsing the module body, use tokenOnSpaceChar to generate the first token
      # and then, only parse /. as indented block
      # but with global variable atLineHead, we do defensive style coding and simplify the design
      if atLineHead
        char = text[++cursor]
        leftIndentBlockComment(ind)
        skipSpaceLines(ind)
        if indent>ind then t = INDENT
        else if indent==ind then t = NEWLINE
        else t = UNDENT
        return token.next = {type: t, value: text[cur...cursor], cursor:cur, stopCursor:cursor, line:line, column:col, indent:ind}
      else
        # "/" return as independent symbol, left "." will be processed later, it and following "." maybe will become a symbol too.
        # a possible legal syntax is that "/" is used as a suffix operator and "." or ".." or "..." are used as a binary operator.
        # e.g. a/...b
        return token.next = {type: SYMBOL, value:"/", cursor:cur, stopCursor:cursor, line:line, indent:ind}
    else if atLineHead
      # the '/' at the head of one line should start a code block comment
      # which should be processed when meeting new line
      return token.next = {type:CODE_BLOCK_COMMENT_LEAD_SYMBOL, value:"/", cursor:cur, stopCursor:cursor, line:line, column:col, indent:ind}
    else
      # a symbol starts with "/"
      char = text[++cursor]; prev = token; tokenOnSymbolChar(); value = "/"+token.value
      token = {type:SYMBOL, value:value, cursor:cur, stopCursor:cursor, line:line, column:col, indent:ind}
      return prev.next = token

  # the token leaded by '\n', '\r', maybe return token with type NEWLINE, INDENT, UNDENT, EOI
  tokenFnMap['\n'] = tokenFnMap['\r'] = tokenOnNewlineChar = ->
    cur = cursor; line = lineno; col = cursor-lineStart; ind = indent
    skipSpaceLines(ind)
    if not char then type = EOI
    else if indent>ind then type = INDENT
    else if indent==ind then type = NEWLINE
    else type = UNDENT
    return token.next = {type:type, value:text[cur...cursor],
    cursor:cur, # stopCursor: cursor,
    line:line, stopLine: lineno,
    column:col, # stopColumn: column,
    indent: ind, stopIndent: indent}

  tokenOnIdentifierChar = ->
    cur = cursor; char = text[++cursor]; col = cursor-lineStart
    while char and identifierCharSet[char] then char=text[++cursor]
    txt=text.slice(cur, cursor)
    if keywordHasOwnProperty(txt) then type = KEYWORD
    else if conjunctionHasOwnProperty(txt) then type = CONJUNCTION
    else type = IDENTIFIER
    token.next = {type:type, value:txt
    cursor:cur, stopCursor: cursor,
    line: lineno, column: col, indent:indent}

  for c of firstIdentifierCharSet then tokenFnMap[c] = tokenOnIdentifierChar

  tokenOnNumberChar = ->
    cur = cursor; base = 10; col = cursor-lineStart
    if char=='0' and c2 = text[cursor+1]
      if c2=='b' or c2=='B' then base = 2; baseStart = cursor += 2; char = text[cursor]
      else if c2=='x' or c2=='X' then base = 16; baseStart = cursor += 2; char = text[cursor]
      else char = text[++cursor]; meetDigit = true
    if base==2
      while char
        if char=='0' or char=='1' then char = text[++cursor]
        else break
    else if base==16
      while char
        if  not('0'<=char<='9' or 'a'<=char<='f' or 'A'<=char<='F') then break
        else char = text[++cursor]
    if base==2
      if char=='.' or char=='e' or char=='E' then error 'binary number followed by ".eE"'
      else if '2'<=char<='9' then error 'binary number followed by 2-9'
    if base==16
      if char=='.' then error 'hexadecimal number followed by "."'
      else if letterCharSet[char] then error 'hexadecimal number followed by g-z or G-Z'
    if base!=10
      if cursor==baseStart
        # e.g 0x+3, 0x(1+2)
        cursor--; char = text[cursor]
        return token.next = { type: NUMBER, value: text[cur...cursor], value:0,
        cursor:cur, stopCursor:cursor
        line:lineno, column:col, indent:indent}
      else
        return token.next = { type: NUMBER, value:parseInt(text[baseStart...cursor], base),
        cursor:cur, line:lineno, column: col, indent:indent}
    # base==10
    while char
      if '0'<=char<='9' then meetDigit = true; char = text[++cursor]
      else break
    # if not meetDigit then return symbol() # comment because in no matchToken solution
    if not meetDigit then return
    if char=='.'
      meetDigit = false
      char = text[++cursor]
      while char
        if char<'0' or '9'<char then break
        else meetDigit = true; char = text[++cursor]
    dotCursor = cursor-1
    if not meetDigit and char!='e' and char!='E'
      cursor = dotCursor; char = text[cursor]
      return token.next = { type: NUMBER, value:parseInt(text[baseStart...cursor], base),
      cursor:cur, stopCursor:cursor
      line:lineno, column: col, indent:indent}
    if char=='e' or char=='E'
      char = text[++cursor]
      if char=='+' or char=='-'
        char = text[++cursor]
        if not char or char<'0' or '9'<char
          cursor = dotCursor; char = text[cursor]
          return token.next = { type: NUMBER, value:parseInt(text[cur...dotCursor], base),
          cursor:cur, stopCursor:cursor
          line:lineno, column: col, indent:indent}
        else
          while char
            char = text[++cursor]
            if  char<'0' or '9'<char then break
      else if not char or char<'0' or '9'<char
        cursor = dotCursor; char = text[cursor]
        return token.next = { type: NUMBER, value:parseInt(text[cur...dotCursor], base),
        cursor:cur, stopCursor:cursor
        line:lineno, column: col, indent:indent}
      else while char
          if  char<'0' or '9'<char then break
          char = text[++cursor]
    token.next = { type: NUMBER, value:parseFloat(text[cur...cursor], base),
    cursor:cur, stopCursor:cursor
    line:lineno, column: col, indent:indent}

  for c in '0123456789' then tokenFnMap[c] = tokenOnNumberChar

  tokenFnMap[','] =tokenOnCommaChar = ->
    cur = cursor; char = text[++cursor]
    token.next = {type:PUNCTUATION, value:',', line:lineno, stopLine: lineno,
    cursor:cursor, stopCursor:cursor, column: cur-lineStart
    clauseEnd: true}

  tokenFnMap[';'] = tokenOnSemiColonChar = ->
    cur = cursor; char = text[++cursor]
    token.next = {value:';', type:PUNCTUATION, line:lineno, stopLine: lineno,
    cursor:cursor, stopCursor:cursor, column: cur-lineStart,
    clauseEnd:true, sentenceEnd: true
    }

  # whether new line character is immediately following a concatenating character '\'
  # this is not affected embedded concatenated line in other structure.
  concatenating = false

  tokenFnMap["'"] = tokenOnSingleQuoteChar = ->
    char = text[++cursor]; col = cursor-lineStart
    if char=="'"
      if text[cursor+1]=="'"
        cursor += 2; char = text[cursor]
        return token.next = leftRawNonInterpolatedString()
      else
        char = text[++cursor]
        return token.next = {value:'""', type:NON_INTERPOLATE_STRING, cursor:cursor-2, line:lineno, column:col}
    else return token.next = leftNonInterpolatedString()

  leftRawNonInterpolatedString = ->
    cur = cursor-3; line = lineno
    if cursor==indent+3 then indentInfo = {indent:indent}
    else indentInfo = {}
    str = ''
    # the left characters of the same line after '''
    while char
      if char=="'"
        if text[cursor+1]=="'"
          if text[cursor+2]=="'"
            cursor += 3; char = text[cursor]
            return {type:NON_INTERPOLATE_STRING, value:'"'+str+'"', start:cur, stop:cursor, line:line, stopLine: lineno}
          else str += "''"; cursor += 2; char = text[cursor]
        else str += "'"; char = text[++cursor]
      else if char=='\\'
        # the '\' at end of line will not in the result string
        if (c=text[cursor+1])=='\n' or c=='\r'
          char = text[++cursor]; concatenating = true; break
        else str += '\\\\'; char = text[++cursor]
      else if char!='\n' and char!='\r' then str += char; char = text[++cursor]
      else break
    while char
      if char=="'"
        if text[cursor+1]=="'"
          if text[cursor+2]=="'"
            cursor += 3; char = text[cursor]
            return {type: NON_INTERPOLATE_STRING, value: '"'+str+'"', start:cur, stop:cursor, line:line, stopLine: lineno}
          else str += "''"; cursor += 2; char = text[cursor]
        else str += "'"; char = text[++cursor]
      else str += rawNonInterpolatedStringLine(indentInfo)
    if not text[cursor] then error "expect ''', unexpected end of input while parsing interpolated string"

  rawNonInterpolatedStringLine = (indentInfo) ->
    result = ''
    # new line character must be escaped.
    if char=='\n'
      if not concatenating then result += '\\n'
      char = text[++cursor]
      if char=='\r'
        if not concatenating then result += '\\r'
        char = text[++cursor]
    else
      if not concatenating then result += '\\r'
      char = text[++cursor]
      if char=='\n'
        if not concatenating then result += '\\n'
        char = text[++cursor]
    concatenating = false
    lineno++; cur = cursor
    while char==' ' then char = text[++cursor]
    column = cursor-lineStart
    if char=='\t' then error 'unexpected tab character "\t" at the head of line'
    else if char=='\n' or char=='\r' then result += text[cur...cursor]; return result
    else if (ind=indentInfo.value)!=undefined then indentInfo.value = column
    else if ind>column then i = 0; n = column-ind; while i++<n then result += ' '
    else if ind<column then error 'expect equal to or more than the indent of first line of the string'
    while char
      if char=="'"
        if text[cursor+1]=="'"
          if text[cursor+2]=="'" then return result
          else result += '\\"\\"'; cursor += 2; char = text[cursor]
        else result += '\\"'; char = text[++cursor]
      else if char=='\n' or char=='\r' then return result
      else if char=='\\'
        char = text[++cursor]
        if char=='\n' or char=='\r' then concatenating = true; return result
        if char then result += '\\\\'
        else error 'unexpected end of input while parsing non interpolated string'
      # '"' must be escaped, because all the string is wrapped in "..."
      else result += char; char = text[++cursor]
    error 'unexpected end of input while parsing non interpolated string'

  leftNonInterpolatedString = ->
    cur = cursor-1; line = lineno; col = cur-lineStart
    if cursor==indent+1 then indentInfo = {value:indent}
    else indentInfo = {}
    str = ''
    # the left characters of the same line after '''
    while char
      if char=="'"
        char = text[++cursor]
        return {type: NON_INTERPOLATE_STRING, value: '"'+str+'"', start:cur, stop:cursor, line:line, stopLine: line, column: col}
      else if char=='\\'
        # the '\' at end of line will not in the result string
        if (c=text[cursor+1])=='\n' or c=='\r' then char = text[++cursor]; concatenating = true; break
        else if c=="'" then str += "'"; cursor += 2; char = text[cursor]
        else str += '\\'; char = text[++cursor]
      else if char!='\n' and char!='\r' then str += char; char = text[++cursor]
      else break
    while char and char!="'" then str += nonInterpolatedStringLine(indentInfo)
    if char=="'"
      char = text[++cursor]
      return {type: NON_INTERPOLATE_STRING, value: '"'+str+'"', start:cur, stop:cursor, line:line, stopLine: lineno, column: col}
    else error "expect \"'\", unexpected end of input while parsing interpolated string"

  nonInterpolatedStringLine = (indentInfo) ->
    result = ''
    if char=='\n'
      if not concatenating then result += '\\n'
      char = text[++cursor]
      if char=='\r'
        result += '\\r'
        char = text[++cursor]
    else
      if not concatenating then result += '\r'
      char = text[++cursor]
      if char=='\\n'
        if not concatenating then result += '\\n'
        char = text[++cursor]
    concatenating = false
    lineno++; cur = cursor
    while char==' ' then char = text[++cursor]
    column = cursor-lineStart
    if char=='\t' then error 'unexpected tab character "\t" at the head of line'
    else if char=='\n' or char=='\r' then result += text[cur...cursor]; return result
    else if (ind=indentInfo.value)!=undefined then indentInfo.value = column
    else if ind>column then i = 0; n = column-ind; while i++<n then result += ' '
    else if ind<column then error 'expect equal to or more than the indent of first line of the string'
    while char
      if char=="'" then return result
      else if char=='\n' or char=='\r' then return result
      else if char=='\\'
        char = text[++cursor]
        # '\' at the end of line is omitted
        if char=='\n' or char=='\r' then return result
        else if char=="'" then result += "'"; char = text[++cursor]
        else if char then result += '\\'; result += char; char = text[++cursor]
        else error 'unexpected end of input while parsing non interpolated string'
      else if char=='"'  then result += '\\"'; char = text[++cursor]
      else result += char; char = text[++cursor]
    error 'unexpected end of input while parsing non interpolated string'

  tokenFnMap['"'] = tokenOnDoubleQuoteChar = ->
    char = text[++cursor]
    if char=='"'
      if text[cursor+1]=='"'
        cursor += 2; char = text[cursor]; tkn = token; interolateStringNumber++
        tkn2 = leftRawInterpolateString()
        interolateStringNumber--; tkn.next = tkn2
        return tkn2
      else
        char = text[++cursor]
        return token.next = {value:'""', type:NON_INTERPOLATE_STRING, lineno:lineno, cursor:cursor-2, column:cursor-2-lineStart}
    else
      tkn = token;  interolateStringNumber++
      tkn2 = leftInterpolateString()
      interolateStringNumber--; tkn.next = tkn2
      return tkn2

  @leftRawInterpolateString = leftRawInterpolateString = ->
    cur = cursor; line = lineno
    if cursor-lineStart==indent+3 then indentInfo = {value:indent} else indentInfo = {}
    pieces = []; str = '"'
    while char
      if char=='"'
        if text[cursor+1]=='"'
          if text[cursor+2]=='"'
            cursor += 3
            if str!='"' then pieces.push str += '"'
            return {type: INTERPOLATE_STRING, value: ['string!'].concat(pieces),
            cursor:cur, stopCursor: cursor,
            line:line, stopLine: line}
          else cursor += 2; char = text[cursor]
        else str += '"'; char = text[++cursor]
      else if char=='\n'
        if not concatenating then str += '\\n'
        char = text[++cursor]
        if char=='\r'
          if not concatenating then str += '\\r'
          char = text[++cursor]
        concatenating = false
        while 1
          lineno++
          while char==' ' then str += char; char = text[++cursor]
          if char=='\n'
            str += '\\n'; char = text[++cursor]
            if char=='\r' then str += '\\r'; char = text[++cursor]
            continue
          else if char=='\r'
            str += '\\r'; char = text[++cursor]
            if char=='\n' then str += '\\n'; char = text[++cursor]
            continue
          else break
        column = cursor-lineStart
        if char=='\t' then error 'unexpected tab character "\t" in the head of line'
        if indentInfo.value==undefined then indentInfo.value = column
        ind = indentInfo.value
        if ind<column then error 'expect equal to or more than the indent of first line of the string'
        else if ind>column then i = 0; n = column-ind; while i++<n then str += ' '
      else if char=='\r'
        if not concatenating then str += '\\r'
        char = text[++cursor]
        if char=='\n'
          if not concatenating then str += '\\n'
          char = text[++cursor]
        concatenating = false
        while 1
          lineno++
          while char==' ' then str += char; char = text[++cursor]
          if char=='\n'
            str += '\\n'; char = text[++cursor]
            if char=='\r' then str += '\\r'; char = text[++cursor]
            continue
          else if char=='\r'
            str += '\\r'; char = text[++cursor]
            if char=='\n' then str += '\\n'; char = text[++cursor]
            continue
          else break
        column = cursor-lineStart
        if char=='\t' then error 'unexpected tab character "\t" in the head of line'
        else if (ind=indentInfo.value)!=undefined then indentInfo.value = column
        else if ind>column then i = 0; n = column-ind; while i++<n then str += ' '
        else if ind<column then error 'expect equal to or more than the indent of first line of the string'
      else if char=='(' or char=='{' or char=='['
        # for efficiency, do not match next token while matching delimiter token (...), [...], {...} in tokenOnLeftParenChar, tokenOnLeftBracketChar, tokenOnLeftCurveChar
        str += char+'"'; pieces.push str; pieces = '"'; char = text[++cursor]
        matchToken()
        char = text[--cursor] # let )]} can be output into next piece
        pieces.push getOperatorExpression(token)
      else if  char=='$'
        if (char=text[++cursor])
          if not firstIdentifierCharSet[char] then str += '$'
          else char = '$'; --cursor; pieces.push str+'"'; str = '"'
        else break
      else if char=='$'
        literalStart = ++cursor; char = text[cursor]
        if not firstIdentifierCharSet[char] then str += '$'
        else
          x = parser.interpolateExpression()
          if text[cursor]==':'
            char = text[++cursor]
            pieces.push str+text[literalStart...cursor]+'"'; str = '"'
          else if str!='"' then pieces.push str+'"'; str = '"'
          pieces.push x
      else if char=='\\'
        char = text[++cursor]
        if char=='\n' or char=='\r' then concatenating = true
        else if char then str += '\\\\'
        else error 'unexpected end of input while parsing interpolated string'
      else str += char; char = text[++cursor]
    if not text[cursor] then error 'expect \'"\', unexpected end of input while parsing interpolated string'

  leftInterpolateString = ->
    cur = cursor-1; line = lineno
    if cursor-1-lineStart==indent+1 then indentInfo = {value:indent} else indentInfo = {}
    pieces = []; str = '"'
    while char
      if char=='"'
        if str!='"' then pieces.push str+'"'; char = text[++cursor]
        return {type: INTERPOLATE_STRING, value: ['string!'].concat(pieces),
        cursor:cur, stopCursor:cursor,
        line:line, stopLine: lineno}
      else if char=='\n'
        if not concatenating then str += char
        char = text[++cursor]
        if char=='\r'
          if not concatenating then str += char
          char = text[++cursor]
        concatenating = false
        while 1
          lineno++
          while char==' ' then str += char; char = text[++cursor]
          if char=='\n'
            str += char; char = text[++cursor]
            if char=='\r' then str += char; char = text[++cursor]
            continue
          else if char=='\r'
            str += char; char = text[++cursor]
            if char=='\n' then str += char; char = text[++cursor]
            continue
          else break
        column = cursor-lineStart
        if char=='\t' then error 'unexpected tab character "\t" in the head of line'
        else if indentInfo.value==undefined then indentInfo.value = column
        else
          ind = indentInfo.value
          if ind>column then i = 0; n = column-ind; while i++<n then result += ' '
          else if ind<column then error 'expect equal to or more than the indent of first line of the string'
      else if char=='\r'
        if not concatenating then str += char
        char = text[++cursor]
        if char=='\n'
          if not concatenating then str += char
          char = text[++cursor]
        concatenating = false
        while 1
          lineno++
          while char==' ' then str += char; char = text[++cursor]
          if char=='\n'
            str += char; char = text[++cursor]
            if char=='\r' then str += char; char = text[++cursor]
            continue
          else if char=='\r'
            str += char; char = text[++cursor]
            if char=='\n' then str += char; char = text[++cursor]
            continue
          else break
        column = cursor-lineStart
        if char=='\t' then error 'unexpected tab character "\t" in the head of line'
        else if indentInfo.value==undefined then indentInfo.value = column
        else
          ind = indentInfo.value
          if ind>column then i = 0; n = column-ind; while i++<n then result += ' '
          else if ind<column then error 'expect equal to or more than the indent of first line of the string'
      else if char=='$'
        literalStart = ++cursor; char = text[cursor]
        if not firstIdentifierCharSet[char] then str += '$'
        else
          x = parser.interpolateExpression()
          if text[cursor]==':'
            char = text[++cursor]
            pieces.push str+text[literalStart...cursor]+'"'; str = '"'
          else if str!='"' then pieces.push str+'"'; str = '"'
          pieces.push x
      else if char=='(' or char=='{' or char=='['
        # for efficiency, do not match next token while matching delimiter token (...), [...], {...} in tokenOnLeftParenChar, tokenOnLeftBracketChar, tokenOnLeftCurveChar
        pieces.push str+char+'"'; str = '"'
        matchToken()
        pieces.push getOperatorExpression(token)
        str = '"'+text[cursor-1]
      else if char=='\\'
        if not (char=text[++cursor]) then break
        else if char=='\n' or char=='\r' then char = text[++cursor]; concatenating = true
        else str += '\\'+char; char = text[++cursor]
      else str += char; char = text[++cursor]
    if not text[cursor] then error 'expect \'"\', but meet end of input while parsing interpolated string'

  # for efficiency, in tokenOnLeftParenChar, tokenOnLeftBracketChar, tokenOnLeftCurveChar
  # do not match next token while matching delimiter token (...), [...], {...}
  tokenFnMap['('] = tokenOnLeftParenChar = ->
    # skip "("
    cur = cursor; line = lineno; col = cursor-lineStart; char = text[++cursor]; ind = indent
    start = token; matchToken()
    if (parenVariantFn=parenVariantMap[token.value])
      token = parenVariantFn(); token.cursor = cursor; token.column = column; token.indent = ind
    else
      if (type=token.type)==UNDENT then error 'unexpected undent while parsing parenethis "(...)"'
      else if type==SPACE or type==NEWLINE or type==INDENT then matchToken()
      if token.value==')'
        token = {type: PAREN, value:undefined, cursor:cur, stopCursor: cursor,
        line:lineno, column:col}
        start.next = token
        return token
      exp = parser.operatorExpression()
      if token.type==UNDENT
        if token.stopIndent<ind then error 'expect ) indent equal to or more than ('
        else matchToken()
      else if token.value!=')' then error 'expect )'
      #else matchToken() # do not match token here, so token.next==undefined, and nextToken() will matchToken instead.
      char = text[++cursor]
      token = {type: PAREN, value:exp, cursor:cur, stopCursor: cursor, line:lineno, column:col}
    if interolateStringNumber%2 then  interolateStringNumber = (interolateStringNumber-1)/2
    else  interolateStringNumber %= 2
    start.next = token = token
    token

  parenVariantMap = {
  }

  tokenFnMap['['] = tokenOnLeftBracketChar = ->
    cur = cursor; char = text[++cursor]; line = lineno; col = cursor-lineStart; ind = indent
    start = token; matchToken()
    if (bracketVariantFn=bracketVariantMap[token.value])
      token = bracketVariantFn(); token.cursor = cursor; token.column = column; token.indent = ind
    else
      expList = parser.lineBlock()
      if token.type==UNDENT
        if token.stopIndent<ind then error 'unexpected undent while parsing parenethis "[...]"'
        else matchToken()
      if token.value!=']' then error 'expect ]'
      if expList then expList.unshift 'list!'
      else expList = []
      char = text[++cursor]
      token = {type: BRACKET, value:expList, cursor:cur, stopCursor: cursor, line:lineno, stopLine: lineno, column:col}
    start.next = token
    token

  bracketVariantMap = {}

  tokenFnMap['{'] = ->
    cur = cursor; cursor++; line = lineno; col = cursor-lineStart; ind = indent
    start = token; matchToken()
    if (curveVariantFn=curveVariantMap[token.value])
      token = curveVariantFn(); token.cursor = cursor; token.column = column; token.indent = ind
    else
      if token.value=='}' and matchToken()
        token = {value:text[cur...cursor], value:['hash!'], cursor:cur, line:line, column:col}
        start.next = token
        return start
      body = parser.lineBlock()
      if token.indent<ind then error 'unexpected undent while parsing parenethis "{...}"'
      if token.value!='}' then error 'expect }' else cursor++
      char = text[++cursor]
      if body.length==0 then return {type: CURVE, value:'', start:cur, stop: token}
      if body.length==1 then body = body[0]
      else body.unshift 'begin!'
    extend body, {type: CURVE, start:start, stop: cursor, line1:line1, line:lineno}

  curveVariantMap =
    '.': ->  matchToken(); return hash()

  @hash = ->
    cur = cursor; line1 = lineno; indentCol = lineInfo[lineno].indentCol
    if text[cursor...cursor+2]!='{.' then return else cursor += 2
    items = parser.hashBlock()
    if lineInfo[lineno].indentCol<indentCol then error 'unexpected undent while parsing parenethis "{.  ... .}"'
    if text[cursor...cursor+2]!='.}' then error 'expect .}' else cursor += 2
    wrapResult ['hash!'].concat(items), {start:cur, stop:cursor, line1:line1, line:lineno}

  @hashBlock = ->
    cur = cursor; line1 = lineno
    if (spac=bigSpace()) and spac.undent then return
    result = []; if spac.indent then indentCol = lineInfo[lineno].indentCol
    while (x=parser.hashItem()) and result.push x
      space()
      if not (c=text[cursor]) then break
      if c=='.'
        if text[cursor+1]=='}' then break
        else error 'unexpected ".", expect .} to close hash block'
      if c==';' then cursor++
      space2 = bigSpace()
      if not (c=text[cursor]) or c=='}' then break
      if lineno==line1 then continue
      if (col=lineInfo[lineno].indentCol)>column1
        if indentCol and col!=indentCol then error 'unconsistent indent in hash {. .}'
        else indentCol = col
      else if col==column1 then break
      else if col<column1 then rollbackToken space2; return
    result.start = cur; result.stop = cursor; result

  @hashItem = ->
    if isIndent(token) then error 'unexpected indent'
    else if isUndent(token) then return
    if key=parser.compactClauseExpression()
      if isMultiline(token) then error 'unexpected new line after hash key'
      if token.value==':' and matchToken()
        if (t=key.type)==IDENTIFIER or t==NUMBER or t==NON_INTERPOLATE_STRING then js = true
      else if text[cursor...cursor+2]=='=>' then cursor+=2
      else error 'expect : or => for hash item definition'
      if (spac=follow('spaceComment')) and spac.indent
        value = ['hash!'].concat parser.hashBlock()
      else value = parser.clause()
      if not value then error 'expect value of hash item'
      if js then result = ['jshashitem!', getOperatorExpression(key), value]
      else result = ['pyhashitem!', getOperatorExpression(key), value]
      wrapResult result, {start:cur, stop:cursor, line1:line1, line:lineno}

  tokenOnRightDelimiterChar = ->
    token.next = {type:RIGHT_DELIMITER, value:char, cursor:cursor, stopCursor:cursor,
    line:lineno, indent:indent, stopIndent:indent}

  for c in ')]}' then tokenFnMap[c] = tokenOnRightDelimiterChar

  @followMatch = followMatch = (fn) ->
    cur = cursor; line = lineno
    x = fn()
    cursor = cur; lineno = line
    x

  @follow = follow = (matcherName) ->
    cur = cursor; line = lineno
    x = parser[matcherName]()
    cursor = cur; lineno = line
    x

  @expect = expect = (matcherName, message) ->
    if not (x = parser[matcherName]()) then error message
    else x

  @followSequence = followSequence = (matcherList...) ->
    cur = cursor; line1 = lineno
    for matcherName in  matcherList
      if not (x=parser[matcherName]()) then break
    cursor = cur; lineno = line1
    x

  @followOneOf = (matcherList...) ->
    cur = cursor; line1 = lineno
    for matcherName in  matcherList
      cursor = cur; lineno = line1 # defensive coding style
      if x =  parser[matcherName]() then break
    cursor = cur; lineno = line1
    x

  @setText = (x) -> parser.text = text = x; x
  @cursor = -> cursor
  @setCursor = (x) -> cursor = x
  @atStatementHead = -> atStatementHead
  @setAtStatementHead = (x) -> atStatementHead = x
  @endOfInput = -> not text[cursor]

  @literal = literal = (string) ->
    length = string.length
    if text[cursor...cursor+length]==string then cursor += length; true

  wrapResult = (result, info) -> result.info = info; result

  @decimal = decimal = ->
    cur = cursor
    while c = text[cursor] then (if  '0'<=c<='9' then cursor++ else break)
    if cursor==cur then return
    {value: text[cur...cursor], cursor:cur}

  @symbolOrIdentifier = -> parser.symbol() or parser.identifier()

  atomTokenTypes = list2dict(IDENTIFIER,  NUMBER,  REGEXP,  PAREN, BRACKET, CURVE,  HASH,
  BRACKET,  PAREN,  SYMBOL, NON_INTERPOLATE_STRING,  INTERPOLATE_STRING, COMPACT_CLAUSE_EXPRESSION)

  @atom = (mode) ->
    if token.isCompactClauseExpression
      atomToken = token; nextToken(); return atomToken
    else if atomTokenTypes[(type=token.type)]
      atomToken = token; atomToken.priority = 1000; nextToken(); return atomToken

  # prefix operator don't need to be compared to current global priority
  @prefixOperator = (mode) ->
    # hasOwnProperty.call is necessary in order to avoid error while builtin attribute of object is defined prefix operator
    tokenText = token.value
    if not hasOwnProperty.call(prefixOperatorDict, tokenText) or  not (op=prefixOperatorDict[tokenText]) then return
    if token.escaped then return
    opToken = token; nextToken()
    if token.value=='.' and nextToken()
      if (type=token.type)==SPACE or type==INDENT or type==UNDENT or type==NEWLINE
        if mode==OPERATOR_EXPRESSION then error 'unexpected spaces after :'
        else token = opToken; return
    else if (type=token.type)==INDENT then error 'unexpected indent after prefix operator'
    else if type==NEWLINE then error 'unexpected new line after prefix operator'
    else if type==UNDENT then error 'unexpected undent after prefix operator'
    else if (tokenText=token.value)==")" or tokenText==']' or tokenText=="}" then error 'unexpected '+tokenText+' after prefix operator'
    else if type==SPACE then matchToken(); priInc = 300
    else priInc = 600
    opToken.symbol = op.symbol; opToken.priority = op.priority+priInc
    wrapResult opToken, {start:opToken}

  # suffix operator must be symbol, should follow space, right delimiters or punctuations.
  @suffixOperator = (mode, x) ->
    if token.type!=SYMBOL then return
    if (op=suffixOperatorDict[token.value])
      token.symbol = op.symbol; token.priority = op.priority+600
      opToken = token; matchToken()
      #  can not follow suffirx: SYMBOL IDENTIFIER  REGEXP PAREN BRACKET HASH etc
      if (type=token.type)==SPACE or type==NEWLINE or type==INDENT or type==UNDENT or type==EOI or type==RIGHT_DELIMITER\
          or (value=token.value)==':' or value==',' or value==';'
        return wrapResult opToken, {start: opToken}
      else token = opToken; return

  parser.clauseEnd = (spac) ->
    cur = cursor; line1 = lineno
    spac = spac or bigSpace()
    if (c=text[cursor])==','
      if not spac.inline then error '"," should not be at the head of a line'
      cursor++; return true
    if parser.sentenceEnd(spac) or c==';' then  rollbackToken spac; return true

  binaryOperatorMemoIndex = memoIndex
  memoIndex += 5

  @binaryOperator = (mode, x) ->
    if token.isBinaryOperator then opToken = token; nextToken(); return opToken
    if m=token[binaryOperatorMemoIndex+mode] then token = m.next; return m.result
    if (type=token.type)==EOI or type==UNDENT or type==RIGHT_DELIMITER \
        or (mode!=OPERATOR_EXPRESSION and (type==NEWLINE or type==INDENT or type==PUNCTUATION))\
        or ((mode==COMPACT_CLAUSE_EXPRESSION or mode==INTERPOLATE_EXPRESSION) and type==SPACE)\
        or (mode==INTERPOLATE_EXPRESSION and (char=="'" or char=='"'))
      token[binaryOperatorMemoIndex+mode] = {result:null, next:token}
      return
    start = token
    if (op=binaryDictOperator(mode, x)) \
        or ((token=start) and (fn=customBinaryOperatorFnMap[type]) and (op=fn(mode, x)))
      token[binaryOperatorMemoIndex+mode] = {result:op, next:token}
      return op
    else token = start; return

  binaryDictOperator = (mode, x) ->
    if (type1=token.type)==SPACE then priInc = 300; nextToken()
    else if type1==NEWLINE or type1==INDENT then priInc = 0; nextToken()
    else priInc = 600; if token.value=='.' then nextToken()
    opValue = token.value
    if not hasOwnProperty.call(binaryOperatorDict, opValue) or not (op=binaryOperatorDict[opValue]) then return
    opToken = token; nextToken()
    if token.value=='.'
      if priInc!=600 then error 'unexpected "." after binary operator '+opToken.value+', here should be spaces, comment or newline'
      else nextToken()
    if (value=token.value)==',' or value==';' or value==':'  or (type=token.type)==NEWLINE or type==UNDENT or type==EOI\
      or (mode==INTERPOLATE_EXPRESSION and (char=="'" or char=='"')) then return
    if (type=token.type)==UNDENT then error 'unexpected undent after binary operator "'+opToken.value+'"'
    else if type==EOI then error 'unexpected end of input, expect right operand after binary operator'
    else if token.type==RIGHT_DELIMITER then return
    if priInc==600
      if type==SPACE
        if op.value==',' then priInc = 300; nextToken()
        else if (c=text[cursor])==';' then error 'unexpected ;'
        else error 'unexpected spaces or new lines after binary operator "'+op.value+'" before which there is no space.'
    else if priInc==300
      if type==UNDENT then error 'unexpceted undent after binary operator '+op.value
      else if type==NEWLINE then priInc = 0
      else if type==INDENT then priInc = 0; indentExpression()
      else if type==SPACE then nextToken()
      else
        if mode==OPERATOR_EXPRESSION then error 'binary operator '+op.value+' should have spaces at its right side.'
        else token = start
      # below must in operator expression (...) mode, not in clause mode.
    else
      # any operator near newline always have the priority 300, i.e. compute from up to down
      if opValue==',' or opValue==':' or opValue=='%'  or op.assign
        error 'binary operator '+op.symbol+' should not be at begin of line'
      if type==UNDENT then error 'binary operator should not be at end of block'
      else if type==NEWLINE then error 'a single binary operator should not occupy whole line.'
      else if type==SPACE then nextToken()
      if type1==INDENT # the token before operator token is indent token
        priInc = 0; indentExpression()
    opToken.symbol = op.symbol; opToken.priority = op.priority+priInc
    opToken

  indentExpression = ->
    indentStart = token
    indentExp = parser.expression(mode, 0, true)
    if (type=nextToken().type)!=UNDENT and type!=EOI and token.value!=')'
      error 'expect an undent after a indented block expression'
    indentExp.priority = 1000
    nextToken()
    token = indentStart

  customBinaryOperatorFnMap = {}

  customBinaryOperatorFnMap[PAREN] = (mode, x) ->
    {symbol:'call()', type: SYMBOL, priority: 800, start:token}

  customBinaryOperatorFnMap[BRACKET] = (mode, x) ->
    {symbol:'index[]', type: SYMBOL, priority: 800, start:token}

  customBinaryOperatorFnMap[IDENTIFIER] = (mode, x) ->
    cur = token.cursor
    if (x.value=='@' and x.stopCursor==cur) or (text[cur-2...cur]=='::' and text[cur-3]!=':')
      {symbol:'attribute!', type: SYMBOL, priority: 800, start:token}

  customBinaryOperatorFnMap[SYMBOL] = (mode, x) ->
    tkn = token
    if (value=tkn.value)=='#' and nextToken()
      return {symbol:'#()', type: SYMBOL, priority: 800, start:tkn}
    else if value=='::'
        return {symbol:'attribute!', type: SYMBOL, start:tkn, priority: 800}
    else if value=="." and (tkn=token) and nextToken()
      if token.type==IDENTIFIER
        return {symbol:'attribute!', type: SYMBOL, start:tkn, priority: 800}

#  # any binary function can be used as binary exports, and the priority to be used actually is set here.
#  @binaryFunctionPriority = 35

  @prefixExpression = (mode, priority) ->
    start = token
    # current global prority doesn't affect prefixOperator
    if op=parser.prefixOperator(mode)
      pri = if priority>op.priority then priority else op.priority
      x = parser.expression(mode, pri, true)
      if x then wrapResult makeOperatorExpression(PREFIX, op, x), {start:start, stop:token}

  expressionMemoIndex = memoIndex
  memoIndex += 5
  @expression = expression = (mode, priority, leftAssoc) ->
    indexMode = expressionMemoIndex+mode; start = token
    if result=start[indexMode] then token = result.next; return result.value
    if not x = parser.prefixExpression(mode, priority)
      if not x = parser.atom(mode) then start[memoIndex+mode] = {value:null, next:token}; return
    while 1
      tkn1 = token
      if (op = parser.suffixOperator(mode, x))
        if op.priority>=priority
          x = wrapResult makeOperatorExpression(SUFFIX, op, x), {start:start, stop:token}
        else token = tkn1; break
      else break
    # the priority and association of suffix operator does not affect the following expression
    while 1
      tkn2 = token
      if (op=parser.binaryOperator(mode, x))
        if ((leftAssoc and (opPri=op.priority)>priority) or (not leftAssoc and opPri>=priority))
          # should assure that a right operand is here while parsing binary operator
          y = expression(mode, opPri, not op.rightAssoc)
          x = wrapResult makeOperatorExpression(BINARY, op, x, y), {start:start, stop:token}
        else token = tkn2; break
      else break
    if token!=tkn1
      while 1
        tkn = token
        if (op = parser.suffixOperator(mode, x))
          if op.priority>=priority
            x = wrapResult makeOperatorExpression(SUFFIX, op, x), {start:start, stop:token}
          else token = tkn; break
        else break
    start[indexMode] = {value:x, next:token}
    x

  # the priority of operator vary from 0 to 300,
  # if there is no space between them, then add 600, if there is spaces, then add 300.
  # if meet newline, add 0.
  @operatorExpression = operatorExpression = -> parser.expression(OPERATOR_EXPRESSION, 0, true)

  # compact expression as clause item.
  @compactClauseExpression = ->
    result = parser.expression(COMPACT_CLAUSE_EXPRESSION, 600, true)
    if result then result.isCompactClauseExpression = true
    result

  # space expression as clause item.
  @spaceClauseExpression = spaceClauseExpression = ->
    if token.type==SPACE then nextToken()
    parser.expression(SPACE_CLAUSE_EXPRESSION, 300, true)

  # interpolate expression embedded in string
  @interpolateExpression = ->
    exp = tokenOnIdentifierChar()
    exp.start = exp.stop = start = exp
    while 1
      cur = cursor
      if (char=text[cursor])=='.'
        if char=text[++cursor] and firstIdentifierCharSet[char] and (id=tokenOnIdentifierChar())
          exp = ['attribute!', exp, id]
          id.start = id; id.stop = id; exp.start = start; exp.stop = id
        else break
      else if char=='['
        if (tkn=tokenOnLeftBracketChar()) and token.type==BRACKET
          exp = ['index!', exp, tkn]
          exp.start = start; exp.stop = tkn
        else error 'error while parsing "[" leading interpolate expression in double qoute string'
      else cursor = cur; break
    exp

  @isIdentifier = isIdentifier = (item) -> item.type==IDENTIFIER

  @itemToParameter = itemToParameter = (item) ->
    if item.type==IDENTIFIER then return item
    else if item0=item[0]
      if item0=='attribute!' and item[1].text=='@' then return item
      else if item0.symbol=='x...'
        parser.meetEllipsis = item[1].ellipsis = true
        return item
      else if entity(item0)=='=' # default parameter
        # default parameter should not be ellipsis parameter at the same time
        # and this is the behavior in coffee-script too
        # and (item01[0].symbol!='x...' or not isIdentifier(item01[1]).type==IDENTIFIER)
        if (item1=item[1]) and item1.type==IDENTIFIER then return item
        else if ((item10=item1[0]) and item10=='attribute!' and item1[1].text=='@') then return item
        else return
      # for dynamic parser and writing macro
      else if item0.symbol=='unquote!' or item0.symbol=='unquote-splice'
        return item

  @toParameters = toParameters = (item) ->
    if not item then return []
    if x=itemToParameter(item) then return [x]
    else if item[0]==','
      result = for x in item[1...]
        if not(param=itemToParameter(x)) then meetError = true; break
        if param.ellipsis
          if meetEllipsis then meetError = true; break
          else meetEllipsis = true
        param
      if not meetError then result

  @labelStatement = ->
    start = cursor; line1 = lineno
    if not (lbl=parser.jsIdentifier()) then return
    if text[cursor]!='#' then cursor = start; return
    cursor++
    if (spac=bigSpace()) and (not spac.text or spac.undent or spac.newline)  then cursor = start; return
    if clause=parser.clause() then clause = ['label!', lbl, clause]
    else clause = ['label!', lbl, '']
    extend clause, {start:start, stop:cursor, line1:line1, line:lineno}

  @conjunction = ->
    start = cursor
    if (x=symbol() or taijiIdentifier()) and isConjunction(x) then return x
    cursor = start; return

  @expectIndentConj = expectIndentConj = (word, line1, isHeadStatement, options, clauseFn) ->
    start2 = cursor; line2 = lineno
    if options.optionalClause? then optionalClause = options.optionalClause
    else optionalClause = word!='then'
    if options.optionalWord? then optionalWord = options.optionalWord
    else optionalWord = word=='then'
    indentCol = lineInfo[line1].indentCol
    spac = bigSpace(); col = lineInfo[lineno].indentCol
    if col==indentCol and lineno!=line1 and not isHeadStatement
      if not optionalClause
        error 'meet new line, expect inline keyword "'+word+'" for inline statement'
      else rollbackToken spac; return
    if col<indentCol
      if not optionalClause then error 'unexpected undent, expect '+word
      else rollbackToken spac; return
    else if col>indentCol
      if options.indentCol
        if col!=options.indentCol then error 'unconsistent indent'
      else options.indentCol = col
    w = taijiIdentifier()
    meetWord = w and w.text==word
    if not meetWord
      if isConjunction(w)
        if optionalClause then rollbackToken spac; return
        else  error 'unexpected '+w.text+', expect '+word+' clause'
      else if (not optionalWord and not optionalClause) or (
          not optionalClause and optionalWord and spac.inline)
        if word!='then' or not options.colonAtEndOfLine then error 'expect keyword '+word
      else if not optionalWord then return rollbackToken spac
      else if optionalClause then return rollbackToken spac
    if not meetWord then rollback start2, line2
    clauseFn()

  conjClause = (conj, line1, isHeadStatement, options) ->
    begin(expectIndentConj conj, line1, isHeadStatement, options, parser.lineBlock)

  thenClause  = (line1, isHeadStatement, options) -> conjClause 'then', line1, isHeadStatement, options
  elseClause  = (line1, isHeadStatement, options) -> conjClause 'else', line1, isHeadStatement, options
  finallyClause  = (line1, isHeadStatement, options) -> conjClause 'finally', line1, isHeadStatement, options
  catchClause = (line1, isHeadStatement, options) ->
    expectIndentConj 'catch', line1, isHeadStatement, options, ->
      line2 = lineno; space(); atStatementHead = false
      catchVar = parser.identifier(); space(); then_ = thenClause(line2, false, {})
      [catchVar, then_]

  caseClauseOfSwitchStatement = (line1, isHeadStatement, options) ->
    expectIndentConj 'case', line1, isHeadStatement, options, ->
      line2 = lineno; space(); atStatementHead = false
      exp = parser.compactClauseExpression()
      #if exp.isBracket then exp.shift()
      if exp[0]!='list!' then exp = ['list!', exp]
      space(); expectChar(':', 'expect ":" after case values')
      body = parser.block() or parser.lineBlock()
      [exp, begin(body)]

  @keyword = ->
    start = cursor
    if (x=symbol() or taijiIdentifier()) and isKeyword(x) then return x
    cursor = start; return

  # if test then action else action
  keywordThenElseStatement = (keyword) -> (isHeadStatement) ->
    line1 = lineno; space()
    if not (test=parser.clause())? then error 'expect a clause after "'+keyword+'"'
    then_ = thenClause(line1, isHeadStatement, options={colonAtEndOfLine: test.colonAtEndOfLine})
    else_ = elseClause(line1, isHeadStatement, options)
    if else_ then [keyword, test, then_, else_]
    else [keyword, test, then_]

  # while! test body...
  keywordTestExpressionBodyStatement = (keyword) -> (isHeadStatement) ->
    line1 = lineno; space()
    if not (test = parser.compactClauseExpression())
      error 'expect a compact clause expression after "'+keyword+'"'
    if not (body = parser.lineBlock()) then error 'expect the body for while! statement'
    [keyword, test, begin(body)]

  # throw or return value
  throwReturnStatement = (keyword) -> (isHeadStatement) ->
    space(); if text[cursor]==':' and text[cursor+1]!=':' then cursor++; space();
    if clause = parser.clause() then [keyword, clause] else [keyword]

  # break; continue
  breakContinueStatement = (keyword) -> (isHeadStatement) ->
    space()
    if lbl = jsIdentifier() then [keyword, lbl] else [keyword]

  letLikeStatement = (keyword) -> (isHeadStatement) ->
    line1 = lineno; space()
    varDesc = parser.varInitList() or parser.clause()
    [keyword, varDesc, thenClause(line1, isHeadStatement, {})]

  # no cursor and lineno is attached in result, so can not be memorized directly.
  @identifierLine = ->
    result = []
    while space() and not parser.lineEnd() and not follow('newline') and text[cursor]!=';'
      if x=parser.identifier() then result.push x
      else error 'expect an identifier'
    result

  # no cursor and lineno is attached in result, so can not be memorized directly.
  @identifierList = ->
    line1 = lineno; indentCol = lineInfo[line1].indentCol
    result = parser.identifierLine()
    spac = bigSpace();
    if (col0=lineInfo[lineno].indentCol)<=indentCol
      rollbackToken spac; return result
    if text[cursor]==';' then return result
    while varList=parser.identifierLine()
      result.push.apply result, varList
      spac = bigSpace()
      if (col=lineInfo[lineno].indentCol)<=indentCol then rollbackToken spac; break
      else if col!=col0 then error 'inconsistent indent of multiple identifiers lines after extern!'
      if text[cursor]==';' then break
    result

  @varInit = ->
    if not (id = parser.identifier()) then return
    space()
    if text[cursor]=='=' and cursor++
      if value=parser.block() then value = begin(value)
      else if not(value=parser.clause()) then error 'expect a value after "=" in variable initilization'
    space()
    if text[cursor]==',' then cursor++
    if not value then return id else return [id, '=', value]

  @varInitList = ->
    start = cursor; line1 = lineno; result = []
    indentCol0 = lineInfo[lineno].indentCol
    spac = bigSpace()
    col = lineInfo[lineno].indentCol
    if col>indentCol0 then indentCol1 = col
    else if spac.undent or spac.newline then error 'unexpected new line, expect at least one variable in var statement'
    while 1
      if x=parser.varInit() then result.push x
      else break
      space1 = bigSpace()
      col = lineInfo[lineno].indentCol
      if not text[cursor] or text[cursor]==';' or follow 'rightDelimiter' then break
      if lineno==line1 then continue
      if col>indentCol0
        if indentCol1 and col!=indentCol1 then error 'unconsitent indent in var initialization block'
        else if not indentCol1 then indentCol1 = col
      else if col==indentCol0 then break
      else rollbackToken space1
    # if not result.length then error 'expect at least one variable in var statement'
    if not result.length then rollback start, line1; return
    return result

  @importItem = ->
    start = cursor; line1 = lineno
    sym = parser.symbol()
    if sym and (symValue=sym.text)!='#' and symValue!='#/'
      error 'unexpected symbol after "as" in import! statement'
    name = parser.identifier()
    if name
      if name.text=='from'
        if sym
          error 'keyword "from" should not follow "#" or "#/" immediately in import! statement, expect variable name instead'
        else return rollback(start, lineno)
    else if text[cursor]=="'" or text[cursor]=='"'
      if sym
        error 'file path should not follow "#" or "#/" immediately in import! statement, expect variable name instead'
      else return  rollback(start, lineno)
    space()
    start1 = cursor; line2 = lineno
    if (as_=taijiIdentifier())
      if as_.text=='from' then as_ = undefined; rollback start1, line2
      else if as_.text!='as' then error 'unexpected word '+as_.text+', expect "as", "," or "from [module path...]"'
      else
        space()
        sym2 = parser.symbol()
        if sym2 and (symValue2=sym2.text)!='#' and symValue2!='#/'
          error 'unexpected symbol after "as" in import! statement'
        if symValue=='#/'
          if symValue2=='#'
            error 'expect "as #/alias" or or "as alias #alias2" after "#/'+name.text+'"'
        else if symValue=='#'
          if not symValue
            error 'meta variable can not be imported as runtime variable'
          else if symValue=='#/'
            error 'meta variable can not be imported as both meta and runtime variable'
        else if not symValue
          if symValue2=='#'
            error 'runtime variable can not be imported as meta variable'
          else if symValue2=='#/'
            'runtime variable can not be imported as both meta and runtime variable'
        space(); asName = expectIdentifier()
        if symValue=='#/' and not symValue2
          space(); sym3 = parser.symbol()
          if not sym3 then error 'expect # after "#/'+name.text+' as '+asName.text+'"'
          else if sym3.text!='#' then error 'unexpected '+sym3.text+' after "#/'+name.text+'as '+asName.text+'"'
          asName2 = expectIdentifier()
    if not as_
      if symValue=='#/' then return [[name, name], [name, name, 'meta']]
      else if symValue=='#' then return [[name, name, 'meta']]
      else return [[name, name]]
    else
      if symValue=='#/'
        if asName2 then return [[name, asName], [name,asName2, 'meta']]
        else return [[name, asName], [name,asName, 'meta']]
      else if symValue=='#' then return [[name, asName, 'meta']]
      else return [[name, asName]]

  @exportItem = ->
    runtime = undefined
    if text[cursor...cursor+2]=='#/' then cursor+=2; runtime = 'runtime'; meta = 'meta'; space()
    else if (c=text[cursor])=='#' then cursor++; meta = 'meta'; space()
    else runtime = 'runtime'
    if meta then name = expectIdentifier()
    else if not (name = taijiIdentifier()) then return
    space()
    if text[cursor]=='=' and cursor++
      space(); value = parser.spaceClauseExpression(); space()
    [name, value, runtime, meta]

  @spaceComma = spaceComma = -> space(); if text[cursor]==',' then cursor++; space(); return true
  @seperatorList = seperatorList = (item, seperator) ->
    if typeof item=='string' then item = parser[item]
    ->
      result = []
      while x=item()
        result.push x
        if seperator() then continue
        else break
      result

  @importItemList = seperatorList('importItem', spaceComma)

  @exportItemList = seperatorList('exportItem', spaceComma)

  @expectIdentifier = expectIdentifier = (message) ->
    if id=parser.identifier() then return id
    else error message or 'expect identifier'

  @expectOneOfWords = expectOneOfWords = (words...) ->
    space(); token = taijiIdentifier();
    if not token then error 'expect one of the words: '+words.join(' ')
    value = token.value; i = 0; length = words.length;
    while i<length then (if value==words[i] then return words[i] else i++)
    error 'expect one of the words: '+words.join(' ')

  maybeOneOfWords = (words...) ->
    space(); token = taijiIdentifier();
    if not token then return
    value = token.value; i = 0; length = words.length;
    while i<length then (if value==words[i] then return words[i] else i++)
    return
  expectWord = (word) -> space(); (if not (token=taijiIdentifier()) or token.value!=word then error 'expect '+ word); word
  word = (w) ->
    start = cursor; line1 = lineno; space()
    if not token=taijiIdentifier() then return
    if token.value!=w then return rollback(start, line1)
    return token

  @expectChar = expectChar = (c) -> if text[cursor]==c then cursor++ else error 'expect "'+c+'"'

  @endOfDynamicBlock = @eob = ->
    if cursor==endCursorOfDynamicBlockStack[-1] then return true
    else return false

  @keywordToStatementMap =
    '%': (isHeadStatement) ->
      start = cursor; line1 = lineno
      if not space().text then return
      leadClause = parser.clause()
      code = compileExp(['return', ['%/', leadClause]], environment)
      space(); indentCol = lineInfo[lineno].indentCol
      if expectWord('then') or (text[cursor]==':' and cursor++)
        space()
        if newline()
          blockStopLineno = lineno
          while lineInfo[blockStopLineno].indentCol>indentCol and blockStopLineno<maxLine
            blockStopLineno++
          cursorAtEndOfDynamicBlock = lineInfo[blockStopLineno].indentCol or text.length
        else
          blockStopLineno = lineno+1
          cursorAtEndOfDynamicBlock = lineInfo[blockStopLineno].indentCol or text.length
      else error 'expect "then" or ":"'
      endCursorOfDynamicBlockStack.push cursorAtEndOfDynamicBlock
      result = new Function('__$taiji_$_$parser__', code)(parser)
      endCursorOfDynamicBlockStack.pop()
      cursor = cursorAtEndOfDynamicBlock; lineno = blockStopLineno
      if Object::toString.call(result) == '[object Array]'
        extend result, {start: start, stop:cursor, line1: line, lineno:lineno}
      else {value: result, start: start, stop:cursor, line1: line1, lineno:lineno}

    'break': breakContinueStatement('break')
    'continue': breakContinueStatement('continue')
    'throw': throwReturnStatement('throw')
    'return': throwReturnStatement('return')
    'new': throwReturnStatement('new')

    'var': (isHeadStatement) -> ['var'].concat parser.varInitList()
    'extern!': (isHeadStatement) -> ['extern!'].concat parser.identifierList()
    'include!': (isHeadStatement) ->
      space(); filePath = expect('string', 'expect a file path')
      space()
      if word('by')
        space(); parseMethod = expect('taijiIdentifier', 'expect a parser method')
      ['include!', filePath, parseMethod]

    # import [#/]name [as [#/]name] ... from path as [#/]name #name [by method]
    'import!': (isHeadStatement) ->
      space()
      items = parser.importItemList(); space()
      if items.length then from_ = expectWord('from') # or items[0][2]
      else from_ = word('from')
      #if not from_ then return ['import!', names[0][0], names[0][1], []]
      space(); srcModule = parser.string(); space();
      if as_ = literal('as')
        space()
        sym = parser.symbol()
        if sym
          if (symValue=sym.text)!='#' and sym.text!='#/'
            error 'unexpected symbol before import module name', sym
        alias = expectIdentifier('expect an alias for module')
        if symValue=='#' then metaAlias = alias; alias = undefined
        else if symValue=='#/' then metaAlias = alias
        space()
        sym2 = parser.symbol()
        if sym and sym2 then error 'unexpected symbol after meta alias'
        space(); alias2 = parser.identifier()
        # sym is the first symbol # or #/
        if sym  and alias2 then 'unexpected identifier '+alias2+' after '+symValue+alias
        if alias2 then metaAlias = alias2
        space()
      if word('by')
        space(); parseMethod = expect('taijiIdentifier', 'expect a parser method')
      runtimeImportList = []; metaImportList = []
      for item in items
        for x in item
          if x[2] then  metaImportList.push x
          else runtimeImportList.push x
      ['import!'].concat [srcModule, parseMethod, alias, metaAlias, runtimeImportList, metaImportList]

    'export!': (isHeadStatement) -> space(); ['export!'].concat parser.exportItemList()

    'let': letLikeStatement('let')
    'letrec!': letLikeStatement('letrec!')
    'letloop!': letLikeStatement('letloop!')
    'if': keywordThenElseStatement('if')
    'while': keywordThenElseStatement('while')
    'while!': keywordTestExpressionBodyStatement('while!')

    'for': (isHeadStatement) ->
      line1 = lineno; space()
      if text[cursor]=='(' and cursor++
        init = parser.clause(); space(); expectChar(';')
        test = parser.clause(); space(); expectChar(';')
        step = parser.clause(); space(); expectChar(')')
        return ['cFor!', init, test, step, thenClause(line1, isHeadStatement, {})]
      name1 = expectIdentifier(); space()
      if text[cursor]==',' then cursor++; space()
      if (token=jsIdentifier()) and value=token.value
        if value=='in' or value=='of' then inOf = value
        else name2 = value; space(); inOf = expectOneOfWords('in', 'of')
        space(); obj = parser.clause()
      if name2
        if inOf=='in' then kw = 'forIn!!' else kw = 'forOf!!'
        [kw, name1, name2, obj, thenClause(line1, isHeadStatement, {})]
      else
        if inOf=='in' then kw = 'forIn!' else kw = 'forOf!'
        [kw, name1, obj, thenClause(line1, isHeadStatement, {})]

    'do': (isHeadStatement) ->
      line1 = lineno; space(); indentCol = lineInfo[lineno].indentCol
      body = parser.lineBlock()
      if newlineFromLine(line1, lineno) and not isHeadStatement then return body
      if not (conj=maybeOneOfWords('where', 'when', 'until'))
        error 'expect conjunction where, when or until'
      if conj=='where' then tailClause = parser.varInitList()
      else tailClause = parser.clause()
      if conj=='where' then ['let', tailClause, body]
      else if conj=='when' then ['doWhile!', body, tailClause]
      else ['doWhile!', body, ['!x', tailClause]]

    'switch': (isHeadStatement) ->
      line1 = lineno
      if not (test = parser.clause()) then error 'expect a clause after "switch"'
      options = {}; cases = ['list!']
      while case_=caseClauseOfSwitchStatement(line1, isHeadStatement, options) then cases.push case_
      else_ = elseClause(line1, isHeadStatement, options)
      ['switch', test, cases, else_]

    'try': (isHeadStatement) ->
      line1 = lineno;
      if not (test = parser.lineBlock()) then error 'expect a line or block after "try"'
      if atStatementHead and not isHeadStatement
        error 'meet unexpected new line when parsing inline try statement'
      options = {}; #catchClauses = ['list!']
      #while catch_=catchClause(line1, isHeadStatement, options) then catchClauses.push catch_
      #else_ = elseClause(line1, isHeadStatement, options);
      catch_ = catchClause(line1, isHeadStatement, options)
      if not catch_ then error 'expect a catch clause for try-catch statement'
      final = finallyClause(line1, isHeadStatement, options)
      #['try', begin(test), catch_, else_, final]
      ['try', begin(test), catch_[0], catch_[1], final]

    'class': (isHeadStatement) ->
      line1 = lineno; space();
      # class name should be provided explicitly
      name = expect('identifier', 'expect class name'); space()
      if parser.conjunction('extends') then space(); superClass = parser.identifier(); space()
      else supers = undefined
      if followNewline() and newlineFromLine(line1, line1+1) then body = undefined
      else body = parser.lineBlock()
      ['#call!', 'class', [name, superClass, body]]

  @statement = ->
    start = cursor; line1 = lineno
    if not (keyword = symbol() or taijiIdentifier()) then return
    if stmtFn = parser.keywordToStatementMap[keyword.text]
      isHeadStatement = atStatementHead; atStatementHead = false
      if stmt = stmtFn(isHeadStatement)
        return extend stmt, {start:start, stop:cursor, line1:line1, line:lineno}
    return rollback start, line1

  @defaultAssignLeftSide = ->
    start = cursor; line1 = lineno
    if not (x=parser.spaceClauseExpression()) then return
    if x.type==PAREN or x.type==BRACKET or x.type==DATA_BRACKET or x.type==CURVE
      rollback start, line1; return
    x = getOperatorExpression x
    if not x then  rollback start, line1; return
    if x.type==IDENTIFIER or ((e=entity(x)) and (e[0]=='attribute!' or e[0]=='index!')) then x
    else if x.text=='::' then x
    else if parser.isAssign(x[0]) then rollback x[1].stop, x[1].line; return x[1]
    else  rollback start, line1; return

  @isAssign = (val) -> (op=binaryOperatorDict[val]) and op.assign

  @defaultAssignSymbol = -> (x=parser.symbol()) and parser.isAssign(x.text) and x

  @defaultAssignRightSide = ->
    space2 = bigSpace()
    if space2.undent then error 'unexpected undent after assign symbol'+symbol.text
    else if space2.newline then error 'unexpected new line after assign symbol'+symbol.text
    parser.block() or parser.clause()

  @makeAssignClause = (assignLeftSide, assignSymbol, assignRightSide) -> ->
    start = cursor; line1 = lineno
    if not (left=assignLeftSide()) then return
    spac = space()
    if not (token=assignSymbol()) then return rollback start, line1
    right = assignRightSide(spac)
    if left.type==CURVE
      eLeft = entity(left)
      if typeof eLeft=='string'
        if eLeft[0]=='"' then error 'unexpected left side of assign: '+eLeft
        left = [left]
      else if eLeft and eLeft.push
        if eLeft[0]=='begin!' then error 'syntax error: left side of assign should be a list of variable names separated by space'
      else error 'unexpected left side of assign'
      return ['hashAssign!', left, right]
    extend [token, left, right], {start:start, cursor:cursor, line1:line1, line:lineno}

  @defaultAssignClause = @makeAssignClause @defaultAssignLeftSide, @defaultAssignSymbol, @defaultAssignRightSide

  @customAssignClauses = []

  @assignClause = ->
    for matcher in parser.customAssignClauses then if x=matcher() then return x
    parser.defaultAssignClause()

  @macroCallClause = ->
    start = cursor; line1 = lineno
    if (head=parser.compactClauseExpression())
       if (space1=space()) and not space1.text then return rollback(start, line1)
       if text[cursor]=='#' and cursor++ and ((spac=space()) and spac.text or text[cursor]=='\n' or text[cursor]=='\r')
          if blk = parser.block()
            return extend ['#call!', head, blk], {cursor:start, line1:lineno, stop:cursor, line:lineno}
          else if args = parser.clauses()
            return extend ['#call!', head, args], {cursor:start, line1:lineno, stop:cursor, line:lineno}
    rollback(start, line1)

  @parameterList = ->
    start = token
    if token.type==SPACE then nextToken()
    if token.type!=PAREN then token = start; return
    if item=getOperatorExpression(token.value)
      if params=parser.toParameters(item) then return params
      else
        if followSequence('inlineSpaceComment', 'defaultSymbolOfDefinition')
          error 'illegal parameters list for function definition'
        else token = start; return

  @definition = ->
    start = token
    if not (parameters=parser.parameterList()) then parameters = []
    if token.type==SPACE then nextToken()
    if (value=token.value) and ((tail=value[(value.length-2)...])=='->' or tail=='=>')
      define = token; nextToken()
      body = begin(parser.lineBlock()) or 'undefined'
      extend [define, parameters, body], {start:start, stop:token}
    else token = start; return

  @clauseItem = ->
    if token.type==SPACE then nextToken()
    if (item=parser.compactClauseExpression())
      if item.type==PAREN  and (d=parser.definition()) then return d
      return item

  @sequenceClause = ->
    start = token; clause = []
    while item = parser.clauseItem() then clause.push item
    if not clause.length then return
    extend clause, {start:start, stop:token}

  @customClauseList = ['assignClause', 'colonClause', 'macroCallClause', 'indentClause']

  leadTokenClause = (value) ->
    start = token
    if (type=matchToken().type)!=SPACE and type!=INDENT then token = start; return
    matchToken()
    if not (fn=leadWordClauseMap[start.value]) then token = start; return
    clause = fn(start, parser.clause())
    clause.start = start; clause.stop = token
    clause

  leadWordClauseMap =
  # eval while parsing, call by %% clause
  # e.g.
  # %% %text()
  # %% %cursor()
  # %% %number()1234
    '%%':  (tkn, clause) ->
      code = compileExp(['return', clause], environment)
      new Function('__$taiji_$_$parser__', code)(parser)

  # the head of clause will be convert to attribute of __$taiji_$_$parser__
  # see exports['%/'] and convertParserAttribute in core.coffee
  # {%/ matcheA(x, y) } will be converted to {%% %matchA(x, y)}
    '%/': (tkn, clause) ->
      # notice the difference between %% and %/
      # here ['%/', clause] is compiled
      code=compileExp(['return', [tkn, clause]], environment)
      new Function('__$taiji_$_$parser__', code)(parser)

  # identifier in clause will be convert to attribute of __$taiji_$_$parser__
  # see exports['%!'] and convertParserAttribute in core.coffee
  # {%! matcheA(x, y) } will be converted to {%% %matchA(%x, %y)}
    '%!': (tkn, clause) ->
      code=compileExp(['return', [tkn, clause]], environment)
      new Function('__$taiji_$_$parser__', code)(parser)

    '~':  (tkn, clause) -> tkn.symbol = 'quote!'; [tkn, clause]
    '`':  (tkn, clause) -> tkn.symbol = 'quasiquote!'; [tkn, clause]
    '^':  (tkn, clause) -> tkn.symbol = 'unquote!'; [tkn, clause]
    '^&': (tkn, clause) -> tkn.symbol = 'unquote-splice'; [tkn, clause]

  # preprocess opertator
  # see # see metaConvertFnMap['#'] and preprocessMetaConvertFnMap for more information
    '#':  (tkn, clause) -> [tkn, clause]

  # evaluate in compile time
  # see metaConvertFnMap['##']
    '##':  (tkn, clause) -> [tkn, clause]

  # evaluate in both compile time and run time
  # see metaConvertFnMap['#/']
    '#/': (tkn, clause) -> [tkn, clause]

  # escape from compile time to runtime
  # see metaConvertFnMap['#-']
    '#-': (tkn, clause) -> [tkn, clause]

  # #& metaConvert exp and get the current expression(not metaConverted raw program)
  # see metaConvertFnMap['#&']
    '#&': (tkn, clause) -> [tkn, clause]

  symbol2clause = {}

  for key of leadWordClauseMap then symbol2clause[key] = leadTokenClause

  @clause = ->
    start = token
    if (type=token.type)==SPACE then nextToken(); type = token.type
    if type==KEYWORD then return keyword2statement[token.value]()
    else if type==IDENTIFIER and nextToken()
      if token.value=='#' and nextToken() and token.value==':' and nextToken() and (blk=parser.lineBlock())
        # label statement
        return ['label!', start, blk]
      else token = start
    else if type==SYMBOL and (fn=symbol2clause[token.value])
      if result = fn() then return result
      else token = start

    if not (head=parser.compactClauseExpression())
      if (op=parser.prefixOperator())
        if token.type==SPACE and nextToken() and (exp=parser.spaceClauseExpression())
          return [op, exp]
        else return op
      else if token.value==',' then nextToken(); return {value:'undefined', start:start, stop:token}
      else return

    if op=parser.binaryOperator(SPACE_CLAUSE_EXPRESSION, 300)
      originalToken = token; token = head; head.next = op; op.isBinaryOperator = true; op.next = originalToken
      if (exp=parser.spaceClauseExpression())
        if (value=token.value)==',' then nextToken(); if token.type==SPACE then nextToken()
        else if value!=';' and (type=token.type)!=NEWLINE and type!=UNDENT and type!=EOI
          error 'after space expression clause, expect stop symbol of clause like colon, semicolon, new line, undent or end of input etc.'
        return exp
      else token = originalToken

    tkn = token
    if (exp=parser.spaceClauseExpression())
      if exp.priority<=600 and isCallable(head)
        if (value=token.value)==',' then nextToken(); if token.type==SPACE then nextToken()
        else if value!=';' and (type=token.type)!=NEWLINE and type!=UNDENT and type!=EOI
          error 'after caller leading clause, expect stop symbol of clause like colon, semicolon, new line, undent or end of input etc.'
        return [head, exp]
      else token = tkn

    else if token.value=='#' and nextToken()
      if token.type==SPACE then clauses = parser.clauses()
      else if token.type==INDENT then clauses = parser.block()
      return [head].concat clauses

    else if token.value==':'
      nextToken()
      if token.type==SPACE then nextToken()
      clause = parser.clauses()
      clause.unshift head
      clause.start = head
      return extend clause,  {start:start, stop:token}

    if clause = parser.sequenceClause()
      clause.unshift head; clause.start = start
      if token.value==INDENT
        blk = parser.block()
        clause.push.apply clause, blk
        clause.stop = blk.stop
    else clause = head

    if (value=token.value)==','
      nextToken()
      #if token.type==SPACE then nextToken()

    else if value==':'
      # head clause with colon leading clauses or colon leading indented block
      # print: 1 + 2, 3
      # withMethod # openWindow: 100x200 400x500
      # getFn Math name:
      #   abs 1
      #   sin x
      nextToken()
      if token.type=='INDENT' then clauses = parser.block()
      else
        clauses = parser.clauses()
      clauses.unshift clause
      clauses.start = start; clauses.stop = token
      clauses

    else if token.type==INDENT
      # head clause with indented block
      # please pay attention to the difference between clause+':'+INDENT+block and clause+INDENT+block
      clauses = parser.block()
      clause.push.apply clause, clauses

    extend clause, {start:start, stop:token}

  isCallable = (exp) -> return (type=exp.type)!=NUMBER and type!=NON_INTERPOLATE_STRING and type!=INTERPOLATE_STRING and type!=BRACKET and type!=HASH

  @clauses = ->
    result = []
    while clause=parser.clause() then result.push clause
    return result

  @lineCommentBlock = ->
    start = cursor
    if comment=parser.lineComment()
      if comment.indent
        if comment.text[...3]=='///' then result = parser.blockWithoutIndentHead(); result.unshift ['directLineComment!', comment.text]; result
        else parser.blockWithoutIndentHead()
      else
        if text[start...start+3]=='///'
          [extend(['directLineComment!', comment.text], {start:start, stop:cursor, line: lineno})]
        else [extend(['lineComment!', comment.text], {start:start, stop:cursor, line: lineno})]

  @codeCommentBlockComment = ->
    if cursor!=lineInfo[lineno].start+lineInfo[lineno].indentCol then return
    if text[cursor]!='/' then return
    if (c=text[cursor+1])=='.' or c=='/' or c=='*' then return
    start = cursor; line1 = lineno; cursor++
    code = parser.lineBlock()
    extend [['codeBlockComment!', code]], {start:start, stop:cursor, line1: line1, line: lineno}

  @sentence = ->
    start = token
    if (type=token.type)==EOI or type==UNDENT or type==RIGHT_DELIMITER or isConjunction(token)
      return
    result = parser.clauses()
    if token.value==';'
      nextToken()
      if token.type==SPACE then nextToken()
    extend result, {start:start, stop:token}

  @line = ->
    if (type=token.type)==UNDENT or type==RIGHT_DELIMITER or isConjunction(token) and type==EOI
      return
    # if x=(parser.lineCommentBlock() or parser.codeCommentBlockComment()) then return x
    result = []
    while x = parser.sentence() then result.push.apply result, x
    if token.type==NEWLINE then nextToken()
    result

  @block = (dent) -> if token.type==INDENT then nextToken(); return parser.blockWithoutIndentHead(dent)

  # a block with out indent( the indent has been ate before).
  # stop until meet a undent (less indent col than the intent col of the start line)
  @blockWithoutIndentHead = (dent) ->
    result = []
    while (x=parser.line())
      result.push.apply(result, x)
      if token.stopIndent<dent then break
    return result


  @lineBlock = (dent) ->
    if token.type==INDENT then nextToken(); parser.blockWithoutIndentHead(dent)
    else
      result = parser.line()
      if token.stopIndent>dent
        result.push.apply result, parser.blockWithoutIndentHead()
      result

  @moduleBody = ->
    matchToken()
    if token.type==NEWLINE then matchToken()
    if token.type==SPACE then matchToken()
    body = []
    while 1
      if not x=parser.line() then break
      spac = bigSpace()
      body.push.apply body, x
      clearMemo()
      if lineInfo[lineno].indentCol<indentCol then rollbackToken spac; break
    if text[cursor] then error 'expect end of input, but meet "'+text.slice(cursor)+'"'
    begin body

  @moduleHeader = ->
    if not (literal('taiji') and spaces()  and  literal('language') and spaces() and
        (x=decimal()) and char('.') and (y=decimal()))
      error 'taiji language module should begin with "taiji language x.x"'
    if (x=x.value)!=0 or (y=y.value)!=1 then error 'taiji 0.1 can not process taiji language'+x+'.'+y
    lineno++
    while lineno<=maxLine and (lineInfo[lineno].indentCol>0 or lineInfo[lineno].empty) then lineno++
    if lineno>maxLine then cursor = text.length
    else cursor = lineInfo[lineno].start # lineInfo[lineno].indentCol = 0
    {type: MODULE_HEADER, version: {main:x, minor:y}, value: text[...cursor]}

  @module = ->
    # #!use/bin/node taiji
    if text[cursor...cursor+2]=='#!' then  scriptDirective = ['scriptDirective!', skipLineTail()]
    wrapResult ['module!', scriptDirective, parser.moduleHeader(), parser.moduleBody()], {type: MODULE}

  @init = (data, cur, env) ->
    @text = text = data; cursor = cur; char = text[cursor]; lineno = 1; lineStart = 0
    token = {} # an empty token, {}.next is undefined, so nextToken will call matchToken
    # should not call matchToken() here, because the head of module need be processed differently
    # matchToken() should be called in moduleBody() instead
    memoMap = {}
    atStatementHead = true
    interolateStringNumber = 0
    @environment = environment = env
    @meetEllipsis = false
    endCursorOfDynamicBlockStack = []

  @parse = (data, root, cur, env) ->
    parser.init(data, cur, env)
    # should not call matchToken() here, because the head of module need be processed differently
    # matchToken() should be called in moduleBody() instead
    root()

  @lexError = lexError = (message) ->
    throw cursor+'('+lexRow+':'+lexCol+'): '+message+': \n'+text[cursor-40...cursor]+'|   |'+text[cursor...cursor+40]

  @error = error = (message, tkn) ->
    tkn = tkn or token; cur = tkn.cursor
    throw cur+'('+tkn.line+':'+tkn.column+'): '+message+': \n'+text[cur-40...cur]+(text[cur...cur+40].red)

  return @

{compileExp} = require '../compiler'