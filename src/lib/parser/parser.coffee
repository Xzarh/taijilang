{charset, isArray, wrapInfo1, wrapInfo2, str, entity} = require '../utils'

{extend, firstIdentifierChars, firstIdentifierCharSet, letterDigitSet, identifierChars,
digitCharSet, letterCharSet, identifierCharSet,
taijiIdentifierCharSet, constant} = base = require './base'
digitChars = base.digits
letterChars = base.letters

{NUMBER,  STRING,  IDENTIFIER, SYMBOL, REGEXP,  HEAD_SPACES, CONCAT_LINE, PUNCT, FUNCTION, C_BLOCK_COMMENT
PAREN, BRACKET, DATA_BRACKET, CURVE, INDENT_EXPRESSION
NEWLINE,  SPACES,  INLINE_COMMENT, SPACES_INLINE_COMMENT,
LINE_COMMENT, BLOCK_COMMENT, CODE_BLOCK_COMMENT,CONCAT_LINE
NON_INTERPOLATE_STRING, INTERPOLATE_STRING, EOI
INDENT, UNDENT, HALF_DENT, MODULE_HEADER, MODULE, SPACE_COMMENT, TAIL_COMMENT
SPACE
} = constant

{prefixOperatorDict, suffixOperatorDict, binaryOperatorDict,
makeOperatorExpression, getOperatorExpression} = require './operator'

exports.escapeNewLine = escapeNewLine = (s) -> (for c in s then (if c=='\n' then '\\n' else '\\r')).join('')

exports.keywordMap =
  'if': 1, 'try':1, 'switch':1, 'while':1, 'let':1, 'letrec!':1, 'letloop!':1, 'do':1, 'repeat':1
  'return':1, 'break':1, 'continue':1, 'throw':1,'function':1,'for':1
  'loop':1, 'class':1, 'var':1, 'for':1

exports.isKeyword = isKeyword = (item) ->
  item and not item.escaped and hasOwnProperty.call(exports.keywordMap, item.value)

exports.conjMap =
  'then':1, 'else':1, 'catch':1, 'finally':1, 'case':1, 'default':1, 'extends': 1
  'until':1, 'where':1, 'when':1

exports.isConj = isConj = (item) ->
  item and not item.escaped and hasOwnProperty.call(exports.conjMap, item.value)

hasOwnProperty = Object::hasOwnProperty

begin = (exp) ->
  if not exp or not exp.push then return exp
  if exp.length==0 then ''
  else if exp.length==1 then exp[0]
  else exp.unshift('begin!'); exp


exports.Parser = ->
  parser = @; @predefined = predefined = {}
  unchangeable = ['cursor', 'setCursor', 'row', 'setLineno', 'atLineHead', 'atStatementHead', 'setAtStatementHead']

  # global variable used by lexer
  text = '' # text to be parsed
  textLength = 0 # total length of text to be parsed
  cursor = 0 # position pointer while do lexical parsing, use cur for local position pointer
  char = '' # current character
  lineno = 0 # current line number, use line for local line number
  column = 0 # current column, use col for local column
  indent = 0 # global indent column of current line, use dent for local indent column
  token = null # global token generated by lexical parsing and used by the parser

  eof = {cursor: textLength, column: -1, indent: -1, isUndent: true} # lineno wait to be filled
  eof.next = eof  # eof.next is always itself

  # to maintain the balance of delimterStack with memo function, it's the duty of programer who are extending the parser
  @memo = memo = (fn) ->
    tag = memoIndex++
    ->
      if (m=memoMap[tag]) and hasOwnProperty.call(m, cursor)
        if x=m[cursor] then cursor = x.stop; row = x.line
        return x
      else
        if not memoMap[tag] then memoMap[tag] = m = {}
        m[cursor] = fn()
  #console.log tag+' '+cursor+' '+row
  #m[cursor]

  parser.saveMemo = saveMemo = (tag, start, result) ->
    if not memoMap[tag] then memoMap[tag] = {}
    result.stop = cursor; result.line = row
    memoMap[tag][start] = result

  # garbage collector: do this in some proper time, e.g. when starting to parse a sentence
  @clearMemo = -> memoMap = {}

  nextToken = ->
    if token.next then token = token.next
    else matchToken()

  @matchToken = matchToken = ->
    if not char
      eof.lineno = lineno+1
      token = eof # while reaching the end of input, always return eof
    else if fn = tokenFnMap[char] then fn(char)
    else getSymbolToken()
    token

  @testMatchToken = ->
    char = text[cursor]
    matchToken()

  newToken = (tkn) -> token.next = tkn; token = tkn

  getSymbolToken = ->
    cur = cursor; col = column
    while c=text[cursor]
      if symbolStopChars[c] then break
      if c=='/' and ((c2=text[cursor+1])=='/' or c2=='*') then break
        # else if c2=='.' # should not reach here, because this /. is always in the middle of the symbol, not in the front
      if c=='\\' and ((c2=text[cursor+1])=='\n'  or c2=='\r') then break
      cursor++
    column += cursor-cur
    newToken {value: text.slice(cur, cursor), cursor:cur, stopCursor:cursor, line: lineno, column:col, indent:indent}

  symbolStopChars = extend charset(' \t\v\n\r()[]{},;:\'\".@\\'), identifierCharSet

  getAtToken = getDotToken = ->
    cur = cursor; col = column
    while (c=text[cursor]) and c==char then cursor++
    column += cursor-cur
    newToken {type: SYMBOL, value: text.slice(cur, cursor), cursor:cur, stop:cursor,
    line: lineno, column:col, indent:indent}

  getColonToken = ->
    cur = cursor; col = column
    while (c=text[cursor]) and c==char then cursor++
    column += cursor-cur
    if cursor==cur+1 then type==PUNCT
    else type = SYMBOL
    newToken {type: type, value: text.slice(cur, cursor), cursor:cur, stopCursor:cursor,
    line: lineno, column:col, indent: indent}

  # use function to shift the definition of tokenFnMap here
  makeTokenFnMap = ->
    ' ': getSpaceToken, '\t': getSpaceToken, '\n': getNewlineToken, '\r': getNewlineToken,
    '0': getNumberToken, '1': getNumberToken, '2': getNumberToken, '3': getNumberToken, '4': getNumberToken,
    '5': getNumberToken, '6': getNumberToken, '7': getNumberToken, '8': getNumberToken, '9': getNumberToken,
    '"': getInterpolatedStringToken, "'": getNonInterpolatedStringToken
    '(': getParenToken, ')':getRightDelimiterToken,
    '[':getBracketToken, ']':getRightDelimiterToken,
    '{':getCurveToken, '}':getRightDelimiterToken
    ',':getPunctToken, ';':getPunctToken
    '.':getDotToken, ':':getColonToken, '@':getAtToken
    '\\': getMaybeConcatLineToken, '/': getCommentRegexpToken

  # space below means not spacebar key or space character, means anything piece like white space, e.g. ' ', '\t', etc.

  getSpaceToken = ->
    cur = cursor; line = lineno; col = column; dent = indent
    cursor++; column++; skipInlineSpace(dent)
    char = text[cursor]
    if char=='\\' and newline()
      while (c=text[cursor]) and c==' ' then cursor++; column++
      if c=='\n' or c=='\r' then error 'should not follow empty line as concatenated line'
      else if not c then unexpectedEOF('after concatenated line symbol "\"')
      if concatenating
        if columen!=dent then error 'expect the same indent for the second and more concatenated lines'
      else if column<=dent then expectMoreIndent(dent, 'in the following concatenated line')
      concatIndent = column
      skipInlineSpace(concatIndent)
      if (c=text[cursor])=='\n' or c=='\r'
        error 'concatenated line should not have only spaces and comments'
      return newToken {type: SPACE, value: text[cur...cursor], cursor:cur, stopCursor: cursor,
      line:line, stopLine:lineno, column:col, stopColumn: column, indent: dent}
    if newline()
      skipSpaceLines(dent); indent = column
      tkn = {type: SPACE, value: text[cur...cursor], cursor:cur, stopCursor: cursor,
      line:line, stopLine:lineno, column:col, stopColumn: column, indent: dent}
      if indent>dent then tkn.isIndent = true
      else if indent<dent then tkn.isUndent = false
      else tkn.isNewline = true
      return newToken tkn
    else return  newToken {type: SPACE, value: text[cur...cursor], cursor:cur, stopCursor: cursor,
    line:line, stopLine:lineno, column:col, stopColumn: column, indent: dent}


  # the lexical matcher skipSomething, leftSomething do not process global variable "char"
  #  so instead of using char, please use local c, ch etc as character in text to be parsed

  # should be called after a new line
  skipSpaceLines = (dent) ->
    while 1
      while (c=text[cursor]) and c==' ' then cursor++; column++
      if c=='\t' then unexpectedTabCharAtLineHead()
      else if c=='\n'
        cursor++; column = 0
        if c=='\r' then cursor++
        continue
      else if c=='\r'
        cursor++; column = 0
        if c=='\n' then cursor++
        continue
      else if not c then break
      else if column!=dent then break
      else if c=='/'
        if (c2=text[cursor+1])=='/' then cursor += 2; skipLineTail(); continue
        else if c2=='*'
          cursor += 2; leftCBlockComment()
          skipInlineSpace()
          if newline() then continue
          else break
        else break
      else break

  # skipInlineSpace is called by getSpaceToken
  # skiptInlineSpace should not generate independent token and called independently
  skipInlineSpace = (dent) ->
    while 1
      while 1
        c = text[cursor]
        if c!=' ' and c!='\t' then break
        cursor++
      c = text[cursor]
      if c=='/'
        if (c2=text[cursor+1])=='*' then cursor +=2; column += 2; leftCBlockComment(dent); continue
        if c2=='/'
          while (c3=text[cursor])!='\n' and c3!='\r' then cursor++; continue
          break
      break

  # \n\r, don't eat spaces.
  @newline = newline = ->
    c = text[cursor]
    if c=='\r'
      cursor++
      if text[cursor]=='\n' then cursor++; c2 = '\n'
      lineno++; column = 0
    else if c=='\n'
      cursor++
      if text[cursor]=='\r' then cursor++; c2 = '\r'
      lineno++; column = 0
    else return
    c+(c2 or '')

  # skip line tail and the space in the head of next line
  skipLineTail = ->
    while (c=text[cursor]) and c!='\n' and c!='\r' then cursor++
    if not c then column = indent = -1
    else
      column = 0
      while c==' ' then cursor++; column++; c = text[cursor]
      if c=='\t' then error 'unexpected tab "\t" character in the head of line'

  leftIndentBlockComment = (dent) ->
    skipLineTail()
    while 1
      c=text[cursor]
      while c and c==' '
        cursor++; column++
      if c=='\n' or c=='\r' then continue
      if column<=dent then break
      skipLineTail()

  # default /* some content */, can cross lines
  leftCBlockComment = (dent) ->
    # dent: the indent column of the line of '/*'
    while 1
      c = text[cursor]
      if c=='*' and text[cursor+1]=='/' then cursor += 2; column += 2; break
      else if c=='\n'
        cursor++; lineno++; column = 0
        if c=='\r' then cursor++
        while (c=text[cursor]) and c==' ' then cursor++; column++
        if c=='\t' then unexpectedTabCharAtLineHead()
        if c=='\n' or c=='\r' then continue
        else if not c then unexpectedEOF('while parsing c style block comment /* */')
        if column<dent then expectMoreIndent(dent, 'while parsing c style block comment /* */')
      else if c=='\r'
        cursor++; lineno++; column = 0
        if c=='\n' then cursor++
        while (c=text[cursor]) and c==' ' then cursor++; column++
        if c=='\t' then unexpectedTabCharAtLineHead()
        if c=='\n' or c=='\r' then continue
        else if not c then unexpectedEOF('while parsing c style block comment /* */')
        if column<dent then expectMoreIndent(dent)
      else if not c
        unexpectedEOF('while parsing c style block comment /* */')
      else cursor++; column++

  @concatLine = ->
    if text[cursor]!='\\' then return
    if (c=text[cursor+1])!='\n' and c!='\r' then return
    cursor++; bigSpace()

  @inlineSpaceComment = space = memo ->
    cur = cursor; line1 = row
    while c=text[cursor]
      if c==' ' or c=='\t' then cursor++
      else if c=='\n' or c=='\r' or parser.tailComment() then lineTail = true; break
      else if parser.cBlockComment() then continue
      else if parser.concatLine() then lineTail = true; concat=true; continue
      else break
    #    console.log cursor+' '+row
    {type: SPACE_COMMENT, value:text[cur...cursor],
    start: cur, stop:cursor, line1:line1, line:row
    multiLine: line1!=row, lineTail: lineTail, concat:concat, inline:true}

  @multilineSpaceComment = memo ->
    cur = cursor; line1 = row; indentCol = lineInfo[row].indentCol
    space();
    multiStart = cursor
    while c=text[cursor]
      if newLineAndEmptyLines() then continue
      else if indentCol!=lineInfo[row].indentCol then break  # stop at indent or undent
      else if parser.indentBlockComment() then continue
      else if parser.cBlockComment() then space(); continue
      else break
    if cursor==multiStart then cursor = cur; return # fail if only meet inline space comment
    atStatementHead = true
    {type: SPACE_COMMENT, value:text[cur...cursor], start: cur, stop:cursor, line1:line1, line:row
    multipleLine: true
    indent:indentCol<lineInfo[row].indentCol
    undent:indentCol>lineInfo[row].indentCol
    newline:indentCol==lineInfo[row].indentCol}

  @spaceComment = bigSpace = memo -> parser.multilineSpaceComment() or space()

  @regexp = memo ->
    if text[cursor..cursor+1]!='/!' then return
    cur = cursor; cursor += 2
    while c = text[cursor]
      if c=='\\' and text[cursor+1]=='/' then cursor += 2
      else if c=='\\' and text[cursor+1]=='\\' then cursor += 2
      else if c=='\n' or c=='\r'
        error 'meet unexpected new line while parsing regular expression'
      else if c=='/'
        i = 0; cursor++
        # console.log text.slice(cursor)
        while c=text[cursor]
          if c=='i' or c=='g'or c=='m' then cursor++; ++i
          else break
        if i>3 then 'too many modifiers after regexp'
        break
      else cursor++
    wrapResult ['regexp!','/'+text.slice(cur+2, cursor)], {type: REGEXP, start:cur, stop: cursor, line: row}

  # // leftLineTailComment, the start symbol // has been matched
  leftLineTailComment = ->
    char = text[++cursor]
    if char=='\n' or char=='\r' then cursor++; char = text[cursor]
    if char=='\n' or char=='\r' then cursor++; char = text[cursor]
    lexRow++; lexCol = 0

  leftSpace = ->
    while  char==' ' or char=='\t'
      cursor++; lexCol++; char = text[cursor]

  spaceCommentLines = ->
    if char==' ' or char=='\t' then cursor++; lexCol++; leftSpaceToken()
    if char=='/'
      char = text[++cursor]
      if char=='/' then leftLineTailComment()

  getCommentRegexpToken = ->
    # // start a line comment
    cur = cursor; char = text[++cursor]
    if char=='/' # // leading line comment
      cursor++
      tail = skipLineTail()
      spaceLines = spaceCommentLines(indent)
      if lexIndentCol>startIndentCol then t = INDENT
      else if lexIndentCol>startIndentCol then t = NEWLINE
      else t = UNDENT
      return {type: t, value: text[cur...cursor], content:[tail, spaceLines]}
    else if char=='*'
      leftCBlockComment()
      while 1
        if char==' ' or char=='\t' then cursor++; lexCol++; leftSpaceToken()
        if char=='/'
          if text[cursor+1]=='*' then leftCBlockComment()
          else if text[cursor+1]=='/'
            leftLineTailComment()
            break
    else if char=='.' # block comment /. multiple indented lines
      startLineIndent = lexIndentCol
      x = skipLineTail()
      lineList = skipLineUntilSameOrLessIndent(startLineIndent)
      return {type:BLOCK_COMMENT, value:[x].concat(lineList)}
    else if char=='!'
      cursor++; lexCol++; leftRexexp()
      return {type:REGEXP, value: '/'+text[cur+1...cursor]}
    else if firstIdentifierCharSet[char]
      cursor++; lexCol++;
      return {type: CODE_BLOCK_COMMENT_START, value:'/'}

  getMaybeConcatLine = ->
    cursor++; lexRow++
    if char=='\n'
      cursor++; lexRow = 0
      if char=='\r' then cursor++
      leftSpaceToken()
      if lexRow<lexIndent and char and char!='\n' and char!='\r' then lexError 'should not intent less in concatenated line'
      lexIndent = lexRow
      char = text[cursor]
      return {type:SPACE, value: text[cur...cursor], concatLine: true}
    else if char =='\r'
      cursor++; lexRow = 0
      if char=='\n' then cursor++
      leftSpaceToken()
      if lexRow<lexIndentt and char and char!='\n' and char!='\r' then lexError 'should not intent less in concatenated line'
      lexIndent = lexRow
      return {type:SPACE, value: text[cur...cursor], concatLine: true}
    else return leftSymbolToken('\\')

  getNewlineToken = ->

  getNumberToken = ->
    cur = cursor; col = column; base = 10; c = text[cursor]
    if c=='0' and c2 = text[cursor+1]
      if c2=='b' or c2=='B' then base = 2; baseStart = cursor += 2; c = text[cursor]
      else if c2=='x' or c2=='X' then base = 16; baseStart = cursor += 2; c = text[cursor]
      else c = text[++cursor]; meetDigit = true
    if base==2
      while c
        if c=='0' or c=='1' then c = text[++cursor]
        else break
    else if base==16
      while c
        if  not('0'<=c<='9' or 'a'<=c<='f' or 'A'<=c<='F') then break
        else c = text[++cursor]
    if base==2
      if c=='.' or c=='e' or c=='E' then error 'binary number followed by ".eE"'
      else if '2'<=c<='9' then error 'binary number followed by 2-9'
    if base==16
      if c=='.' then error 'hexadecimal number followed by "."'
      else if letterCharSet[c] then error 'hexadecimal number followed by g-z or G-Z'
    if base!=10
      if cursor==baseStart
        # e.g 0x+3, 0x(1+2)
        cursor--
        return newToken { type: NUMBER, value: text[cur...cursor], expr: ['number!', 0],
        cursor:cur, line:lineno, column:col, indent:indent}
      else return newToken { type: NUMBER, value: (value=text[baseStart...cursor]), expr: ['number!', parseInt(value, base)],
      cursor:cur, line:lineno, column: col, indent:indent}
    # base==10
    while c
      if '0'<=c<='9' then meetDigit = true; c = text[++cursor]
      else break
    # if not meetDigit then return symbol() # comment because in no matchToken solution
    if not meetDigit then return
    if c=='.'
      meetDigit = false
      c = text[++cursor]
      while c
        if c<'0' or '9'<c then break
        else meetDigit = true; c = text[++cursor]
    dotCursor = cursor-1
    if not meetDigit and c!='e' and c!='E'
      cursor = dotCursor;
      return newToken { type: NUMBER, value: (value=text[baseStart...cursor]), expr: ['number!',parseInt(value, base)],
      cursor:cur, line:lineno, column: col, indent:indent}
    if c=='e' or c=='E'
      c = text[++cursor]
      if c=='+' or c=='-'
        c = text[++cursor]
        if not c or c<'0' or '9'<c
          cursor = dotCursor;
          return newToken { type: NUMBER, value: (value=text[cur...dotCursor]), expr: ['number!', parseInt(value, base)],
          cursor:cur, line:lineno, column: col, indent:indent}
        else
          while c
            c = text[++cursor]
            if  c<'0' or '9'<c then break
      else if not c or c<'0' or '9'<c
        cursor = dotCursor;
        return newToken { type: NUMBER, value: (value=text[cur...dotCursor]), expr: ['number!', parseInt(value, base)],
        cursor:cur, line:lineno, column: col, indent:indent}
      else while c
          if  c<'0' or '9'<c then break
          c = text[++cursor]
    newToken { type: NUMBER, value: (value=text[cur...cursor]), expr: ['number!', parseFloat(value, base)],
    cursor:cur, line:lineno, column: col, indent:indent}

  getInterpolatedStringToken = ->
  getNonInterpolatedStringToken = ->
  getBracketToken = ->
  getCurveToken = ->
  getRightDelimiterToken = ->
  getMaybeConcatLineToken = ->
  getCommentRegexpToken = ->

  getParenToken = (c) -> {value:c, type:c, row:lexLineno, cursor:cursor, length:1, col: lexCol}
  getPunctToken = getParenToken

  getInterpolatedStringToken = (c) ->
    if text[cursor+1]=='"'
      if [cursor+2]=='"' then return parseRawInterpolateString()
      else return {value:'""', type:'"', row:lexLineno, cursor:cursor, length:1, col: lexCol}
    else return parseInterpolatedString()

  getInterpolatedStringToken = (c) ->
    if text[cursor+1]=="'"
      if [cursor+2]=="'" then return parseRawNonInterpolateString()
      else return {value:'""', type:"'", row:lexLineno, cursor:cursor, length:1, col: lexCol}
    else return parseNonInterpolatedString()

  clearMemo = ->
    memoMap = {}
    cursor2Token = {}

  # real tokenFnMap should be produced after all dependency have been defined.
  tokenFnMap = makeTokenFnMap()

  getIdentifierToken = ->
    if not firstIdentifierCharSet[text[cursor]] then return
    cur = cursor; cursor++
    while c=text[cursor] then (if identifierCharSet[c] then cursor++ else break)
    col = column += cursor-cur
    newToken {type: IDENTIFIER, value: (value=text.slice(cur, cursor)), expr: ['identifier!', value],
    cursor:cur, stopCursor: cursor, line: lineno, column: col, indent:indent}

  for c of firstIdentifierCharSet then tokenFnMap[c] = getIdentifierToken

  # global variable used by the parser
  cursor = 0; row = 1;  lineInfo = []; maxLine = -1
  memoMap = {}; atStatementHead = true
  cursor2token = {} # cursor to token map
  environment = null
  # used by ? clause then block to identifier end of dynamic block
  endCursorOfDynamicBlockStack = []

  memoIndex = 0  # don't need be set in parser.init, memoMap need to be set instead.

  @followMatch = followMatch = (fn) ->
    cur = cursor; line = row
    x = fn()
    cursor = cur; row = line
    x

  @follow = follow = (matcherName) ->
    cur = cursor; line = row
    x = parser[matcherName]()
    cursor = cur; row = line
    x

  @expect = expect = (matcherName, message) ->
    if not (x = parser[matcherName]()) then error message
    else x

  @followSequence = followSequence = (matcherList...) ->
    cur = cursor; line1 = row
    for matcherName in  matcherList
      if not (x=parser[matcherName]()) then break
    cursor = cur; row = line1
    x

  @followOneOf = (matcherList...) ->
    cur = cursor; line1 = row
    for matcherName in  matcherList
      cursor = cur; row = line1 # defensive coding style
      if x =  parser[matcherName]() then break
    cursor = cur; row = line1
    x

  @setText = (x) -> parser.text = text = x; x
  @cursor = -> cursor
  @setCursor = (x) -> cursor = x
  @atStatementHead = -> atStatementHead
  @setAtStatementHead = (x) -> atStatementHead = x
  @endOfInput = -> not text[cursor]

  @literal = literal = (string) ->
    length = string.length
    if text[cursor...cursor+length]==string then cursor += length; true

  wrapResult = (result, info) -> result.info = info; result

  @decimal = decimal = memo ->
    cur = cursor
    while c = text[cursor] then (if  '0'<=c<='9' then cursor++ else break)
    if cursor==cur then return
    {value: text[cur...cursor], cursor:cur}

  nonInterpolatedStringLine = (quote, quoteLength) ->
    result = ''
    while c=text[cursor]
      if text[cursor...cursor+quoteLength]==quote then return result
      else if x=newline() then return result+escapeNewLine(x.value)
      else if c=='\\'
        result += '\\'; cursor++
        if x=newline() then return result+escapeNewLine(x.value)
        else if c=text[cursor] then result += c else return result
      else if c=='"'  then result += '\\"'
      else result += c
      ++cursor
    error 'unexpected end of input while parsing non interpolated string'

  @nonInterpolatedString = memo ->
    if text[cursor...cursor+3]=="'''" then quote = "'''"
    else if text[cursor]=="'" then quote = "'"
    else return
    cur = cursor; line1 = row; quoteLength = quote.length; indentCol = null
    if cursor==lineInfo[row].start+lineInfo[row].indentCol then indentCol = lineInfo[row].indentCol
    cursor += quoteLength; str = ''
    while text[cursor]
      if text[cursor...cursor+quoteLength]==quote
        cursor += quoteLength
        return {type: NON_INTERPOLATE_STRING, value: '"'+str+'"', start:cur, stop:cursor, line1:line1, line: row}
      if lineInfo[row].empty
        str += nonInterpolatedStringLine(quote, quoteLength)
        continue
      else if row!=line1
        myLineInfo =  lineInfo[row]; myIndent = myLineInfo.indentCol
        if indentCol==null then indentCol = myIndent
        else if myIndent<indentCol then error 'wrong indent in string'
        cursor += indentCol
      str += nonInterpolatedStringLine(quote, quoteLength)
    if not text[cursor] then error 'expect '+quote+', unexpected end of input while parsing interpolated string'

  interpolateStringPiece = (quote, quoteLength, indentCol, lineIndex) ->
    str = '"'
    while c = text[cursor]
      if text[cursor...cursor+quoteLength]==quote then return str+'"'
      else if c=='"'
        if c!=quote then str +='\\"'; cursor++
        else return str +'\\"'
      else if x = newline()
        if not lineInfo[row].empty and (myIndent=lineInfo[row].indentCol) and lineIndex.value++
          if indentCol.value==null then indentCol.value = myIndent
          else if myIndent!=indentCol.value then error 'wrong indent in string'
          else cursor += myIndent
        return str+escapeNewLine(x)+'"'
      else if c=='(' or c=='{' or c=='[' then return str+c+'"'
      else if  c=='$' then return str+'"'
      else if c=='\\'
        if not (c2=text[cursor+1]) then break
        else if c2=='\n' or c2=='\r' then cursor++; str += '\\'
        else cursor += 2; str += '\\'+c2
      else str += c; cursor++
    error 'unexpected end of input while parsing interpolated string'

  @interpolatedString = memo ->
    if text[cursor...cursor+3]=='"""' then quote = '"""'
    else if text[cursor]=='"' then quote = '"'
    else return
    cur = cursor; line1 = row; indentCol = null
    if (col=parser.getCol())==lineInfo[row].indentCol then indentCol = {value:col}
    else indentCol = {}
    quoteLength = quote.length; cursor += quoteLength; pieces = []
    lineIndex = {value:0}
    while c=text[cursor]
      if text[cursor...cursor+quoteLength]==quote
        cursor += quoteLength
        return {type: INTERPOLATE_STRING, value: ['string!'].concat(pieces), start:cur, stop:cursor, line1:line1, line: row}
      if c=='$'
        literalStart = cursor++
        x = parser.interpolateExpression()
        if x
          x = getOperatorExpression x
          if text[cursor]==':'
            cursor++
            pieces.push text[literalStart...cursor]
          pieces.push x
        else pieces.push '"$"'
      else if c=='(' or c=='{' or c=='['
        if x=parser.delimiterExpression('inStrExp')
          pieces.push getOperatorExpression(x)
          if c=='(' then pieces.push '")"'
          else if c=='[' then  pieces.push '"]"'
          else if c=='{' then  pieces.push '"}"'
        else pieces.push '"'+c+'"'
      else pieces.push interpolateStringPiece(quote, quoteLength, indentCol, lineIndex)
    if not text[cursor] then error 'expect '+quote+', unexpected end of input while parsing interpolated string'

  @string = -> parser.interpolatedString() or parser.nonInterpolatedString()

  @paren = paren = memo ->
    startToken = getToken()
    if token.value!='(' then return
    else token = matchToken()
    if isSpaceToken(token)
      if token.undent then error 'unexpected undent while parsing parenethis "(...)"'
      else token = matchToken()
    exp = parser.operatorExpression()
    if token.isUndent and token.indent<startToken.indent then error 'expect ) indent equal to or more than ('
    if token.value!=')' then error 'expect )'
    else token = matchToken()
    wrapResult exp, {type: PAREN, start:cur, stop:token}

  curveVariantMap = {
    '.': ->  matchToken(); return hash()
  }

  @curve = curve = memo ->
    cur = token
    if token.value!='{' then return
    matchToken()
    if (curveVariantFn=curveVariantFnMap[token.value]) then return curveVariantFn()
    assertNotUndent(); skipSpaceToken()
    if token.value=='}' then  matchToken(); return extend ['hash!'], {start:cur, stop:token}
    body = parser.lineBlock()
    if token.indent<startIndent then error 'unexpected undent while parsing parenethis "{...}"'
    if token.value!='}' then error 'expect }' else cursor++
    if body.length==0 then return {type: CURVE, value:'', start:cur, stop: token}
    if body.length==1 then body = body[0]
    else body.unshift 'begin!'
    extend body, {type: CURVE, start:cur, stop: cursor, line1:line1, line:row}

  bracketVariantMap = {
  }

  @bracket = memo ->
    cur = token
    if token.value!='[' then return
    matchToken()
    if (curveVariantFn=curveVariantFnMap[token.value]) then return curveVariantFn()
    assertNotUndent(); skipSpaceToken()
    expList = parser.lineBlock()
    bigSpace()
    if token.indent<start.indent then error 'unexpected undent while parsing parenethis "[...]"'
    if text[cursor]!=']' then error 'expect ]' else cursor++
    if expList then expList.unshift 'list!'
    else expList = []
    wrapResult expList, {type: BRACKET, isBracket: true, start:cur, stop: cursor, line1:line1, line:row}

  @hashItem = memo ->
    if isIndent(token) then error 'unexpected indent'
    else if isUndent(token) then return
    if key=parser.compactClauseExpression()
      if isMultiline(token) then error 'unexpected new line after hash key'
      if token.value==':' and matchToken()
        if (t=key.type)==IDENTIFIER or t==NUMBER or t==NON_INTERPOLATE_STRING then js = true
      else if text[cursor...cursor+2]=='=>' then cursor+=2
      else error 'expect : or => for hash item definition'
      if (spac=follow('spaceComment')) and spac.indent
        value = ['hash!'].concat parser.hashBlock()
      else value = parser.clause()
      if not value then error 'expect value of hash item'
      if js then result = ['jshashitem!', getOperatorExpression(key), value]
      else result = ['pyhashitem!', getOperatorExpression(key), value]
      wrapResult result, {start:cur, stop:cursor, line1:line1, line:row}

  @hashBlock = memo ->
    cur = cursor; line1 = row; column1 = lineInfo[row].indentCol
    if (spac=bigSpace()) and spac.undent then return
    result = []; if spac.indent then indentCol = lineInfo[row].indentCol
    while (x=parser.hashItem()) and result.push x
      space()
      if not (c=text[cursor]) then break
      if c=='.'
        if text[cursor+1]=='}' then break
        else error 'unexpected ".", expect .} to close hash block'
      if c==';' then cursor++
      space2 = bigSpace()
      if not (c=text[cursor]) or c=='}' then break
      if row==line1 then continue
      if (col=lineInfo[row].indentCol)>column1
        if indentCol and col!=indentCol then error 'unconsistent indent in hash {. .}'
        else indentCol = col
      else if col==column1 then break
      else if col<column1 then rollbackToken space2; return
    result.start = cur; result.stop = cursor; result

  @hash = memo ->
    cur = cursor; line1 = row; indentCol = lineInfo[row].indentCol
    if text[cursor...cursor+2]!='{.' then return else cursor += 2
    items = parser.hashBlock()
    if lineInfo[row].indentCol<indentCol then error 'unexpected undent while parsing parenethis "{.  ... .}"'
    if text[cursor...cursor+2]!='.}' then error 'expect .}' else cursor += 2
    wrapResult ['hash!'].concat(items), {start:cur, stop:cursor, line1:line1, line:row}

  @delimiterExpression = memo -> parser.paren() or parser.dataBracket() or parser.bracket() or parser.curve() or parser.hash()

  @escapeSymbol = escapeSymbol = ->
    cur = cursor; line1 = row
    if text[cursor]!='\\' then return
    cursor++; sym = parser.symbol()
    if not sym then return rollback(cur, line1)
    else sym.start = cur; sym.escape = true; return sym

  @escapeStringSymbol = ->
    if token.value!="\\" then return
    matchToken()
    if token.type!=NON_INTERPOLATED_STRING then return
    if isMultipleLines(token) then rollback cur
    matchToken()
    wrapResult ['symbol!', token], {type: SYMBOL, escape: true, start:cur, stop:token}

  @delimiterCharset = charset('|\\//:')

  @rightDelimiter = (delimiter) ->
    cur = cursor
    if text[cursor...cursor+2]=='.}' then cursor += 2; return '.}'
    while (c=text[cursor]) and parser.delimiterCharset[c] then cursor++
    if c!=')' and c!=']' and c!='}' then cursor = cur; return  # and c!='>'
    cursor++
    if delimiter
      if text[cur...cursor]!=delimiter then cursor = cur; return
      else delimiter
    else text[cur...cursor]

  @symbolOrIdentifier = -> parser.symbol() or parser.identifier()
  atomTokenTypes = {IDENTIFIER:1, NUMBER:1, REGEXP:1, CURVE: 1, HASH: 1, BRACKET:1, PAREN:1, SYMBOL:1}
  @atom = (mode) ->
    if atomTokenTypes[token.type]
      atomToken = token; matchToken(); atomToken.priority = 1000;
      return wrapResult atomToken, {start:atomToken}

  # prefix operator don't need to be compared to current global priority
  @prefixOperator = (mode) ->
    # hasOwnProperty.call is necessary in order to avoid error while builtin attribute of object is defined prefix operator
    if hasOwnProperty.call(prefixOperatorDict, token.value) and (op=prefixOperatorDict[token.value]) then return
    opToken = token; matchToken()
    if token.value==':'
      matchToken()
      if isSpace(token)
        if mode==PAREN_EXPR then error 'unexpected spaces after :'
        else token = opToken; return
    else if isSpace(token)
      if isIndent(token) then error 'unexpected indent after prefix operator'
      else if isNewline(token) then error 'unexpected new line after prefix operator'
      priInc = 300
    else if not canFollowPrefix(token)
      error 'unexpected '+token.value+' after prefix operator'
    else priInc = 600
    opToken.symbol = op.symbol; opToken.value = op.priority+priInc
    wrapResult opToken, {start:opToken, token}

  # suffix operator must be symbol, should follow space, right delimiters or punctuations.
  @suffixOperator = (mode, x, priority) ->
    if token.type!=SYMBOL then return
    if (op=suffixOperatorDict[token.value]) and op.priority+600>=priority
      token.symbol = op.symbol; token.priority = op.priority+600
      opToken = token; matchToken()
      if canFollowSuffix() then return wrapResult opToken, {start: cur}
      else token = opToken; return

  canFollowSufix = () -> (t=token.type)==SPACE or t==RIGHT_DELIMITER or t==PUNCTUATION or t==EOI

  parser.clauseEnd = (spac) ->
    cur = cursor; line1 = row
    spac = spac or bigSpace()
    if (c=text[cursor])==','
      if not spac.inline then error '"," should not be at the head of a line'
      cursor++; return true
    if parser.sentenceEnd(spac) or c==';' then  rollbackToken spac; return true

  parser.expressionEnd = (mode, spac) ->
    if (not parser.isClauseExpression(mode)) then return
    (c=text[cursor])==':' and text[cursor+1]!=':'  or parser.clauseEnd(spac)\
    or (mode=='comClExp' and spac.value) or (mode=='inStrExp' and (c=="'" or c=='"'))

  parser.isClauseExpression = (mode) -> mode=='comClExp' or mode=='spClExp' or mode=='inStrExp'

  @binaryOperator = (mode, x, priority, leftAssoc) ->
    if isEOI(token) then return
    else if op=binaryDictOperator(mode, x, priority, leftAssoc) then return op
    else if op=parser.customBinaryOperator(mode, x, priority, leftAssoc) then return op

  binaryDictOperator = (mode, x, priority, leftAssoc) ->
    start = token
    if isInlineSpace(token) then priInc = 300
    else if isMultiplelines(token) then priInc = 0
    else priInc = 600; if token.value=='.' then matchToken()
    if priority>=priInc+300 then return
    value = token.value
    if not hasOwnProperty.call(binaryOperatorDict, value) or not (op=binaryOperatorDict[value])
      token = start; return
    opToken = token; matchToken()
    if token.value=='.'
      if priInc==600 then error 'unexpected "." after binary operator '+opToken.value+', here should be spaces, comment or newline'
      else
        # assure token is not identifier while parsing custom binary attribute operator
        matchToken()
    if parser.expressionEnd(mode) then token = start; return
    if isUndent(token) then error 'unexpected undent after binary operator "'+opToken.value+'"'
    if isEOI(token) then error 'unexpected end of input, expect right operand after binary operator'
    if token.type==RIGHT_DELIMITER then return
    if priInc==600
      if isSpace(Token)
        if op.value==',' then priInc = 300
        else if (c=text[cursor])==';' then error 'unexpected ;'
        else error 'unexpected spaces or new lines after binary operator "'+op.value+'" before which there is no space.'
      pri = op.priority+priInc
      if (leftAssoc and pri<=priority) or pri<priority then return rollback start, line1
      extend {}, op, {priority: pri}
    else if priInc==300
      pri = op.priority+priInc
      if isSpace(Token)
        if isUndent(token) then error 'unexpceted undent after binary operator '+op.value
        else if isNewline(token) then priInc = 0
        else if isIndent(token)
          priInc = 0; indentStart = cursor; indentLine = row
          indentExp = parser.recursiveExpression(cursor)(mode, 0, true)
          if  (space3=bigSpace()) and not space3.undent and text[cursor] and text[cursor]!=')'
            error 'expect an undent after a indented block expression'
          indentExp = {type: INDENT_EXPRESSION, value: indentExp, priority:1000}
          tag = 'expr('+mode+','+300+','+(0+!op.rightAssoc)+')'
          saveMemo tag, indentStart, indentExp
          cursor = indentStart
      else
        if mode=='opExp' then error 'binary operator '+op.symbol+' should have spaces at its right side.'
        else return rollback start, line1
      if (leftAssoc and pri<=priority) or pri<priority then return rollback start, line1
      extend {}, op, {priority: pri}
      # below must in operator expression (...) mode, not in clause mode.
    else
      if priority>300 then return rollback start, line1
      # any operator near newline always have the priority 300, i.e. compute from up to down
      if op.valu==',' or op.value==':' or op.value=='%'  or op.assign
        error 'binary operator '+op.symbol+' should not be at begin of line'
      if space2.undent then error 'binary operator should not be at end of block'
      else if space2.newline then error 'a single binary operator should not occupy whole line.'
      if space1.indent
        priInc = 0; indentStart = cursor; indentLine = row
        indentExp = parser.recursiveExpression(cursor)(mode, 0, true)
        if  (space3=bigSpace()) and not space3.undent and text[cursor] and text[cursor]!=')'
          error 'expect an undent after a indented block expression'
        indentExp = {type: INDENT_EXPRESSION, value: indentExp, priority:1000}
        tag = 'expr('+mode+','+300+','+(0+!op.rightAssoc)+')'
        saveMemo tag, indentStart, indentExp
        cursor = indentStart; row = indentLine
      extend {}, op, {priority: 300}

  @followParenArguments = -> # use the private paren
    start = cursor; line1 = row
    x=paren()
    #always rollback, because just followParenArguments
    rollback start, line1; return  x

  @binaryCallOperator = (mode, x, priority, leftAssoc) ->
    if isSpace(token)
      start = token
      matchToken()
      if token.type==PAREN
        if mode==PAREN_EXPR then throw '() as call operator should tightly close to the left caller'
      else token = start;  return
    else if 800>priority
      start = token; matchToken()
      if token.type==PAREN
        return {symbol:'call()', type: SYMBOL, priority: 800, start:cursor, stop:cursor, line:row}
      else token = start


#  @binaryMacroCallOperator = (mode, x, priority, leftAssoc) ->
#    start = cursor; line1 = row
#    space1=space()
#    if text[cursor]!='#' then return rollback start, line1
#    cursor++; space2 = space();
#    if !!space2.value != !!space1.value and text[cursor]=='('
#      error 'should have spaces on both or neither sides of symbol around "#"'
#    if not parser.followParenArguments() then return rollback start, line1
#    pri = space1.value? 500 : 800
#    if pri<=priority then rollback start, line1
#    return {symbol:'#()', type: SYMBOL, priority: 800, start:cursor, stop:cursor, line:row}

  @binaryIndexOperator = (mode, x, priority, leftAssoc) ->
    start = cursor; line1 = row
    if (spac=bigSpace()) and spac.value and follow('bracket')
      if mode=='opExp'
        throw '[] as subscript should tightly close to left operand'
      else rollback start, line1;  return
    else if 800>priority and follow('bracket')
      return {symbol:'index[]', type: SYMBOL, priority: 800, start:cursor, stop:cursor, line:row}
    rollback start, line1;  return

  # a.b, fn(x, y).b
  @binaryAttributeOperator = (mode, x, priority, leftAssoc) ->
    start = cursor; line1 = row
    if (spac=bigSpace()) and spac.value
      if 500<=priority then return rollback start, line1
      if not (text[cursor]=='.' and text[cursor+1]!='.') then return rollback start, line1
      if text[cursor]=='}' then  return rollback start, line1
      cursor++
      if not (space2=bigSpace())
        error 'expect spaces after "." because there are spaces before it'
      else return {symbol:'attribute!', type: SYMBOL, priority: 500}
    else if 800>priority and (text[cursor]=='.' and text[cursor+1]!='.') and ++cursor
      if text[cursor]=='}' then  return rollback start, line1
      if (spac=bigSpace()) and spac.value
        error 'unexpected spaces after "." because there are no space before it'
      else if follow('symbol') then return
      else return {symbol:'attribute!', type: SYMBOL, priority: 800}
    return rollback start, line1

#  # @attr, @[1], @['ads']
#  @binaryAtThisAttributeIndexOperator = (mode, x, priority, leftAssoc) ->
#    if 800<=priority or x.value!='@' then return
#    if x.stop!=cursor then return
#    if follow('jsIdentifier')
#      {symbol:'attribute!', type: SYMBOL, start: cursor, stop:cursor, line: row, priority: 800}
#    else if follow 'bracket'
#      {symbol:'index!', type: SYMBOL, start: cursor, stop:cursor, line: row, priority: 800}

#  # @::, obj::, obj::y
#  @binaryPrototypeAttributeOperator = (mode, x, priority, leftAssoc) ->
#    if 800<=priority then return
#    if (x.type==IDENTIFIER or x.value=='@') and text[cursor...cursor+2]=='::' and text[cursor+2]!=':'
#      {symbol:'attribute!', type: SYMBOL, start: cursor, stop:cursor, line: row, priority: 800}
#    else if  text[cursor-3]!=':' and text[cursor-2...cursor]=='::'
#      if followMatch (-> parser.recursiveExpression(cursor)(mode, 800, leftAssoc))
#        {symbol:'attribute!', type: SYMBOL, start: cursor, stop:cursor, line: row, priority: 800}

#  @customBinaryOperators = [@binaryAttributeOperator, @binaryCallOperator, @binaryMacroCallOperator, @binaryIndexOperator,
#                            @binaryAtThisAttributeIndexOperator, @binaryPrototypeAttributeOperator]

  @customBinaryOperator = (mode, x, priority, leftAssoc) ->
    for fn in parser.customBinaryOperators then if op = fn(mode, x, priority, leftAssoc)  then return op
    return

#  # any binary function can be used as binary exports, and the priority to be used actually is set here.
#  @binaryFunctionPriority = 35

  @prefixExpression = (mode, priority) ->
    start = cursor; line1 = row
    # current global prority doesn't affect prefixOperator
    if op=parser.prefixOperator(mode)
      pri = if priority>op.priority then priority else op.priority
      x = parser.recursiveExpression(cursor)(mode, pri, true)
      if x then extend makeOperatorExpression('prefix!', op, x), {start:start, stop:cursor, line1:line1, line:row}

  @recursiveExpression = recursive = (start) ->
    x = null; line1 = row
    expression = (mode, priority, leftAssoc) ->
      tag = 'expr('+mode+','+priority+','+(0+leftAssoc)+')'
      if not (m=memoMap[tag]) then m = memoMap[tag] = {}
      else if result=m[start] then cursor = result.stop; row = result.line; return result
      if not x
        if not x = parser.prefixExpression(mode, priority)
          if not x = parser.atom(mode) then memoMap[tag][start] = null; return
      if op = parser.suffixOperator(mode, x, priority)
        x = extend makeOperatorExpression('suffix!', op, x), {start:start, stop:cursor, line1:line1, line:row}
        # the priority and association of suffix operator does not affect the following expression
      if op = parser.binaryOperator(mode, x, priority, leftAssoc)
        # should assure that a right operand is here while parsing binary operator
        y = recursive(cursor)(mode, op.priority, not op.rightAssoc)
        x = extend makeOperatorExpression('binary!', op, x, y), {start:start, stop:cursor, line1:line1, line:row}
        return expression(mode, priority, leftAssoc)
      m[start] = x

  # the priority of operator vary from 0 to 300,
  # if there is no space between them, then add 600, if there is spaces, then add 300.
  # if meet newline, add 0.
  @operatorExpression = operatorExpression = -> parser.recursiveExpression(cursor)('opExp', 0, true)
  # compact expression as clause item.
  @compactClauseExpression = -> parser.recursiveExpression(cursor)('comClExp', 600, true)
  # space expression as clause item.
  @spaceClauseExpression = spaceClauseExpression = -> parser.recursiveExpression(cursor)('spClExp', 300, true)
  # interpolate expression embedded in string
  @interpolateExpression = -> parser.recursiveExpression(cursor)('inStrExp', 600, true)

  @isIdentifier = isIdentifier = (item) -> item.type==IDENTIFIER

  @itemToParameter = itemToParameter = (item) ->
    if item.type==IDENTIFIER then return item
    else if item0=item[0]
      if item0=='attribute!' and item[1].value=='@' then return item
      else if item0.symbol=='x...'
        parser.meetEllipsis = item[1].ellipsis = true
        return item
      else if entity(item0)=='=' # default parameter
        # default parameter should not be ellipsis parameter at the same time
        # and this is the behavior in coffee-script too
        # and (item01[0].symbol!='x...' or not isIdentifier(item01[1]).type==IDENTIFIER)
        if (item1=item[1]) and item1.type==IDENTIFIER then return item
        else if ((item10=item1[0]) and item10=='attribute!' and item1[1].value=='@') then return item
        else return
      # for dynamic parser and writing macro
      else if item0.symbol=='unquote!' or item0.symbol=='unquote-splice'
        return item

  @toParameters = toParameters = (item) ->
    if not item then return []
    if x=itemToParameter(item) then return [x]
    else if item[0]==','
      result = for x in item[1...]
        if not(param=itemToParameter(x)) then meetError = true; break
        if param.ellipsis
          if meetEllipsis then meetError = true; break
          else meetEllipsis = true
        param
      if not meetError then result

  leadWordClauseMap =
    # eval while parsing, call by %% clause
    # e.g.
    # %% %text()
    # %% %cursor()
    # %% %number()1234
    '%%':  (clause) ->
      code = compileExp(['return', clause], environment)
      new Function('__$taiji_$_$parser__', code)(parser)

    # the head of clause will be convert to attribute of __$taiji_$_$parser__
    # see exports['%/'] and convertParserAttribute in core.coffee
    # {%/ matcheA(x, y) } will be converted to {%% %matchA(x, y)}
    '%/': (clause) ->
      # notice the difference between %% and %/
      # here ['%/', clause] is compiled
      code=compileExp(['return', ['%/', clause]], environment)
      new Function('__$taiji_$_$parser__', code)(parser)

    # identifier in clause will be convert to attribute of __$taiji_$_$parser__
    # see exports['%!'] and convertParserAttribute in core.coffee
    # {%! matcheA(x, y) } will be converted to {%% %matchA(%x, %y)}
    '%!': (clause) ->
      code=compileExp(['return', ['%!', clause]], environment)
      new Function('__$taiji_$_$parser__', code)(parser)

    '~':  (clause) -> ['quote!', clause]
    '`':  (clause) -> ['quasiquote!', clause]
    '^':  (clause) -> ['unquote!', clause]
    '^&': (clause) -> ['unquote-splice', clause]

    # preprocess opertator
    # see # see metaConvertFnMap['#'] and preprocessMetaConvertFnMap for more information
    '#':  (clause) -> ['#', clause]

    # evaluate in compile time
    # see metaConvertFnMap['##']
    '##':  (clause) -> ['##', clause]

    # evaluate in both compile time and run time
    # see metaConvertFnMap['#/']
    '#/': (clause) -> ['#/', clause]

    # escape from compile time to runtime
    # see metaConvertFnMap['#-']
    '#-': (clause) -> ['#/', clause]

    # #& metaConvert exp and get the current expression(not metaConverted raw program)
    # see metaConvertFnMap['#&']
    '#&': (clause) -> ['#&', clause]

  @leadWordClause = ->
    start = cursor; line1 = row
    if not (key = parser.symbol() or parser.identifier()) then return
    if (spac=space()) and (not spac.value or spac.undent) then return rollback start, line1
    if not (fn=leadWordClauseMap[key.value]) then return rollback start, line1
    clause = fn(parser.clause())
    if clause and typeof clause=='object'
      extend clause, {start:start, stop:cursor, line1:line1, line:row}
    else extend {value:clause}, {start:start, stop:cursor, line1:line1, line:row}

  @labelStatement = ->
    start = cursor; line1 = row
    if not (lbl=parser.jsIdentifier()) then return
    if text[cursor]!='#' then cursor = start; return
    cursor++
    if (spac=bigSpace()) and (not spac.value or spac.undent or spac.newline)  then cursor = start; return
    if clause=parser.clause() then clause = ['label!', lbl, clause]
    else clause = ['label!', lbl, '']
    extend clause, {start:start, stop:cursor, line1:line1, line:row}

  @conjunction = ->
    start = cursor
    if (x=symbol() or taijiIdentifier()) and isConj(x) then return x
    cursor = start; return

  @expectIndentConj = expectIndentConj = (word, line1, isHeadStatement, options, clauseFn) ->
    start2 = cursor; line2 = row
    if options.optionalClause? then optionalClause = options.optionalClause
    else optionalClause = word!='then'
    if options.optionalWord? then optionalWord = options.optionalWord
    else optionalWord = word=='then'
    indentCol = lineInfo[line1].indentCol
    spac = bigSpace(); col = lineInfo[row].indentCol
    if col==indentCol and row!=line1 and not isHeadStatement
      if not optionalClause
        error 'meet new line, expect inline keyword "'+word+'" for inline statement'
      else rollbackToken spac; return
    if col<indentCol
      if not optionalClause then error 'unexpected undent, expect '+word
      else rollbackToken spac; return
    else if col>indentCol
      if options.indentCol
        if col!=options.indentCol then error 'unconsistent indent'
      else options.indentCol = col
    w = taijiIdentifier()
    meetWord = w and w.value==word
    if not meetWord
      if isConj(w)
        if optionalClause then rollbackToken spac; return
        else  error 'unexpected '+w.value+', expect '+word+' clause'
      else if (not optionalWord and not optionalClause) or (
          not optionalClause and optionalWord and spac.inline)
        if word!='then' or not options.colonAtEndOfLine then error 'expect keyword '+word
      else if not optionalWord then return rollbackToken spac
      else if optionalClause then return rollbackToken spac
    if not meetWord then rollback start2, line2
    clauseFn()

  conjClause = (conj, line1, isHeadStatement, options) ->
    begin(expectIndentConj conj, line1, isHeadStatement, options, parser.lineBlock)

  thenClause  = (line1, isHeadStatement, options) -> conjClause 'then', line1, isHeadStatement, options
  elseClause  = (line1, isHeadStatement, options) -> conjClause 'else', line1, isHeadStatement, options
  finallyClause  = (line1, isHeadStatement, options) -> conjClause 'finally', line1, isHeadStatement, options
  catchClause = (line1, isHeadStatement, options) ->
    expectIndentConj 'catch', line1, isHeadStatement, options, ->
      line2 = row; space(); atStatementHead = false
      catchVar = parser.identifier(); space(); then_ = thenClause(line2, false, {})
      [catchVar, then_]

  caseClauseOfSwitchStatement = (line1, isHeadStatement, options) ->
    expectIndentConj 'case', line1, isHeadStatement, options, ->
      line2 = row; space(); atStatementHead = false
      exp = parser.compactClauseExpression()
      #if exp.isBracket then exp.shift()
      if exp[0]!='list!' then exp = ['list!', exp]
      space(); expectChar(':', 'expect ":" after case values')
      body = parser.block() or parser.lineBlock()
      [exp, begin(body)]

  @keyword = ->
    start = cursor
    if (x=symbol() or taijiIdentifier()) and isKeyword(x) then return x
    cursor = start; return

  # if test then action else action
  keywordThenElseStatement = (keyword) -> (isHeadStatement) ->
    line1 = row; space()
    if not (test=parser.clause())? then error 'expect a clause after "'+keyword+'"'
    then_ = thenClause(line1, isHeadStatement, options={colonAtEndOfLine: test.colonAtEndOfLine})
    else_ = elseClause(line1, isHeadStatement, options)
    if else_ then [keyword, test, then_, else_]
    else [keyword, test, then_]

  # while! test body...
  keywordTestExpressionBodyStatement = (keyword) -> (isHeadStatement) ->
    line1 = row; space()
    if not (test = parser.compactClauseExpression())
      error 'expect a compact clause expression after "'+keyword+'"'
    if not (body = parser.lineBlock()) then error 'expect the body for while! statement'
    [keyword, test, begin(body)]

  # throw or return value
  throwReturnStatement = (keyword) -> (isHeadStatement) ->
    space(); if text[cursor]==':' and text[cursor+1]!=':' then cursor++; space();
    if clause = parser.clause() then [keyword, clause] else [keyword]

  # break; continue
  breakContinueStatement = (keyword) -> (isHeadStatement) ->
    space()
    if lbl = jsIdentifier() then [keyword, lbl] else [keyword]

  letLikeStatement = (keyword) -> (isHeadStatement) ->
    line1 = row; space()
    varDesc = parser.varInitList() or parser.clause()
    [keyword, varDesc, thenClause(line1, isHeadStatement, {})]

  # no cursor and row is attached in result, so can not be memorized directly.
  @identifierLine = ->
    result = []
    while space() and not parser.lineEnd() and not follow('newline') and text[cursor]!=';'
      if x=parser.identifier() then result.push x
      else error 'expect an identifier'
    result

  # no cursor and row is attached in result, so can not be memorized directly.
  @identifierList = ->
    line1 = row; indentCol = lineInfo[line1].indentCol
    result = parser.identifierLine()
    spac = bigSpace();
    if (col0=lineInfo[row].indentCol)<=indentCol
      rollbackToken spac; return result
    if text[cursor]==';' then return result
    while varList=parser.identifierLine()
      result.push.apply result, varList
      spac = bigSpace()
      if (col=lineInfo[row].indentCol)<=indentCol then rollbackToken spac; break
      else if col!=col0 then error 'inconsistent indent of multiple identifiers lines after extern!'
      if text[cursor]==';' then break
    result

  @varInit = ->
    if not (id = parser.identifier()) then return
    space()
    if text[cursor]=='=' and cursor++
      if value=parser.block() then value = begin(value)
      else if not(value=parser.clause()) then error 'expect a value after "=" in variable initilization'
    space()
    if text[cursor]==',' then cursor++
    if not value then return id else return [id, '=', value]

  @varInitList = ->
    start = cursor; line1 = row; result = []
    indentCol0 = lineInfo[row].indentCol
    spac = bigSpace()
    col = lineInfo[row].indentCol
    if col>indentCol0 then indentCol1 = col
    else if spac.undent or spac.newline then error 'unexpected new line, expect at least one variable in var statement'
    while 1
      if x=parser.varInit() then result.push x
      else break
      space1 = bigSpace()
      col = lineInfo[row].indentCol
      if not text[cursor] or text[cursor]==';' or follow 'rightDelimiter' then break
      if row==line1 then continue
      if col>indentCol0
        if indentCol1 and col!=indentCol1 then error 'unconsitent indent in var initialization block'
        else if not indentCol1 then indentCol1 = col
      else if col==indentCol0 then break
      else rollbackToken space1
    # if not result.length then error 'expect at least one variable in var statement'
    if not result.length then rollback start, line1; return
    return result

  @importItem = ->
    start = cursor; line1 = row
    sym = parser.symbol()
    if sym and (symValue=sym.value)!='#' and symValue!='#/'
      error 'unexpected symbol after "as" in import! statement'
    name = parser.identifier()
    if name
      if name.value=='from'
        if sym
          error 'keyword "from" should not follow "#" or "#/" immediately in import! statement, expect variable name instead'
        else return rollback(start, row)
    else if text[cursor]=="'" or text[cursor]=='"'
      if sym
        error 'file path should not follow "#" or "#/" immediately in import! statement, expect variable name instead'
      else return  rollback(start, row)
    space()
    start1 = cursor; line2 = row
    if (as_=taijiIdentifier())
      if as_.value=='from' then as_ = undefined; rollback start1, line2
      else if as_.value!='as' then error 'unexpected word '+as_.value+', expect "as", "," or "from [module path...]"'
      else
        space()
        sym2 = parser.symbol()
        if sym2 and (symValue2=sym2.value)!='#' and symValue2!='#/'
          error 'unexpected symbol after "as" in import! statement'
        if symValue=='#/'
          if symValue2=='#'
            error 'expect "as #/alias" or or "as alias #alias2" after "#/'+name.value+'"'
        else if symValue=='#'
          if not symValue
            error 'meta variable can not be imported as runtime variable'
          else if symValue=='#/'
            error 'meta variable can not be imported as both meta and runtime variable'
        else if not symValue
          if symValue2=='#'
            error 'runtime variable can not be imported as meta variable'
          else if symValue2=='#/'
            'runtime variable can not be imported as both meta and runtime variable'
        space(); asName = expectIdentifier()
        if symValue=='#/' and not symValue2
          space(); sym3 = parser.symbol()
          if not sym3 then error 'expect # after "#/'+name.value+' as '+asName.value+'"'
          else if sym3.value!='#' then error 'unexpected '+sym3.value+' after "#/'+name.value+'as '+asName.value+'"'
          asName2 = expectIdentifier()
    if not as_
      if symValue=='#/' then return [[name, name], [name, name, 'meta']]
      else if symValue=='#' then return [[name, name, 'meta']]
      else return [[name, name]]
    else
      if symValue=='#/'
        if asName2 then return [[name, asName], [name,asName2, 'meta']]
        else return [[name, asName], [name,asName, 'meta']]
      else if symValue=='#' then return [[name, asName, 'meta']]
      else return [[name, asName]]

  @exportItem = ->
    runtime = undefined
    if text[cursor...cursor+2]=='#/' then cursor+=2; runtime = 'runtime'; meta = 'meta'; space()
    else if (c=text[cursor])=='#' then cursor++; meta = 'meta'; space()
    else runtime = 'runtime'
    if meta then name = expectIdentifier()
    else if not (name = taijiIdentifier()) then return
    space()
    if text[cursor]=='=' and cursor++
      space(); value = parser.spaceClauseExpression(); space()
    [name, value, runtime, meta]

  @spaceComma = spaceComma = -> space(); if text[cursor]==',' then cursor++; space(); return true
  @seperatorList = seperatorList = (item, seperator) ->
    if typeof item=='string' then item = parser[item]
    ->
      result = []
      while x=item()
        result.push x
        if seperator() then continue
        else break
      result

  @importItemList = seperatorList('importItem', spaceComma)

  @exportItemList = seperatorList('exportItem', spaceComma)

  @expectIdentifier = expectIdentifier = (message) ->
    if id=parser.identifier() then return id
    else error message or 'expect identifier'

  @expectOneOfWords = expectOneOfWords = (words...) ->
    space(); token = taijiIdentifier();
    if not token then error 'expect one of the words: '+words.join(' ')
    value = token.value; i = 0; length = words.length;
    while i<length then (if value==words[i] then return words[i] else i++)
    error 'expect one of the words: '+words.join(' ')

  maybeOneOfWords = (words...) ->
    space(); token = taijiIdentifier();
    if not token then return
    value = token.value; i = 0; length = words.length;
    while i<length then (if value==words[i] then return words[i] else i++)
    return
  expectWord = (word) -> space(); (if not (token=taijiIdentifier()) or token.value!=word then error 'expect '+ word); word
  word = (w) ->
    start = cursor; line1 = row; space()
    if not token=taijiIdentifier() then return
    if token.value!=w then return rollback(start, line1)
    return token

  @expectChar = expectChar = (c) -> if text[cursor]==c then cursor++ else error 'expect "'+c+'"'

  @endOfDynamicBlock = @eob = ->
    if cursor==endCursorOfDynamicBlockStack[-1] then return true
    else return false

  @keywordToStatementMap =
    '%': (isHeadStatement) ->
      start = cursor; line1 = row
      if not space().value then return
      leadClause = parser.clause()
      code = compileExp(['return', ['%/', leadClause]], environment)
      space(); indentCol = lineInfo[row].indentCol
      if expectWord('then') or (text[cursor]==':' and cursor++)
        space()
        if newline()
          blockStopLineno = row
          while lineInfo[blockStopLineno].indentCol>indentCol and blockStopLineno<maxLine
            blockStopLineno++
          cursorAtEndOfDynamicBlock = lineInfo[blockStopLineno].indentCol or text.length
        else
          blockStopLineno = row+1
          cursorAtEndOfDynamicBlock = lineInfo[blockStopLineno].indentCol or text.length
      else error 'expect "then" or ":"'
      endCursorOfDynamicBlockStack.push cursorAtEndOfDynamicBlock
      result = new Function('__$taiji_$_$parser__', code)(parser)
      endCursorOfDynamicBlockStack.pop()
      cursor = cursorAtEndOfDynamicBlock; row = blockStopLineno
      if Object::toString.call(result) == '[object Array]'
        extend result, {start: start, stop:cursor, line1: line, row:row}
      else {value: result, start: start, stop:cursor, line1: line1, row:row}

    'break': breakContinueStatement('break')
    'continue': breakContinueStatement('continue')
    'throw': throwReturnStatement('throw')
    'return': throwReturnStatement('return')
    'new': throwReturnStatement('new')

    'var': (isHeadStatement) -> ['var'].concat parser.varInitList()
    'extern!': (isHeadStatement) -> ['extern!'].concat parser.identifierList()
    'include!': (isHeadStatement) ->
      space(); filePath = expect('string', 'expect a file path')
      space()
      if word('by')
        space(); parseMethod = expect('taijiIdentifier', 'expect a parser method')
      ['include!', filePath, parseMethod]

    # import [#/]name [as [#/]name] ... from path as [#/]name #name [by method]
    'import!': (isHeadStatement) ->
      space()
      items = parser.importItemList(); space()
      if items.length then from_ = expectWord('from') # or items[0][2]
      else from_ = word('from')
      #if not from_ then return ['import!', names[0][0], names[0][1], []]
      space(); srcModule = parser.string(); space();
      if as_ = literal('as')
        space()
        sym = parser.symbol()
        if sym
          if (symValue=sym.value)!='#' and sym.value!='#/'
            error 'unexpected symbol before import module name', sym
        alias = expectIdentifier('expect an alias for module')
        if symValue=='#' then metaAlias = alias; alias = undefined
        else if symValue=='#/' then metaAlias = alias
        space()
        sym2 = parser.symbol()
        if sym and sym2 then error 'unexpected symbol after meta alias'
        space(); alias2 = parser.identifier()
        # sym is the first symbol # or #/
        if sym  and alias2 then 'unexpected identifier '+alias2+' after '+symValue+alias
        if alias2 then metaAlias = alias2
        space()
      if word('by')
        space(); parseMethod = expect('taijiIdentifier', 'expect a parser method')
      runtimeImportList = []; metaImportList = []
      for item in items
        for x in item
          if x[2] then  metaImportList.push x
          else runtimeImportList.push x
      ['import!'].concat [srcModule, parseMethod, alias, metaAlias, runtimeImportList, metaImportList]

    'export!': (isHeadStatement) -> space(); ['export!'].concat parser.exportItemList()

    'let': letLikeStatement('let')
    'letrec!': letLikeStatement('letrec!')
    'letloop!': letLikeStatement('letloop!')
    'if': keywordThenElseStatement('if')
    'while': keywordThenElseStatement('while')
    'while!': keywordTestExpressionBodyStatement('while!')

    'for': (isHeadStatement) ->
      line1 = row; space()
      if text[cursor]=='(' and cursor++
        init = parser.clause(); space(); expectChar(';')
        test = parser.clause(); space(); expectChar(';')
        step = parser.clause(); space(); expectChar(')')
        return ['cFor!', init, test, step, thenClause(line1, isHeadStatement, {})]
      name1 = expectIdentifier(); space()
      if text[cursor]==',' then cursor++; space()
      if (token=jsIdentifier()) and value=token.value
        if value=='in' or value=='of' then inOf = value
        else name2 = value; space(); inOf = expectOneOfWords('in', 'of')
        space(); obj = parser.clause()
      if name2
        if inOf=='in' then kw = 'forIn!!' else kw = 'forOf!!'
        [kw, name1, name2, obj, thenClause(line1, isHeadStatement, {})]
      else
        if inOf=='in' then kw = 'forIn!' else kw = 'forOf!'
        [kw, name1, obj, thenClause(line1, isHeadStatement, {})]

    'do': (isHeadStatement) ->
      line1 = row; space(); indentCol = lineInfo[row].indentCol
      body = parser.lineBlock()
      if newlineFromLine(line1, row) and not isHeadStatement then return body
      if not (conj=maybeOneOfWords('where', 'when', 'until'))
        error 'expect conjunction where, when or until'
      if conj=='where' then tailClause = parser.varInitList()
      else tailClause = parser.clause()
      if conj=='where' then ['let', tailClause, body]
      else if conj=='when' then ['doWhile!', body, tailClause]
      else ['doWhile!', body, ['!x', tailClause]]

    'switch': (isHeadStatement) ->
      line1 = row
      if not (test = parser.clause()) then error 'expect a clause after "switch"'
      options = {}; cases = ['list!']
      while case_=caseClauseOfSwitchStatement(line1, isHeadStatement, options) then cases.push case_
      else_ = elseClause(line1, isHeadStatement, options)
      ['switch', test, cases, else_]

    'try': (isHeadStatement) ->
      line1 = row;
      if not (test = parser.lineBlock()) then error 'expect a line or block after "try"'
      if atStatementHead and not isHeadStatement
        error 'meet unexpected new line when parsing inline try statement'
      options = {}; #catchClauses = ['list!']
      #while catch_=catchClause(line1, isHeadStatement, options) then catchClauses.push catch_
      #else_ = elseClause(line1, isHeadStatement, options);
      catch_ = catchClause(line1, isHeadStatement, options)
      if not catch_ then error 'expect a catch clause for try-catch statement'
      final = finallyClause(line1, isHeadStatement, options)
      #['try', begin(test), catch_, else_, final]
      ['try', begin(test), catch_[0], catch_[1], final]

    'class': (isHeadStatement) ->
      line1 = row; space();
      # class name should be provided explicitly
      name = expect('identifier', 'expect class name'); space()
      if parser.conjunction('extends') then space(); superClass = parser.identifier(); space()
      else supers = undefined
      if followNewline() and newlineFromLine(line1, line1+1) then body = undefined
      else body = parser.lineBlock()
      ['#call!', 'class', [name, superClass, body]]

  @statement = memo ->
    start = cursor; line1 = row
    if not (keyword = symbol() or taijiIdentifier()) then return
    if stmtFn = parser.keywordToStatementMap[keyword.value]
      isHeadStatement = atStatementHead; atStatementHead = false
      if stmt = stmtFn(isHeadStatement)
        return extend stmt, {start:start, stop:cursor, line1:line1, line:row}
    return rollback start, line1

  @defaultAssignLeftSide = memo ->
    start = cursor; line1 = row
    if not (x=parser.spaceClauseExpression()) then return
    if x.type==PAREN or x.type==BRACKET or x.type==DATA_BRACKET or x.type==CURVE
      rollback start, line1; return
    x = getOperatorExpression x
    if not x then  rollback start, line1; return
    if x.type==IDENTIFIER or ((e=entity(x)) and (e[0]=='attribute!' or e[0]=='index!')) then x
    else if x.value=='::' then x
    else if parser.isAssign(x[0]) then rollback x[1].stop, x[1].line; return x[1]
    else  rollback start, line1; return

  @isAssign = (val) -> (op=binaryOperatorDict[val]) and op.assign

  @defaultAssignSymbol = -> (x=parser.symbol()) and parser.isAssign(x.value) and x

  @defaultAssignRightSide = memo ->
    space2 = bigSpace()
    if space2.undent then error 'unexpected undent after assign symbol'+symbol.value
    else if space2.newline then error 'unexpected new line after assign symbol'+symbol.value
    parser.block() or parser.clause()

  @makeAssignClause = (assignLeftSide, assignSymbol, assignRightSide) -> ->
    start = cursor; line1 = row
    if not (left=assignLeftSide()) then return
    spac = space()
    if not (token=assignSymbol()) then return rollback start, line1
    right = assignRightSide(spac)
    if left.type==CURVE
      eLeft = entity(left)
      if typeof eLeft=='string'
        if eLeft[0]=='"' then error 'unexpected left side of assign: '+eLeft
        left = [left]
      else if eLeft and eLeft.push
        if eLeft[0]=='begin!' then error 'syntax error: left side of assign should be a list of variable names separated by space'
      else error 'unexpected left side of assign'
      return ['hashAssign!', left, right]
    extend [token, left, right], {start:start, cursor:cursor, line1:line1, line:row}

  @defaultAssignClause = @makeAssignClause @defaultAssignLeftSide, @defaultAssignSymbol, @defaultAssignRightSide

  @customAssignClauses = []

  @assignClause = memo ->
    for matcher in parser.customAssignClauses then if x=matcher() then return x
    parser.defaultAssignClause()

  @colonClause = memo ->
    start = cursor; line1 = row
    if not (result = parser.sequenceClause()) then return
    space()
    if (x=parser.symbol()) and x.value==':'
      spac = bigSpace()
      if spac.newline then error '":" should not before a new line'
      else if spac.undent then error '":" should not be before undent'
      else if spac.indent
        result.colonAtEndOfLine = true
        return result
      if not result.push or result.isBracket then result = [result]
      result.push.apply result, parser.clauses()
      result.stop = cursor; result.line = row
      result
    else return rollback start, line1

  @indentClause = memo ->
    start = cursor; line1 = row
    if not (head=parser.sequenceClause()) then return
    spac = bigSpace(); if not spac.indent then return rollback start, line1
    if parser.lineEnd() then return rollback start, line1
    if not (blk=parser.blockWithoutIndentHead()) then return rollback start, line1
    if not head.push then head = [head]; head.start = start; head.line1 = line1
    head.push.apply head, blk
    extend head, {stop:cursor, line:row}

  @macroCallClause = memo ->
    start = cursor; line1 = row
    if (head=parser.compactClauseExpression())
       if (space1=space()) and not space1.value then return rollback(start, line1)
       if text[cursor]=='#' and cursor++ and ((spac=space()) and spac.value or text[cursor]=='\n' or text[cursor]=='\r')
          if blk = parser.block()
            return extend ['#call!', head, blk], {cursor:start, line1:row, stop:cursor, line:row}
          else if args = parser.clauses()
            return extend ['#call!', head, args], {cursor:start, line1:row, stop:cursor, line:row}
    rollback(start, line1)

  # caller and one expression as operand, e.g.
  # print 1 + 2*5
  # console.log x+7 and z or others
  # it's ambiguous while the first item is identifier, caller, accessor, etc
  @unaryExpressionClause = memo ->
    start = cursor; line1 = row
    if (head=parser.compactClauseExpression()) and space() and (x=parser.spaceClauseExpression()) and parser.clauseEnd()
      if text[cursor]==',' then cursor++
      return extend [getOperatorExpression(head), getOperatorExpression(x)], {start:start, stop:cursor, line1:line1, line:row}
    return rollback start, line1

  # a expression may be not wrapped in parenthesis
  # it's ambiguous while the first item is identifier, caller, accessor, etc
  @expressionClause = memo ->
    start = cursor; line1 = row
    if (x=parser.spaceClauseExpression())
      if parser.clauseEnd() then return getOperatorExpression x
      else return rollback start, line1

  @defaultParameterList = ->
    if item=getOperatorExpression(paren(item))
      if params=parser.toParameters(item) then return params
      else
        if followSequence('inlineSpaceComment', 'defaultSymbolOfDefinition')
          error 'illegal parameters list for function definition'
        else rollbackToken item

  @defaultSymbolOfDefinition = ->
    if (x=parser.symbol())
      if (xValue=x.value) and xValue[0]!='\\' and ((xTail=xValue[xValue.length-2...])=='->' or xTail=='=>') then return x
      else rollbackToken(x)

  # a = -> x; b = -> y should be [= a [-> x [= b [-> y]]]]
  @defaultDefinitionBody = -> begin(parser.lineBlock()) or 'undefined'

  @makeDefinition = (parameterList, symbolOfDefinition, definitionBody) -> memo ->
    start = cursor; line1 = row
    if not (parameters=parameterList()) then parameters = []
    space()
    if not (token=symbolOfDefinition()) then return rollback start, line1
    space()
    body = definitionBody()
    extend [token, parameters, body], {start:start, stop:cursor, line1:line1, line:row}

  @defaultDefinition = @makeDefinition @defaultParameterList, @defaultSymbolOfDefinition, @defaultDefinitionBody

  @customDefinition = []

  @definition = memo ->
    for matcher in parser.customDefinition
      if x=matcher() then break
    if x or (x=parser.defaultDefinition()) then return x

  @clauseItem = ->
    start = cursor; line1 = row; spac = bigSpace()
    if not spac.inline then rollbackToken spac; return
    if parser.clauseEnd() then return
    if text[cursor]==':' and text[cursor+1]!=':' then return
    if (item=parser.definition()) then return item
    item = parser.compactClauseExpression()
    if item then return extend getOperatorExpression(item), {start:start, stop:cursor, line1:line1, line:row}

  @sequenceClause = memo ->
    start = cursor; line1 = row; clause = []
    while item = parser.clauseItem() then clause.push item
    if text[cursor]==',' then meetComma = true; cursor++
    if not clause.length and not meetComma then return
    extend clause, {start:start, stop:cursor, line1:line1, line:row}

  @customClauseList = ['statement','labelStatement',
    'leadWordClause', 'assignClause', 'colonClause', 'macroCallClause', 'indentClause',
    'expressionClause', 'unaryExpressionClause']

  @clause = memo ->
    start = cursor; line1 = row
    if (parser.clauseEnd()) then return
    for matcher in parser.customClauseList
      if x=parser[matcher]() then return x
    if not(clause = parser.sequenceClause()) then return
    if clause.length==1 then clause = clause[0]
    if typeof clause != 'object' then clause = {value: clause}
    extend clause, {start:start, stop:cursor, line1:line1, line:row}

  @clauses = -> result = []; (while clause=parser.clause() then result.push clause); return result

  @sentenceEnd = (spac) ->
    spac = spac or bigSpace()
    if parser.lineEnd() then return true
    if not spac.inline then rollbackToken(spac); return true

  @sentence = memo ->
    start = cursor; line1 = row
    if parser.sentenceEnd() then return
    if text[cursor]==';' then cursor++; return []
    extend parser.clauses(), {start:start, stop:cursor, line1:line1, line:row}

  @lineCommentBlock = memo ->
    start = cursor
    if comment=parser.lineComment()
      if comment.indent
        if comment.value[...3]=='///' then result = parser.blockWithoutIndentHead(); result.unshift ['directLineComment!', comment.value]; result
        else parser.blockWithoutIndentHead()
      else
        if text[start...start+3]=='///'
          [extend(['directLineComment!', comment.value], {start:start, stop:cursor, line: row})]
        else [extend(['lineComment!', comment.value], {start:start, stop:cursor, line: row})]

  @codeCommentBlockComment = memo ->
    if cursor!=lineInfo[row].start+lineInfo[row].indentCol then return
    if text[cursor]!='/' then return
    if (c=text[cursor+1])=='.' or c=='/' or c=='*' then return
    start = cursor; line1 = row; cursor++
    code = parser.lineBlock()
    extend [['codeBlockComment!', code]], {start:start, stop:cursor, line1: line1, line: row}

  @lineEnd = -> not text[cursor] or follow('conjunction') or follow('rightDelimiter')#  \

  @line = ->
    if parser.lineEnd() then return
    if x=(parser.lineCommentBlock() or parser.codeCommentBlockComment()) then return x
    result = []
    while x = parser.sentence() then result.push.apply result, x
    result

  # a block which must start with a indent
  @block = ->
    indentCol = lineInfo[row].indentCol; spac = bigSpace();
    if not spac.indent then return rollbackToken spac
    else
      x = parser.blockWithoutIndentHead()
      spac = bigSpace()
      if lineInfo[row].indentCol<indentCol then rollbackToken spac
      x

  # a block with out indent( the indent has been ate before).
  # stop until meet a undent (less indent col than the intent col of the start line)
  @blockWithoutIndentHead = ->
    indentCol = lineInfo[row].indentCol; result = []
    while (x=parser.line()) and (spac = bigSpace())
      if x.length!=1 or not (x0=x[0]) or (x0[0]!='lineComment!' and x0[0]!='codeBlockComment!')
        result.push.apply(result, x)
      if lineInfo[row].indentCol<indentCol then rollbackToken spac; break
    result

  @lineBlock = ->
    space1 = bigSpace(); if space1.indent then return parser.blockWithoutIndentHead()
    line = parser.line()
    cursor2 = cursor
    space2 = bigSpace()
    if indentCol<=indentCol1 then rollback cursor2
    else line.push.apply line, parser.blockWithoutIndentHead()
    line

  @moduleBody = ->
    body = []
    while 1
      if not x=parser.line() then break
      spac = bigSpace()
      body.push.apply body, x
      clearMemo()
      if lineInfo[row].indentCol<indentCol then rollbackToken spac; break
    if text[cursor] then error 'expect end of input, but meet "'+text.slice(cursor)+'"'
    begin body

  @moduleHeader = ->
    if not (literal('taiji') and spaces()  and  literal('language') and spaces() and
        (x=decimal()) and char('.') and (y=decimal()))
      error 'taiji language module should begin with "taiji language x.x"'
    if (x=x.value)!=0 or (y=y.value)!=1 then error 'taiji 0.1 can not process taiji language'+x+'.'+y
    row++
    while row<=maxLine and (lineInfo[row].indentCol>0 or lineInfo[row].empty) then row++
    if row>maxLine then cursor = text.length
    else cursor = lineInfo[row].start # lineInfo[row].indentCol = 0
    {type: MODULE_HEADER, version: {main:x, minor:y}, text: text[...cursor]}

  @module = ->
    # #!use/bin/node taiji
    if text[cursor...cursor+2]=='#!' then  scriptDirective = ['scriptDirective!', skipLineTail()]
    wrapResult ['module!', scriptDirective, parser.moduleHeader(), parser.moduleBody()], {type: MODULE}

  @init = (data, cur, env) ->
    @text = text = data; cursor = cur; lineno = 1
    token = {} # en empty token, which next is undefined, so nextToken will call matchToken
    memoMap = {}
    atStatementHead = true
    @environment = environment = env
    @meetEllipsis = false
    endCursorOfDynamicBlockStack = []

  @parse = (data, root, cur, env) ->
    parser.init(data, cur, env)
    matchToken()
    root()

  @lexError = lexError = (message) ->
    throw cursor+'('+lexRow+':'+lexCol+'): '+message+': \n'+text[cursor-40...cursor]+'|   |'+text[cursor...cursor+40]
  @error = error = (message) ->
    throw cursor+'('+row+':'+parser.getCol()+'): '+message+': \n'+text[cursor-40...cursor]+'|   |'+text[cursor...cursor+40]

  return @

{compileExp} = require '../compiler'