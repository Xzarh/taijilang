colors = require('colors')

{charset, isArray, wrapInfo1, wrapInfo2, str, entity} = require '../utils'

{extend, firstIdentifierChars, firstIdentifierCharSet, letterDigitSet, identifierChars,
digitCharSet, letterCharSet, identifierCharSet, firstSymbolCharset
taijiIdentifierCharSet, constant} = base = require './base'
digitChars = base.digits
letterChars = base.letters

{NUMBER,  STRING,  IDENTIFIER, SYMBOL, REGEXP,  HEAD_SPACES, CONCAT_LINE, PUNCT, FUNCTION, C_BLOCK_COMMENT
PAREN, BRACKET, DATA_BRACKET, CURVE, INDENT_EXPRESSION
NEWLINE,  SPACES,  INLINE_COMMENT, SPACES_INLINE_COMMENT,
LINE_COMMENT, BLOCK_COMMENT, CODE_BLOCK_COMMENT,CONCAT_LINE
NON_INTERPOLATE_STRING, INTERPOLATE_STRING, EOI
INDENT, UNDENT, HALF_DENT, MODULE_HEADER, MODULE, SPACE_COMMENT, TAIL_COMMENT
SPACE, HASH, RIGHT_DELIMITER, KEYWORD, CONJUNCTION

OPERATOR_EXPRESSION, COMPACT_CLAUSE_EXPRESSION, SPACE_CLAUSE_EXPRESSION, INTERPOLATE_EXPRESSION

} = constant

{prefixOperatorDict, suffixOperatorDict, binaryOperatorDict,
makeOperatorExpression, getOperatorExpression} = require './operator'

dict = (pairs...) ->
  d = {}; i = 0; pairsLength = pairs.length
  while i<pairsLength
    d[pairs[i]] = pairs[i+1]
    i += 2
  return d

exports.escapeNewLine = escapeNewLine = (s) -> (for c in s then (if c=='\n' then '\\n' else '\\r')).join('')

exports.keywordMap = keywordMap =
  'if': 1, 'try':1, 'switch':1, 'while':1, 'let':1, 'letrec!':1, 'letloop!':1, 'do':1, 'repeat':1
  'return':1, 'break':1, 'continue':1, 'throw':1,'function':1,'for':1
  'loop':1, 'class':1, 'var':1, 'for':1

keywordHasOwnProperty = Object.hasOwnProperty.bind(exports.keywordMap)

exports.isKeyword = isKeyword = (item) ->
  item and not item.escaped and hasOwnProperty.call(exports.keywordMap, item.text)

exports.conjMap = conjMap =
  'then':1, 'else':1, 'catch':1, 'finally':1, 'case':1, 'default':1, 'extends': 1
  'until':1, 'where':1, 'when':1
conjunctionHasOwnProperty = Object.hasOwnProperty.bind(exports.keywordMap)

exports.isConj = isConj = (item) ->
  item and not item.escaped and hasOwnProperty.call(exports.conjMap, item.text)

hasOwnProperty = Object::hasOwnProperty

begin = (exp) ->
  if not exp or not exp.push then return exp
  if exp.length==0 then ''
  else if exp.length==1 then exp[0]
  else exp.unshift('begin!'); exp

exports.Parser = ->
  parser = @; @predefined = predefined = {}
  unchangeable = ['cursor', 'setCursor', 'lineno', 'setLineno', 'atLineHead', 'atStatementHead', 'setAtStatementHead']

  # global variable used by lexer
  text = '' # text to be parsed
  textLength = 0 # total length of text to be parsed
  cursor = 0 # position pointer while do lexical parsing, use cur for local position pointer
  char = '' # current character, should assure char is the value of text[cursor] whenerver entering or leaving a function
  lineno = 0 # current line number, use line for local line number
  column = 0 # current column, use col for local column
  indent = 0 # global indent column of current line, use dent for local indent column
  atLineHead = true # global indicator to tell whether cursor is at the head of a line before any non space character

  token = undefined # global token generated by lexical parsing and used by the parser

  # global variable used by the syntax parser
  memoMap = {} # memorize the result for syntax matcher
  atStatementHead = true # whether is at head of statement
  environment = null # compiler environment used by dynamic evaluation while parsing
  endCursorOfDynamicBlockStack = [] # used by "then" block of ? clause to identifier end of dynamic block

  memoIndex = 0  # don't need be set in parser.init, memoMap need to be set instead.

  eof = {type:EOI, value:'', cursor: textLength, column: -1, indent: -1} # lineno wait to be filled
  eof.next = eof  # eof.next is always itself

  # to maintain the balance of delimterStack with memo function, it's the duty of programer who are extending the parser
  @memo = memo = (fn) ->
    tag = memoIndex++
    ->
      if (m=memoMap[tag]) and hasOwnProperty.call(m, cursor)
        if x=m[cursor] then cursor = x.stop; lineno = x.line
        return x
      else
        if not memoMap[tag] then memoMap[tag] = m = {}
        m[cursor] = fn()

  parser.saveMemo = saveMemo = (tag, start, result) ->
    if not memoMap[tag] then memoMap[tag] = {}
    result.stop = cursor; result.line = lineno
    memoMap[tag][start] = result

  # garbage collector: do this in some proper time, e.g. when starting to parse a sentence
  @clearMemo = -> memoMap = {}

  nextToken = ->
    if token.next then token = token.next
    else matchToken()

  @matchToken = matchToken = ->
    if not char
      eof.lineno = lineno+1
      token = eof # while reaching the end of input, always return eof
    else if fn = tokenFnMap[char] then fn(char)
    else tokenOnSymbolChar()
    return

  @token = -> token

  # a utility function to help chain token
  chainToken = (tkn) -> token.next = tkn; token = tkn

  tokenFnMap = {}

  tokenOnSymbolChar = ->
    cur = cursor; col = column
    while char
      if symbolStopChars[char] then break

      # //, /*, /!
      # "/!" always start a regexp
      if char=='/' and ((c2=text[cursor+1])=='/' or c2=='*' or c2=='!') then break
      # else if c2=='.' # should not reach here, because this /. is always in the middle of the symbol, not in the front
      # "\" should not be concatenated symbol if following symbol characters
      #else if char=='\\' and ((c2=text[cursor+1])=='\n'  or c2=='\r') then break
      cursor++; char = text[cursor]

    column += cursor-cur
    chainToken {type:SYMBOL, value: text.slice(cur, cursor),
    cursor:cur, stopCursor:cursor, line: lineno, column:col, indent:indent}

  symbolStopChars = extend charset(' \t\v\n\r()[]{},;:\'\".@\\'), identifierCharSet

  tokenFnMap['@'] = tokenFnMap['.'] = tokenOnAtChar = tokenOnDotChar = repeatedCharToken = ->
    cur = cursor; col = column; first = char; char = text[++cursor]
    while char==first then char = text[++cursor]
    column += cursor-cur
    chainToken {type: SYMBOL, value: text.slice(cur, cursor),
    cursor:cur, stopCursor:cursor,
    line: lineno, column:col, indent:indent}

  tokenFnMap[':'] = tokenOnColonChar = ->
    cur = cursor; col = column; first = char; char = text[++cursor]
    while char==first then char = text[++cursor]
    column += cursor-cur
    if cursor==cur+1 then type==PUNCT else type = SYMBOL
    chainToken {type: type, value: text.slice(cur, cursor),
    cursor:cur, stopCursor:cursor,
    line: lineno, column:col, indent: indent}

  # the word "space" below maybe means not spacebar key or space character ' ' or '\t'
  # it means anything piece like white space, e.g. ' ', '\t', etc.

  # token started with ' ' and '\t'
  tokenFnMap[' '] = tokenFnMap['\t'] = tokenOnSpaceChar = ->
    cur = cursor; line = lineno; col = column; dent = indent
    char = text[++cursor]; ++column; skipInlineSpace(dent)
    # skip concatenated line
    if char=='\\' and newline()
      while (c=text[cursor]) and c==' ' then cursor++; column++
      if c=='\n' or c=='\r' then error 'should not follow empty line as concatenated line'
      else if not c then unexpectedEOI('after concatenated line symbol "\"')
      if concatenating
        if column!=dent then error 'expect the same indent for the second and more concatenated lines'
      else if column<=dent then expectMoreIndent(dent, 'in the following concatenated line')
      concatIndent = column
      skipInlineSpace(concatIndent)
      if (c=text[cursor])=='\n' or c=='\r'
        error 'concatenated line should not have only spaces and comments'
      return chainToken {type: SPACE, value: text[cur...cursor], cursor:cur, stopCursor: cursor,
      line:line, stopLine:lineno, column:col, stopColumn: column, indent: dent}
    # skip empty lines, space lines, comment lines
    if newline()
      skipSpaceLines(dent); indent = column
      tkn = {type: SPACE, value: text[cur...cursor], cursor:cur, stopCursor: cursor,
      line:line, stopLine:lineno, column:col, stopColumn: column, indent: dent}
      if indent>dent then tkn.isIndent = true
      else if indent<dent then tkn.isUndent = false
      else tkn.isNewline = true
      return chainToken tkn
    else return  chainToken {type: SPACE, value: text[cur...cursor], cursor:cur, stopCursor: cursor,
    line:line, stopLine:lineno, column:col, stopColumn: column, indent: dent}

  # the lexical matcher skipSomething, leftSomething do not process global variable "char"
  #  so instead of using char, please use local c, ch etc as character in text to be parsed

  # should be called after a new line
  skipSpaceLines = (dent) ->
    while 1
      if not char then return
      while char and char==' ' then cursor++; char = text[cursor]; column++
      if char=='\t' then unexpectedTabCharAtLineHead()
      else if char=='\n'
        if char=='\r' then cursor += 2 else cursor++
        char = text[cursor];  lineno++; column = 0
        continue
      else if char=='\r'
        if char=='\n' then cursor += 2 else cursor++
        char = text[cursor];  lineno++; column = 0
        continue
      else if not char then break
      else if column!=dent then break
      else if char=='/'
        if (c2=text[cursor+1])=='/'
          cursor += 2; char = text[cursor]
          # skip line tail
          while (char=text[cursor]) and char!='\n' and char!='\r' then cursor++; char = text[cursor]
          continue
        # indent block comment /. ... /
        else if c2=='.'
          if atLineHead then leftIndentBlockComment(dent); continue
          else break # will be normal symbol
        else if c2=='*'
          cursor += 2; char = text[cursor]; leftCBlockComment()
          skipInlineSpace()
          if char=='\n'
            if char=='\r' then cursor += 2 else cursor++
            char = text[cursor];  lineno++; column = 0
            continue
          else if char=='\r'
            if char=='\n' then cursor += 2 else cursor++
            char = text[cursor];  lineno++; column = 0
            continue
          else break

        # regexp /! ... /
        else if c2=='!' then break

        # else if atLineHead then break # switch to tokenOnForwardSlashChar to process code block comment start symbol
        else break
      else break

  # skipInlineSpace is called by tokenOnSpaceChar
  # skiptInlineSpace should not generate independent token and called independently
  skipInlineSpace = (dent) ->
    while 1
      while char==' ' or char=='\t' then char = text[++cursor]
      if char=='/'
        if (c2=text[cursor+1])=='*' then cursor +=2; char = text[cursor]; column += 2; leftCBlockComment(dent); continue
        if c2=='/'
          # don't need to process column here, because want to skip characters until reaching new line
          cursor += 2; char = text[cursor]          
          while char!='\n' and char!='\r' then char = text[++cursor]; continue
          break
      break

  # \n\r, \r\n, \r, \n, don't eat spaces.
  @newline = newline = ->
    if (c=char)=='\r'
      cursor++;
      if (c2=text[cursor])=='\n' then cursor++; c2 = '\n'
      char = text[cursor]; lineno++; column = 0
    else if char=='\n'
      cursor++
      if (c2=text[cursor])=='\r' then cursor++; c2 = '\r'
      char = text[cursor]; lineno++; column = 0
    else return
    c+(c2 or '')

  # left indent block comment started with /., before entering this function, /. has been matched.
  leftIndentBlockComment = (dent) ->
    # skip line tail
    while char!='\n' and char!='\r' then cursor++; char = text[cursor]

    # skip lines that is empty or indent more spaces at the head
    while 1
      if char=='\n'
        if text[cursor+1]=='\r' then cursor+=2 else cursor++
        char = text[cursor]; lineno++; column = 0
        while char==' ' then cursor++; char = text[cursor]; column++
        if char=='\n' or char=='\r' then continue
        if char=='\t' then unexpectedTabCharAtLineHead()
        if column<=dent then break
      else if char=='\r'
        if text[cursor+1]=='\n' then cursor+=2 else cursor+=1
        char = text[cursor]; lineno++; column = 0
        while char==' ' then cursor++; char = text[cursor]; column++
        if char=='\n' or char=='\r' then continue
        if char=='\t' then unexpectedTabCharAtLineHead()
        if column<=dent then break
      else if not char then break

  # default /* some content */, can cross lines
  leftCBlockComment = (dent) ->
    # dent: the indent column of the line of '/*'
    while 1
      if char=='*' and text[cursor+1]=='/' then cursor += 2;  char = text[cursor]; column += 2; break
      else if char=='\n'
        cursor++;  char = text[cursor]; lineno++; column = 0
        if char=='\r' then cursor++;  char = text[cursor];
        while char==' ' then cursor++;  char = text[cursor]; column++
        if char=='\t' then unexpectedTabCharAtLineHead()
        if char=='\n' or char=='\r' then continue
        else if not char then unexpectedEOI('while parsing c style block comment /* */')
        if column<dent then expectMoreIndent(dent, 'while parsing c style block comment /* */')
      else if char=='\r'
        cursor++;  char = text[cursor]; lineno++; column = 0
        if char=='\n' then cursor++; char = text[cursor];
        while char==' ' then cursor++;  char = text[cursor]; column++
        if char=='\t' then unexpectedTabCharAtLineHead()
        if char=='\n' or char=='\r' then continue
        else if not char then unexpectedEOI('while parsing c style block comment /* */')
        if column<dent then expectMoreIndent(dent)
      else if not char
        unexpectedEOI('while parsing c style block comment /* */')
      else cursor++;  char = text[cursor]; column++

  leftRegexp = ->
    while char
      if char=='\\'
        if (c2=text[cursor+1]=='/') or c2=='\\' then cursor += 2; char = text[cursor]; column += 2
        else char = text[cursor++]; column++
      else if char=='\n' or char=='\r'
        error 'meet unexpected new line while parsing regular expression'
      else if char=='/'
        i = 0; cursor++; column++
        # console.log text.slice(cursor)
        while char
          if char=='i' or char=='g'or char=='m' then char = text[++cursor]; column++; ++i
          else break
        if i>3 then 'too many modifiers after regexp'
        break
      else char = text[++cursor]; column++
    if not char then error 'unexpected end of input while parsing regexp'

  # back slash \ can be used to escape keyword, conjunction, symbol
  tokenFnMap['\\'] = tokenOnBackSlashChar = ->
    char = text[++cursor]; column++
    if char=='\n' or char=='\r'
      concatline
    else if firstIdentifierCharSet[char]
      tokenOnIdentifierChar()
      token.escaped = true
    else if firstSymbolCharset[char]
      tokenOnSymbolChar()
      token.escaped = true
    else if char==':'
      tokenOnColonChar()
      token.escaped = true
    else if char=='@'
      tokenOnAtChar()
      token.escaped = true
    else if char=='.'
      tokenOnDotChar()
      token.escaped = true
    else if char=="'"
      tokenOnSingleQuoteChar()
      token.escaped = true
    # don't permit escape interpolated string
    # else if char=='"'
    else char = text[--cursor]; column--; repeatedCharToken()

  tokenFnMap['/'] = tokenOnForwardSlashChar = ->
    # // start a line comment
    cur = cursor; char = text[++cursor]; ind = indent
    if char=='/' # // leading line comment
      # skip line tail
      cursor++; char=text[cursor]
      while char and char!='\n' and char!='\r' then cursor++; char=text[cursor]
      skipSpaceLines(indent)
      if indent>ind then t = INDENT
      else if indent==ind then t = NEWLINE
      else t = UNDENT
      return {type: t, value: text[cur...cursor]}
    # /* start a c style block comment
    else if char=='*'
      leftCBlockComment()
      skipInlineSpace()
      if not char then t = EOI
      else if char=='\n' or char=='\r'
        skipSpaceLines(ind)
        if indent>ind then t = INDENT
        else if indent==ind then t = NEWLINE
        else t = UNDENT
      else t = SPACE
      return chainToken {type: t, value: text[cur...cursor]}
    # /! start a regexp
    else if char=='!'
      cur = cursor; cursor += 2; char = text[cursor]; col = column; column += 2
      leftRegexp()
      return chainToken {type:REGEXP, value:['regexp!', '/'+text[cur+1...cursor]]
      cursor:cur, stopCursor:cursor, line:lineno, column: col}
    else if char=='.' # block comment /. multiple indented lines
      # block comment should never be generated at match_here
      # how to assure it?
      # when starting parsing the module body, use tokenOnSpaceChar to generate the first token
      # and then, only parse /. as indented block
      # but with global variable atLineHead, we do defensive style coding and simplify the design
      if atLineHead
        char = text[++cursor]
        leftIndentBlockComment(ind)
        skipSpaceLines(ind)
        if indent>ind then t = INDENT
        else if indent==ind then t = NEWLINE
        else t = UNDENT
        return {type: t, value: text[cur...cursor]}
      else
        # "/" return as independent symbol, left "." will be processed later, it and following "." maybe will become a symbol too.
        # a possible legal syntax is that "/" is used as a suffix operator and "." or ".." or "..." are used as a binary operator.
        # e.g. a/...b
        return {type: SYMBOL, value:"/", cursor: cur, line:line, indent:ind}
    # / which is at the head of one line should start a code block comment
    # which should be processed when meeting new line
    else return {type: CODE_BLOCK_COMMENT_LEAD_SYMBOL, value:"/", cursor:cur, line:line, column:col, indent:ind}

  # the token leaded by '\n', '\r', maybe return token with type NEWLINE, INDENT, UNDENT, EOI
  tokenFnMap['\n'] = tokenFnMap['\r'] = tokenOnNewlineChar = ->
    cur = cursor; line = lineno; col = column; ind = indent
    char = text[cursor+1]
    if char=='\n' or char=='\r' then cursor += 2 else cursor++
    char = text[cursor]
    skipSpaceLines(ind)
    if not char then type = EOI
    else if indent>ind then type = INDENT
    else if indent==ind then type==NEWLINE
    else type = UNDENT
    return chainToken {type:type, value:text[cur...cursor],
    cursor:cur, # stopCursor: cursor,
    line:line, stopLine: lineno,
    column:col, # stopColumn: column,
    indent: ind, stopIndent: indent}

  tokenOnIdentifierChar = ->
    cur = cursor; char = text[++cursor]; col = column
    while char and identifierCharSet[char] then char=text[++cursor]
    txt=text.slice(cur, cursor); column += cursor-cur
    if keywordHasOwnProperty(txt) then type = KEYWORD
    else if conjunctionHasOwnProperty(txt) then type = CONJUNCTION
    else type = IDENTIFIER
    chainToken {type:type, value:txt
    cursor:cur, #stopCursor: cursor,
    line: lineno, column: col, indent:indent}

  for c of firstIdentifierCharSet then tokenFnMap[c] = tokenOnIdentifierChar

  tokenOnNumberChar = ->
    cur = cursor; col = column; base = 10
    if char=='0' and c2 = text[cursor+1]
      if c2=='b' or c2=='B' then base = 2; baseStart = cursor += 2; char = text[cursor]
      else if c2=='x' or c2=='X' then base = 16; baseStart = cursor += 2; char = text[cursor]
      else char = text[++cursor]; meetDigit = true
    if base==2
      while char
        if char=='0' or char=='1' then char = text[++cursor]
        else break
    else if base==16
      while char
        if  not('0'<=char<='9' or 'a'<=char<='f' or 'A'<=char<='F') then break
        else char = text[++cursor]
    if base==2
      if char=='.' or char=='e' or char=='E' then error 'binary number followed by ".eE"'
      else if '2'<=char<='9' then error 'binary number followed by 2-9'
    if base==16
      if char=='.' then error 'hexadecimal number followed by "."'
      else if letterCharSet[char] then error 'hexadecimal number followed by g-z or G-Z'
    if base!=10
      if cursor==baseStart
        # e.g 0x+3, 0x(1+2)
        cursor--; char = text[cursor]; column += cursor-cur
        return chainToken { type: NUMBER, value: text[cur...cursor], value:0,
        cursor:cur, line:lineno, column:col, indent:indent}
      else
        return chainToken { type: NUMBER, value:parseInt(text[baseStart...cursor], base),
        cursor:cur, line:lineno, column: col, indent:indent}
    # base==10
    while char
      if '0'<=char<='9' then meetDigit = true; char = text[++cursor]
      else break
    # if not meetDigit then return symbol() # comment because in no matchToken solution
    if not meetDigit then return
    if char=='.'
      meetDigit = false
      char = text[++cursor]
      while char
        if char<'0' or '9'<char then break
        else meetDigit = true; char = text[++cursor]
    dotCursor = cursor-1
    if not meetDigit and char!='e' and char!='E'
      cursor = dotCursor; char = text[cursor]; column += cursor-cur
      return chainToken { type: NUMBER, value:parseInt(text[baseStart...cursor], base),
      cursor:cur, line:lineno, column: col, indent:indent}
    if char=='e' or char=='E'
      char = text[++cursor]
      if char=='+' or char=='-'
        char = text[++cursor]
        if not char or char<'0' or '9'<char
          cursor = dotCursor; char = text[cursor]; column += cursor-cur
          return chainToken { type: NUMBER, value:parseInt(text[cur...dotCursor], base),
          cursor:cur, line:lineno, column: col, indent:indent}
        else
          while char
            char = text[++cursor]
            if  char<'0' or '9'<char then break
      else if not char or char<'0' or '9'<char
        cursor = dotCursor; char = text[cursor]; column += cursor-cur
        return chainToken { type: NUMBER, value:parseInt(text[cur...dotCursor], base),
        cursor:cur, line:lineno, column: col, indent:indent}
      else while char
          if  char<'0' or '9'<char then break
          char = text[++cursor]
    column += cursor-cur
    chainToken { type: NUMBER, value:parseFloat(text[cur...cursor], base),
    cursor:cur, line:lineno, column: col, indent:indent}


  for c in '0123456789' then tokenFnMap[c] = tokenOnNumberChar

  tokenFnMap[','] = tokenFnMap[';'] = tokenOnPunctuationChar = ->
    {value:char, type:PUNCTUATION, lineno:lexLineno, cursor:cursor, length:1, col: lexCol}

  # whether new line character is immediately following a concatenating character '\'
  # this is not affected embedded concatenated line in other structure.
  concatenating = false

  tokenFnMap["'"] = tokenOnSingleQuoteChar = ->
    char = text[++cursor]; column++
    if char=="'"
      if text[cursor+1]=="'"
        cursor += 2; char = text[cursor]; column += 2
        return chainToken leftRawNonInterpolatedString()
      else
        char = text[++cursor]; column++
        return chainToken {value:'""', type:NON_INTERPOLATE_STRING, cursor:cursor-2, line:lineno, column: column-2}
    else return chainToken leftNonInterpolatedString()

  leftRawNonInterpolatedString = ->
    cur = cursor-3; line = lineno
    if cursor==indent+3 then indentInfo = {indent:indent}
    else indentInfo = {}
    str = ''
    # the left characters of the same line after '''
    while char
      if char=="'" and text[cursor+1]=="'" and text[cursor+2]=="'"
        cursor += 3; char = text[cursor]
        return {type:NON_INTERPOLATE_STRING, value:'"'+str+'"', start:cur, stop:cursor, line:line, stopLine: lineno}
      else if char=='\\'
        # the '\' at end of line will not in the result string
        if (c=text[cursor+1])=='\n' or c=='\r'
          char = text[++cursor]; concatenating = true; break
        else str += '\\\\'; char = text[++cursor]; column++
      else if char!='\n' and char!='\r' then str += char; char = text[++cursor]; column++
      else break
    while char
      if char=="'" and text[cursor+1]=="'" and text[cursor+2]=="'"
        cursor += 3; char = text[cursor]
        return {type: NON_INTERPOLATE_STRING, value: '"'+str+'"', start:cur, stop:cursor, line:line, stopLine: lineno}
      str += rawNonInterpolatedStringLine(indentInfo)
    if not text[cursor] then error 'expect '+quote+', unexpected end of input while parsing interpolated string'

  rawNonInterpolatedStringLine = (indentInfo) ->
    result = ''
    # new line character must be escaped.
    if char=='\n'
      if not concatenating then result += '\\n'
      char = text[++cursor]
      if char=='\r'
        if not concatenating then result += '\\r'
        char = text[++cursor]
    else
      if not concatenating then result += '\\r'
      char = text[++cursor]
      if char=='\n'
        if not concatenating then result += '\\n'
        char = text[++cursor]
    concatenating = false
    lineno++; column = 0; cur = cursor
    while char==' ' then char = text[++cursor]; column++
    if char=='\t' then error 'unexpected tab character "\t" at the head of line'
    else if char=='\n' or char=='\r' then result += text[cur...cursor]; return result
    else if (ind=indentInfo.value)!=undefined then indentInfo.value = column
    else if ind>column then i = 0; n = column-ind; while i++<n then result += ' '
    else if ind<column then error 'expect equal to or more than the indent of first line of the string'
    while char
      if char=="'" and text[cursor+1]=="'" and text[cursor+2]=="'" then return result
      else if char=='\n' or char=='\r' then return result
      else if char=='\\'
        char = text[++cursor]
        if char=='\n' or char=='\r' then return result
        if char then result += '\\\\'; result += char; char = text[++cursor]; column += 2
        else error 'unexpected end of input while parsing non interpolated string'
      # '"' must be escaped, because all the string is wrapped in "..."
      else if char=='"'  then result += '\\"'; char = text[++cursor]; column++
      else result += char; char = text[++cursor]; column++
    error 'unexpected end of input while parsing non interpolated string'

  leftNonInterpolatedString = ->
    cur = cursor-1; line = lineno; col = column-1
    if cursor=indent+1 then indentInfo = {value:indent}
    else indentInfo = {}
    str = ''
    # the left characters of the same line after '''
    while char
      if char=="'"
        char = text[++cursor]; column++
        return {type: NON_INTERPOLATE_STRING, value: '"'+str+'"', start:cur, stop:cursor, line:line, stopLine: line, column: col}
      else if char=='\\'
        # the '\' at end of line will not in the result string
        if (c=text[cursor+1])=='\n' or c=='\r' then char = text[++cursor]; concatenating = true; break
        else if c=="'" then str += "'"; cursor += 2; char = text[cursor]; column += 2
        else str += '\\'; char = text[++cursor]; column++
      else if char!='\n' and char!='\r' then str += char; char = text[++cursor]; column++
      else break
    while char
      if char=="'"
        char = text[++cursor]; column++
        return {type: NON_INTERPOLATE_STRING, value: '"'+str+'"', start:cur, stop:cursor, line:line, stopLine: lineno, column: col}
      str += nonInterpolatedStringLine(indentInfo)
    if not char then error 'expect '+quote+', unexpected end of input while parsing interpolated string'

  nonInterpolatedStringLine = (indentInfo) ->
    result = ''
    if char=='\n'
      if not concatenating then result += '\\n'
      char = text[++cursor]
      if char=='\r'
        result += '\\r'
        char = text[++cursor]
    else
      if not concatenating then result += '\r'
      char = text[++cursor]
      if char=='\\n'
        if not concatenating then result += '\\n'
        char = text[++cursor]
    concatenating = false
    lineno++; column = 0; cur = cursor
    while char==' ' then char = text[++cursor]; column++
    if char=='\t' then error 'unexpected tab character "\t" at the head of line'
    else if char=='\n' or char=='\r' then result += text[cur...cursor]; return result
    else if (ind=indentInfo.value)!=undefined then indentInfo.value = column
    else if ind>column then i = 0; n = column-ind; while i++<n then result += ' '
    else if ind<column then error 'expect equal to or more than the indent of first line of the string'
    while char
      if char=="'" then return result
      else if char=='\n' or char=='\r' then return result
      else if char=='\\'
        char = text[++cursor]
        # '\' at the end of line is omitted
        if char=='\n' or char=='\r' then return result
        else if char=="'" then result += "'"; char = text[++cursor]; column++
        else if char then result += '\\'; result += char; char = text[++cursor]; column += 2
        else error 'unexpected end of input while parsing non interpolated string'
      else if char=='"'  then result += '\\"'; char = text[++cursor]; column++
      else result += char; char = text[++cursor]; column++
    error 'unexpected end of input while parsing non interpolated string'

  tokenFnMap['"'] = tokenOnDoubleQuoteChar = ->
    char = text[++cursor]; column++
    if char=='"'
      if [cursor+1]=='"'
        cursor += 2; char = text[cursor]; column += 2
        return chainToken leftRawInterpolateString()
      else
        char = text[++cursor]; column++
        return chainToken {value:'""', type:NON_INTERPOLATE_STRING, lineno:lineno, cursor:cursor-2, column:column-2}
    else return chainToken leftInterpolatedString()

  @leftRawInterpolatedString = leftRawInterpolatedString = ->
    cur = cursor; line = lineno
    if column==indent+3 then indentInfo = {value:indent} else indentInfo = {}
    pieces = []
    while char
      if char=='"' and text[cursor+1]=='"' and text[cursor+2]=='"'
        cursor += 3; column += 3
        return {type: INTERPOLATE_STRING, value: ['string!'].concat(pieces),
        cursor:cur, stopCursor: cursor,
        line:line, stopLineno: line}
      else if char=='$'
        literalStart = cursor++
        x = parser.interpolateExpression()
        if x
          x = getOperatorExpression x
          if text[cursor]==':'
            char = text[++cursor]
            pieces.push text[literalStart...cursor]
          pieces.push x
        else pieces.push '"$"'
      else if char=='(' or char=='{' or char=='['
        # for efficiency, do not match next token while matching delimiter token (...), [...], {...} in tokenOnLeftParenChar, tokenOnLeftBracketChar, tokenOnLeftCurveChar
        matchToken()
        pieces.push getOperatorExpression(token)
      else pieces.push rawInterpolateStringPiece(indentInfo)
    if not text[cursor] then error 'expect '+quote+', unexpected end of input while parsing interpolated string'

  rawInterpolateStringPiece = (indentInfo) ->
    str = '"'
    while char
      if char=='"'
        if text[cursor+1]=='"'
          if text[cursor+2]=='"' then return str+'"'
          else cursor += 2; column += 2; char = text[cursor]
      else if char=='\n'
        if not concatenating then str += '\\n'
        char = text[++cursor]
        if char=='\r'
          if not concatenating then str += '\\r'
          char = text[++cursor]
        concatenating = false
        while 1
          lineno++; column = 0
          while char==' ' then str += char; char = text[++cursor]; column++
          if char=='\n'
            str += '\\n'; char = text[++cursor]
            if char=='\r' then str += '\\r'; char = text[++cursor]
            continue
          else if char=='\r'
            str += '\\r'; char = text[++cursor]
            if char=='\n' then str += '\\n'; char = text[++cursor]
            continue
          else break
        if char=='\t' then error 'unexpected tab character "\t" in the head of line'
        else if (ind=indentInfo.value)!=undefined then indentInfo.value = column
        else if ind>column then i = 0; n = column-ind; while i++<n then result += ' '
        else if ind<column then error 'expect equal to or more than the indent of first line of the string'
      else if char=='\r'
        if not concatenating then str += '\\r'
        char = text[++cursor]
        if char=='\n'
          if not concatenating then str += '\\n'
          char = text[++cursor]
        concatenating = false
        while 1
          lineno++; column = 0
          while char==' ' then str += char; char = text[++cursor]; column++
          if char=='\n'
            str += '\\n'; char = text[++cursor]
            if char=='\r' then str += '\\r'; char = text[++cursor]
            continue
          else if char=='\r'
            str += '\\r'; char = text[++cursor]
            if char=='\n' then str += '\\n'; char = text[++cursor]
            continue
          else break
        if char=='\t' then error 'unexpected tab character "\t" in the head of line'
        else if (ind=indentInfo.value)!=undefined then indentInfo.value = column
        else if ind>column then i = 0; n = column-ind; while i++<n then result += ' '
        else if ind<column then error 'expect equal to or more than the indent of first line of the string'
      else if char=='(' or char=='{' or char=='[' then return str+'"'
      else if  char=='$' then return str+'"'
      else if char=='\\'
        if not (c2=text[cursor+1]) then error 'unexpected end of input while parsing interpolated string'
        else if c2=='\n' or c2=='\r' then cursor++ #; str += '\\'
        else cursor += 2; char += text[cursor]; column += 2; str += '\\'+c2
      else str += char; char = text[++cursor]; column++
    error 'unexpected end of input while parsing interpolated string'

  leftInterpolatedString = ->
    cur = cursor-1; line = lineno
    if column==indent+1 then indentInfo = {value:indent} else indentInfo = {}
    pieces = []
    while char
      if char=='"'
        char = text[++cursor]; column++
        return {type: INTERPOLATE_STRING, value: ['string!'].concat(pieces),
        cursor:cur, stopCursor:cursor,
        line:line, stopLine: lineno}
      if char=='$'
        literalStart = ++cursor; char = text[cursor]; column++
        x = parser.interpolateExpression()
        if x
          x = getOperatorExpression x
          # a = 1; "$a:" will be "a:1"
          if text[cursor]==':'
            cursor++
            pieces.push text[literalStart...cursor]
          pieces.push x
        else pieces.push '"$"'
      else if char=='(' or char=='{' or char=='['
        # for efficiency, do not match next token while matching delimiter token (...), [...], {...} in tokenOnLeftParenChar, tokenOnLeftBracketChar, tokenOnLeftCurveChar
        matchToken()
        pieces.push getOperatorExpression(token)
      else pieces.push interpolateStringPiece(indentInfo)
    if not text[cursor] then error 'expect '+quote+', unexpected end of input while parsing interpolated string'

  interpolateStringPiece = (indentInfo) ->
    str = '"'
    while char
      if char=='"' then return str+'"'
      else if char=='\n'
        if not concatenating then str += char
        char = text[++cursor]
        if char=='\r'
          if not concatenating then str += char
          char = text[++cursor]
        concatenating = false
        while 1
          lineno++; column = 0
          while char==' ' then str += char; char = text[++cursor]; column++
          if char=='\n'
            str += char; char = text[++cursor]
            if char=='\r' then str += char; char = text[++cursor]
            continue
          else if char=='\r'
            str += char; char = text[++cursor]
            if char=='\n' then str += char; char = text[++cursor]
            continue
          else break
        if char=='\t' then error 'unexpected tab character "\t" in the head of line'
        else if (ind=indentInfo.value)!=undefined then indentInfo.value = column
        else if ind>column then i = 0; n = column-ind; while i++<n then result += ' '
        else if ind<column then error 'expect equal to or more than the indent of first line of the string'
      else if char=='\r'
        if not concatenating then str += char
        char = text[++cursor]
        if char=='\n'
          if not concatenating then str += char
          char = text[++cursor]
        concatenating = false
        while 1
          lineno++; column = 0
          while char==' ' then str += char; char = text[++cursor]; column++
          if char=='\n'
            str += char; char = text[++cursor]
            if char=='\r' then str += char; char = text[++cursor]
            continue
          else if char=='\r'
            str += char; char = text[++cursor]
            if char=='\n' then str += char; char = text[++cursor]
            continue
          else break
        if char=='\t' then error 'unexpected tab character "\t" in the head of line'
        else if (ind=indentInfo.value)!=undefined then indentInfo.value = column
        else if ind>column then i = 0; n = column-ind; while i++<n then result += ' '
        else if ind<column then error 'expect equal to or more than the indent of first line of the string'
      # interpolate expression in string
      else if char=='(' or char=='{' or char=='[' or char=='$' then return str+'"'
      else if char=='\\'
        if not (c2=text[cursor+1]) then break
        else if c2=='\n' or c2=='\r' then char = text[++cursor]
        else cursor += 2; column += 2; str += '\\'+c2
      else str += char; char = text[++cursor]; column++
    error 'unexpected end of input while parsing interpolated string'

  # for efficiency, in tokenOnLeftParenChar, tokenOnLeftBracketChar, tokenOnLeftCurveChar
  # do not match next token while matching delimiter token (...), [...], {...}
  tokenFnMap['('] = tokenOnLeftParenChar = ->
    # skip "("
    cur = cursor; line = lineno; col = column; char = text[++cursor]; column++; ind = indent
    start = token; matchToken()
    if (parenVariantFn=parenVariantMap[token.value]) then return parenVariantFn()
    if (type=token.type)==UNDENT then error 'unexpected undent while parsing parenethis "(...)"'
    else if type==SPACE or type==NEWLINE or type==INDENT then matchToken()
    exp = parser.operatorExpression()
    if (type=token.type)==UNDENT
      if token.stopIndent<ind then error 'expect ) indent equal to or more than ('
      else matchToken()
    else if token.value!=')' then error 'expect )'
    #else matchToken() # do not match token here, so token.next==undefined, and nextToken() will matchToken instead.
    token = {type: PAREN, value:exp, cursor:cur, stopCursor: cursor, line:lineno, stopLine: lineno, column:col}
    start.next = token
    token

  parenVariantMap = {
  }

  tokenFnMap['['] = tokenOnLeftBracketChar = ->
    cur = cursor; cursor++; line = lineno; col = column; column++; ind = indent; start = token; matchToken()
    if (bracketVariantFn=bracketVariantMap[token.value]) then return bracketVariantFn()
    if token.value!='[' then return
    matchToken()
    expList = parser.lineBlock()
    bigSpace()
    if (type=token.type)==UNDENT
      if token.indent<ind then error 'unexpected undent while parsing parenethis "[...]"'
      else nextToken()
    if token.value!=']' then error 'expect ]'
    if expList then expList.unshift 'list!'
    else expList = []
    token = {type: BRACKET, value:expList, cursor:cur, stopCursor: cursor, line:lineno, stopLine: lineno, column:col}
    start.next = token
    token

  bracketVariantMap = {}

  tokenFnMap['{'] = ->
    cur = cursor; cursor++; line = lineno; col = column; column++; ind = indent; start = token; matchToken()
    if (curveVariantFn=curveVariantFnMap[token.value]) then return curveVariantFn()
    if token.value=='}'
      matchToken();
      token = {value:text[cur...cursor], value:['hash!'], cursor:cur, line:line, column:col}
      start.next = token
      return start
    body = parser.lineBlock()
    if token.indent<ind then error 'unexpected undent while parsing parenethis "{...}"'
    if token.value!='}' then error 'expect }' else cursor++
    if body.length==0 then return {type: CURVE, value:'', start:cur, stop: token}
    if body.length==1 then body = body[0]
    else body.unshift 'begin!'
    extend body, {type: CURVE, start:start, stop: cursor, line1:line1, line:lineno}

  curveVariantMap =
    '.': ->  matchToken(); return hash()

  @hash = memo ->
    cur = cursor; line1 = lineno; indentCol = lineInfo[lineno].indentCol
    if text[cursor...cursor+2]!='{.' then return else cursor += 2
    items = parser.hashBlock()
    if lineInfo[lineno].indentCol<indentCol then error 'unexpected undent while parsing parenethis "{.  ... .}"'
    if text[cursor...cursor+2]!='.}' then error 'expect .}' else cursor += 2
    wrapResult ['hash!'].concat(items), {start:cur, stop:cursor, line1:line1, line:lineno}

  @hashBlock = memo ->
    cur = cursor; line1 = lineno; column1 = lineInfo[lineno].indentCol
    if (spac=bigSpace()) and spac.undent then return
    result = []; if spac.indent then indentCol = lineInfo[lineno].indentCol
    while (x=parser.hashItem()) and result.push x
      space()
      if not (c=text[cursor]) then break
      if c=='.'
        if text[cursor+1]=='}' then break
        else error 'unexpected ".", expect .} to close hash block'
      if c==';' then cursor++
      space2 = bigSpace()
      if not (c=text[cursor]) or c=='}' then break
      if lineno==line1 then continue
      if (col=lineInfo[lineno].indentCol)>column1
        if indentCol and col!=indentCol then error 'unconsistent indent in hash {. .}'
        else indentCol = col
      else if col==column1 then break
      else if col<column1 then rollbackToken space2; return
    result.start = cur; result.stop = cursor; result

  @hashItem = memo ->
    if isIndent(token) then error 'unexpected indent'
    else if isUndent(token) then return
    if key=parser.compactClauseExpression()
      if isMultiline(token) then error 'unexpected new line after hash key'
      if token.value==':' and matchToken()
        if (t=key.type)==IDENTIFIER or t==NUMBER or t==NON_INTERPOLATE_STRING then js = true
      else if text[cursor...cursor+2]=='=>' then cursor+=2
      else error 'expect : or => for hash item definition'
      if (spac=follow('spaceComment')) and spac.indent
        value = ['hash!'].concat parser.hashBlock()
      else value = parser.clause()
      if not value then error 'expect value of hash item'
      if js then result = ['jshashitem!', getOperatorExpression(key), value]
      else result = ['pyhashitem!', getOperatorExpression(key), value]
      wrapResult result, {start:cur, stop:cursor, line1:line1, line:lineno}

  tokenOnRightDelimiterChar = ->

  for c in ')]}' then tokenFnMap[c] = tokenOnRightDelimiterChar

  @followMatch = followMatch = (fn) ->
    cur = cursor; line = lineno
    x = fn()
    cursor = cur; lineno = line
    x

  @follow = follow = (matcherName) ->
    cur = cursor; line = lineno
    x = parser[matcherName]()
    cursor = cur; lineno = line
    x

  @expect = expect = (matcherName, message) ->
    if not (x = parser[matcherName]()) then error message
    else x

  @followSequence = followSequence = (matcherList...) ->
    cur = cursor; line1 = lineno
    for matcherName in  matcherList
      if not (x=parser[matcherName]()) then break
    cursor = cur; lineno = line1
    x

  @followOneOf = (matcherList...) ->
    cur = cursor; line1 = lineno
    for matcherName in  matcherList
      cursor = cur; lineno = line1 # defensive coding style
      if x =  parser[matcherName]() then break
    cursor = cur; lineno = line1
    x

  @setText = (x) -> parser.text = text = x; x
  @cursor = -> cursor
  @setCursor = (x) -> cursor = x
  @atStatementHead = -> atStatementHead
  @setAtStatementHead = (x) -> atStatementHead = x
  @endOfInput = -> not text[cursor]

  @literal = literal = (string) ->
    length = string.length
    if text[cursor...cursor+length]==string then cursor += length; true

  wrapResult = (result, info) -> result.info = info; result

  @decimal = decimal = memo ->
    cur = cursor
    while c = text[cursor] then (if  '0'<=c<='9' then cursor++ else break)
    if cursor==cur then return
    {value: text[cur...cursor], cursor:cur}

  @delimiterExpression = memo -> parser.paren() or parser.dataBracket() or parser.bracket() or parser.curve() or parser.hash()

  @escapeSymbol = escapeSymbol = ->
    cur = cursor; line1 = lineno
    if text[cursor]!='\\' then return
    cursor++; sym = parser.symbol()
    if not sym then return rollback(cur, line1)
    else sym.start = cur; sym.escape = true; return sym

  @escapeStringSymbol = ->
    if token.value!="\\" then return
    matchToken()
    if token.type!=NON_INTERPOLATED_STRING then return
    if isMultipleLines(token) then rollback cur
    matchToken()
    wrapResult ['symbol!', token], {type: SYMBOL, escape: true, start:cur, stop:token}

  @delimiterCharset = charset('|\\//:')

  @rightDelimiter = (delimiter) ->
    cur = cursor
    if text[cursor...cursor+2]=='.}' then cursor += 2; return '.}'
    while (c=text[cursor]) and parser.delimiterCharset[c] then cursor++
    if c!=')' and c!=']' and c!='}' then cursor = cur; return  # and c!='>'
    cursor++
    if delimiter
      if text[cur...cursor]!=delimiter then cursor = cur; return
      else delimiter
    else text[cur...cursor]

  @symbolOrIdentifier = -> parser.symbol() or parser.identifier()
  atomTokenTypes = dict(IDENTIFIER,1,  NUMBER,1,  REGEXP,1,  CURVE,1,  HASH,1,  BRACKET,1,  PAREN,1,  SYMBOL,1)
  @atom = (mode) ->
    if atomTokenTypes[token.type]
      atomToken = token; nextToken(); atomToken.priority = 1000;
      return atomToken

  # prefix operator don't need to be compared to current global priority
  @prefixOperator = (mode) ->
    # hasOwnProperty.call is necessary in order to avoid error while builtin attribute of object is defined prefix operator
    tokenText = token.value
    if not hasOwnProperty.call(prefixOperatorDict, tokenText) or  not (op=prefixOperatorDict[tokenText]) then return
    if token.escaped then return
    opToken = token; matchToken()
    if tokenText=='.'
      matchToken()
      if (type=token.type)==SPACE or type==INDENT or type==UNDENT or type==NEWLINE
        if mode==OPERATOR_EXPRESSION then error 'unexpected spaces after :'
        else token = opToken; return
    else if (type=token.type)==INDENT then error 'unexpected indent after prefix operator'
    else if type==NEWLINE then error 'unexpected new line after prefix operator'
    else if type==UNDENT then error 'unexpected undent after prefix operator'
    else if (tokenText=token.value)==")" or tokenText==']' or tokenText=="}" then error 'unexpected '+tokenText+' after prefix operator'
    else if type==SPACE then matchToken(); priInc = 300
    else priInc = 600
    opToken.symbol = op.symbol; opToken.priority = op.priority+priInc
    wrapResult opToken, {start:opToken, token}

  canFollowSuffix = ->
    if (type=token.type)==SPACE or type==INDENT or type==UNDENT or type==NEWLINE or type==SYMBOL or type==EOI then return true
    if (value=token.value)==')' or value==']' or value=='}' or value==':' or value==',' or value==';' then return true
    if type==IDENTIFIER then return false

  # suffix operator must be symbol, should follow space, right delimiters or punctuations.
  @suffixOperator = (mode, x) ->
    if token.type!=SYMBOL then return
    if (op=suffixOperatorDict[token.value])
      token.symbol = op.symbol; token.priority = op.priority+600
      opToken = token; matchToken()
      if canFollowSuffix() then return wrapResult opToken, {start: opToken}
      else token = opToken; return

  canFollowSufix = () -> (t=token.type)==SPACE or t==RIGHT_DELIMITER or t==PUNCTUATION or t==EOI

  parser.clauseEnd = (spac) ->
    cur = cursor; line1 = lineno
    spac = spac or bigSpace()
    if (c=text[cursor])==','
      if not spac.inline then error '"," should not be at the head of a line'
      cursor++; return true
    if parser.sentenceEnd(spac) or c==';' then  rollbackToken spac; return true

  parser.expressionEnd = (mode, spac) ->
    if (not parser.isClauseExpression(mode)) then return
    (c=text[cursor])==':' and text[cursor+1]!=':'  or parser.clauseEnd(spac)\
    or (mode=='comClExp' and spac.text) or (mode=='inStrExp' and (c=="'" or c=='"'))

  parser.isClauseExpression = (mode) -> mode=='comClExp' or mode=='spClExp' or mode=='inStrExp'

  binaryOperatorMemoIndex = memoIndex
  memoIndex += 4

  @binaryOperator = (mode, x) ->
    if m=token[binaryOperatorMemoIndex+mode] then token = m.next; return m.result
    if token.type==EOI then return
    op = binaryDictOperator(mode, x) or parser.customBinaryOperator(mode, x)
    token[binaryOperatorMemoIndex+mode] = {result:op, next:token}
    return op

  binaryDictOperator = (mode, x) ->
    start = token
    if (type1=token.type)==SPACE
      if mode==COMPACT_CLAUSE_EXPRESSION or mode==INTERPOLATE_EXPRESSION then return
      priInc = 300; matchToken()
    else if type1==NEWLINE or type1==INDENT or type1==UNDENT
      if mode!=OPERATOR_EXPRESSION then return
      priInc = 0; matchToken()
    else priInc = 600; if token.value=='.' then matchToken()
    opValue = token.value
    if not hasOwnProperty.call(binaryOperatorDict, opValue) or not (op=binaryOperatorDict[opValue])
      token = start; return
    opToken = token; matchToken()
    txt2 = token.value
    if txt2=='.'
      if priInc==600 then error 'unexpected "." after binary operator '+opToken.text+', here should be spaces, comment or newline'
      else
        # assure token is not identifier while parsing custom binary attribute operator
        matchToken()
    if parser.expressionEnd(mode) then token = start; return
    if (type=token.type)==UNDENT then error 'unexpected undent after binary operator "'+opToken.text+'"'
    else if type==EOI then error 'unexpected end of input, expect right operand after binary operator'
    else if token.type==RIGHT_DELIMITER then return
    if priInc==600
      if type==SPACE
        if op.text==',' then priInc = 300
        else if (c=text[cursor])==';' then error 'unexpected ;'
        else error 'unexpected spaces or new lines after binary operator "'+op.text+'" before which there is no space.'
      pri = op.priority+priInc
      extend {}, op, {priority: pri}
    else if priInc==300
      if type==UNDENT then error 'unexpceted undent after binary operator '+op.text
      else if type==NEWLINE then priInc = 0
      else if type==INDENT then priInc = 0; indentExpression()
      else if type!=SPACE
        if mode==OPERATOR_EXPRESSION then error 'binary operator '+op.text+' should have spaces at its right side.'
        else token = start
      pri = op.priority+priInc
      extend {priority: pri}, op
      # below must in operator expression (...) mode, not in clause mode.
    else
      # any operator near newline always have the priority 300, i.e. compute from up to down
      if opValue==',' or opValue==':' or opValue=='%'  or op.assign
        error 'binary operator '+op.symbol+' should not be at begin of line'
      if type==UNDENT then error 'binary operator should not be at end of block'
      else if type==NEWLINE then error 'a single binary operator should not occupy whole line.'
      if type1==INDENT # the token before operator token is indent token
        priInc = 0; indentExpression()
      extend {priority: 300}, op

  indentExpression = ->
    indentStart = token
    indentExp = parser.recursiveExpression(mode, 0, true)
    tkn = matchToken()
    if (type=tkn.type)!=UNDENT and type!=EOI and type.text!=')'
      error 'expect an undent after a indented block expression'
    indentExp.priority = 1000
    matchToken()
    token = indentStart

  @followParenArguments = -> # use the private paren
    start = cursor; line1 = lineno
    x=paren()
    #always rollback, because just followParenArguments
    rollback start, line1; return  x

  @binaryCallOperator = (mode, x) ->
    if token.type==PAREN
      {symbol:'call()', type: SYMBOL, priority: 800, start:start}

  @binaryMacroCallOperator = (mode, x) ->
    if token.value!='#' then return
    start = token; nextToken()
    if token.type!=PAREN() then token = start; return
    return {symbol:'#()', type: SYMBOL, priority: 800, start:start}


  @binaryIndexOperator = (mode, x) ->
    if token.type==BRACKET
      {symbol:'index[]', type: SYMBOL, priority: 800, start:start}

  # a.b, fn(x, y).b
  @binaryAttributeOperator = (mode, x) ->
    if token.type==SPACE
      start = token; nextToken()
      if token.value!='.' then token = start; return
      nextToken()
      if token.type!=SPACE then error 'expect spaces after "." because there are spaces before it'
      return {symbol:'attribute!', type: SYMBOL, priority: 500}
    else if token.value=='.'
      nextToken()
      if token.type==SPACE then  error 'unexpected spaces after "." because there are no space before it'
      return {symbol:'attribute!', type: SYMBOL, priority: 800}

  # @attr, @[1], @['ads']
  @binaryAtThisAttributeIndexOperator = (mode, x) ->
    if x.stop!=token then return
    if follow('jsIdentifier')
      {symbol:'attribute!', type: SYMBOL, start: cursor, stop:cursor, line: lineno, priority: 800}
    else if follow 'bracket'
      {symbol:'index!', type: SYMBOL, start: cursor, stop:cursor, line: lineno, priority: 800}

  # @::, obj::, obj::y
  @binaryPrototypeAttributeOperator = (mode, x) ->
    if (x.type==IDENTIFIER or x.text=='@') and token.value=='::'
      {symbol:'attribute!', type: SYMBOL, start: cursor, stop:cursor, line: lineno, priority: 800}
    else if  (cur=token.cursor) and text[cur-3]!=':' and text[cur-2...cur]=='::'
      {symbol:'attribute!', type: SYMBOL, start: cursor, stop:cursor, line: lineno, priority: 800}

  @customBinaryOperators = [@binaryAttributeOperator, @binaryCallOperator, @binaryMacroCallOperator, @binaryIndexOperator,
                            @binaryAtThisAttributeIndexOperator, @binaryPrototypeAttributeOperator]

  @customBinaryOperator = (mode, x) ->
    for fn in parser.customBinaryOperators then if op = fn(mode, x)  then return op
    return

#  # any binary function can be used as binary exports, and the priority to be used actually is set here.
#  @binaryFunctionPriority = 35

  @prefixExpression = (mode, priority) ->
    start = token
    # current global prority doesn't affect prefixOperator
    if op=parser.prefixOperator(mode)
      pri = if priority>op.priority then priority else op.priority
      x = parser.recursiveExpression(mode, pri, true)
      if x then wrapResult makeOperatorExpression('prefix!', op, x), {start:start, stop:token}

  recursiveExpressionMemoIndex = memoIndex
  memoIndex += 4
  @recursiveExpression = recursive = (mode, priority, leftAssoc) ->
    if result=token[memoIndex+mode] then token = result.next; return result.value
    start = token; x = null
    expression = ->
      if not x
        if not x = parser.prefixExpression(mode, priority)
          if not x = parser.atom(mode) then start[memoIndex] = {value:null, next:token}; return
      if (op = parser.suffixOperator(mode, x)) and op.priority>=priority
        x = wrapResult makeOperatorExpression('suffix!', op, x), {start:start, stop:token}
        # the priority and association of suffix operator does not affect the following expression
      if (op=parser.binaryOperator(mode, x)) and ((leftAssoc and op.priority>priority) or (not leftAssoc and op.priority>=priority))
        # should assure that a right operand is here while parsing binary operator
        y = recursive(mode, op.priority, not op.rightAssoc)
        x = wrapResult makeOperatorExpression('binary!', op, x, y), {start:start, stop:token}
        return expression()
      start[memoIndex+mode] = {value:x, next:token}
      x
    expression()

  # the priority of operator vary from 0 to 300,
  # if there is no space between them, then add 600, if there is spaces, then add 300.
  # if meet newline, add 0.
  @operatorExpression = operatorExpression = -> parser.recursiveExpression(OPERATOR_EXPRESSION, 0, true)
  # compact expression as clause item.
  @compactClauseExpression = -> parser.recursiveExpression(COMPACT_CLAUSE_EXPRESSION, 600, true)
  # space expression as clause item.
  @spaceClauseExpression = spaceClauseExpression = -> parser.recursiveExpression(SPACE_CLAUSE_EXPRESSION, 300, true)
  # interpolate expression embedded in string
  @interpolateExpression = -> parser.recursiveExpression(INTERPOLATE_EXPRESSION, 600, true)

  @isIdentifier = isIdentifier = (item) -> item.type==IDENTIFIER

  @itemToParameter = itemToParameter = (item) ->
    if item.type==IDENTIFIER then return item
    else if item0=item[0]
      if item0=='attribute!' and item[1].text=='@' then return item
      else if item0.symbol=='x...'
        parser.meetEllipsis = item[1].ellipsis = true
        return item
      else if entity(item0)=='=' # default parameter
        # default parameter should not be ellipsis parameter at the same time
        # and this is the behavior in coffee-script too
        # and (item01[0].symbol!='x...' or not isIdentifier(item01[1]).type==IDENTIFIER)
        if (item1=item[1]) and item1.type==IDENTIFIER then return item
        else if ((item10=item1[0]) and item10=='attribute!' and item1[1].text=='@') then return item
        else return
      # for dynamic parser and writing macro
      else if item0.symbol=='unquote!' or item0.symbol=='unquote-splice'
        return item

  @toParameters = toParameters = (item) ->
    if not item then return []
    if x=itemToParameter(item) then return [x]
    else if item[0]==','
      result = for x in item[1...]
        if not(param=itemToParameter(x)) then meetError = true; break
        if param.ellipsis
          if meetEllipsis then meetError = true; break
          else meetEllipsis = true
        param
      if not meetError then result

  leadWordClauseMap =
    # eval while parsing, call by %% clause
    # e.g.
    # %% %text()
    # %% %cursor()
    # %% %number()1234
    '%%':  (clause) ->
      code = compileExp(['return', clause], environment)
      new Function('__$taiji_$_$parser__', code)(parser)

    # the head of clause will be convert to attribute of __$taiji_$_$parser__
    # see exports['%/'] and convertParserAttribute in core.coffee
    # {%/ matcheA(x, y) } will be converted to {%% %matchA(x, y)}
    '%/': (clause) ->
      # notice the difference between %% and %/
      # here ['%/', clause] is compiled
      code=compileExp(['return', ['%/', clause]], environment)
      new Function('__$taiji_$_$parser__', code)(parser)

    # identifier in clause will be convert to attribute of __$taiji_$_$parser__
    # see exports['%!'] and convertParserAttribute in core.coffee
    # {%! matcheA(x, y) } will be converted to {%% %matchA(%x, %y)}
    '%!': (clause) ->
      code=compileExp(['return', ['%!', clause]], environment)
      new Function('__$taiji_$_$parser__', code)(parser)

    '~':  (clause) -> ['quote!', clause]
    '`':  (clause) -> ['quasiquote!', clause]
    '^':  (clause) -> ['unquote!', clause]
    '^&': (clause) -> ['unquote-splice', clause]

    # preprocess opertator
    # see # see metaConvertFnMap['#'] and preprocessMetaConvertFnMap for more information
    '#':  (clause) -> ['#', clause]

    # evaluate in compile time
    # see metaConvertFnMap['##']
    '##':  (clause) -> ['##', clause]

    # evaluate in both compile time and run time
    # see metaConvertFnMap['#/']
    '#/': (clause) -> ['#/', clause]

    # escape from compile time to runtime
    # see metaConvertFnMap['#-']
    '#-': (clause) -> ['#/', clause]

    # #& metaConvert exp and get the current expression(not metaConverted raw program)
    # see metaConvertFnMap['#&']
    '#&': (clause) -> ['#&', clause]

  @leadWordClause = ->
    start = cursor; line1 = lineno
    if not (key = parser.symbol() or parser.identifier()) then return
    if (spac=space()) and (not spac.text or spac.undent) then return rollback start, line1
    if not (fn=leadWordClauseMap[key.text]) then return rollback start, line1
    clause = fn(parser.clause())
    if clause and typeof clause=='object'
      extend clause, {start:start, stop:cursor, line1:line1, line:lineno}
    else extend {value:clause}, {start:start, stop:cursor, line1:line1, line:lineno}

  @labelStatement = ->
    start = cursor; line1 = lineno
    if not (lbl=parser.jsIdentifier()) then return
    if text[cursor]!='#' then cursor = start; return
    cursor++
    if (spac=bigSpace()) and (not spac.text or spac.undent or spac.newline)  then cursor = start; return
    if clause=parser.clause() then clause = ['label!', lbl, clause]
    else clause = ['label!', lbl, '']
    extend clause, {start:start, stop:cursor, line1:line1, line:lineno}

  @conjunction = ->
    start = cursor
    if (x=symbol() or taijiIdentifier()) and isConj(x) then return x
    cursor = start; return

  @expectIndentConj = expectIndentConj = (word, line1, isHeadStatement, options, clauseFn) ->
    start2 = cursor; line2 = lineno
    if options.optionalClause? then optionalClause = options.optionalClause
    else optionalClause = word!='then'
    if options.optionalWord? then optionalWord = options.optionalWord
    else optionalWord = word=='then'
    indentCol = lineInfo[line1].indentCol
    spac = bigSpace(); col = lineInfo[lineno].indentCol
    if col==indentCol and lineno!=line1 and not isHeadStatement
      if not optionalClause
        error 'meet new line, expect inline keyword "'+word+'" for inline statement'
      else rollbackToken spac; return
    if col<indentCol
      if not optionalClause then error 'unexpected undent, expect '+word
      else rollbackToken spac; return
    else if col>indentCol
      if options.indentCol
        if col!=options.indentCol then error 'unconsistent indent'
      else options.indentCol = col
    w = taijiIdentifier()
    meetWord = w and w.text==word
    if not meetWord
      if isConj(w)
        if optionalClause then rollbackToken spac; return
        else  error 'unexpected '+w.text+', expect '+word+' clause'
      else if (not optionalWord and not optionalClause) or (
          not optionalClause and optionalWord and spac.inline)
        if word!='then' or not options.colonAtEndOfLine then error 'expect keyword '+word
      else if not optionalWord then return rollbackToken spac
      else if optionalClause then return rollbackToken spac
    if not meetWord then rollback start2, line2
    clauseFn()

  conjClause = (conj, line1, isHeadStatement, options) ->
    begin(expectIndentConj conj, line1, isHeadStatement, options, parser.lineBlock)

  thenClause  = (line1, isHeadStatement, options) -> conjClause 'then', line1, isHeadStatement, options
  elseClause  = (line1, isHeadStatement, options) -> conjClause 'else', line1, isHeadStatement, options
  finallyClause  = (line1, isHeadStatement, options) -> conjClause 'finally', line1, isHeadStatement, options
  catchClause = (line1, isHeadStatement, options) ->
    expectIndentConj 'catch', line1, isHeadStatement, options, ->
      line2 = lineno; space(); atStatementHead = false
      catchVar = parser.identifier(); space(); then_ = thenClause(line2, false, {})
      [catchVar, then_]

  caseClauseOfSwitchStatement = (line1, isHeadStatement, options) ->
    expectIndentConj 'case', line1, isHeadStatement, options, ->
      line2 = lineno; space(); atStatementHead = false
      exp = parser.compactClauseExpression()
      #if exp.isBracket then exp.shift()
      if exp[0]!='list!' then exp = ['list!', exp]
      space(); expectChar(':', 'expect ":" after case values')
      body = parser.block() or parser.lineBlock()
      [exp, begin(body)]

  @keyword = ->
    start = cursor
    if (x=symbol() or taijiIdentifier()) and isKeyword(x) then return x
    cursor = start; return

  # if test then action else action
  keywordThenElseStatement = (keyword) -> (isHeadStatement) ->
    line1 = lineno; space()
    if not (test=parser.clause())? then error 'expect a clause after "'+keyword+'"'
    then_ = thenClause(line1, isHeadStatement, options={colonAtEndOfLine: test.colonAtEndOfLine})
    else_ = elseClause(line1, isHeadStatement, options)
    if else_ then [keyword, test, then_, else_]
    else [keyword, test, then_]

  # while! test body...
  keywordTestExpressionBodyStatement = (keyword) -> (isHeadStatement) ->
    line1 = lineno; space()
    if not (test = parser.compactClauseExpression())
      error 'expect a compact clause expression after "'+keyword+'"'
    if not (body = parser.lineBlock()) then error 'expect the body for while! statement'
    [keyword, test, begin(body)]

  # throw or return value
  throwReturnStatement = (keyword) -> (isHeadStatement) ->
    space(); if text[cursor]==':' and text[cursor+1]!=':' then cursor++; space();
    if clause = parser.clause() then [keyword, clause] else [keyword]

  # break; continue
  breakContinueStatement = (keyword) -> (isHeadStatement) ->
    space()
    if lbl = jsIdentifier() then [keyword, lbl] else [keyword]

  letLikeStatement = (keyword) -> (isHeadStatement) ->
    line1 = lineno; space()
    varDesc = parser.varInitList() or parser.clause()
    [keyword, varDesc, thenClause(line1, isHeadStatement, {})]

  # no cursor and lineno is attached in result, so can not be memorized directly.
  @identifierLine = ->
    result = []
    while space() and not parser.lineEnd() and not follow('newline') and text[cursor]!=';'
      if x=parser.identifier() then result.push x
      else error 'expect an identifier'
    result

  # no cursor and lineno is attached in result, so can not be memorized directly.
  @identifierList = ->
    line1 = lineno; indentCol = lineInfo[line1].indentCol
    result = parser.identifierLine()
    spac = bigSpace();
    if (col0=lineInfo[lineno].indentCol)<=indentCol
      rollbackToken spac; return result
    if text[cursor]==';' then return result
    while varList=parser.identifierLine()
      result.push.apply result, varList
      spac = bigSpace()
      if (col=lineInfo[lineno].indentCol)<=indentCol then rollbackToken spac; break
      else if col!=col0 then error 'inconsistent indent of multiple identifiers lines after extern!'
      if text[cursor]==';' then break
    result

  @varInit = ->
    if not (id = parser.identifier()) then return
    space()
    if text[cursor]=='=' and cursor++
      if value=parser.block() then value = begin(value)
      else if not(value=parser.clause()) then error 'expect a value after "=" in variable initilization'
    space()
    if text[cursor]==',' then cursor++
    if not value then return id else return [id, '=', value]

  @varInitList = ->
    start = cursor; line1 = lineno; result = []
    indentCol0 = lineInfo[lineno].indentCol
    spac = bigSpace()
    col = lineInfo[lineno].indentCol
    if col>indentCol0 then indentCol1 = col
    else if spac.undent or spac.newline then error 'unexpected new line, expect at least one variable in var statement'
    while 1
      if x=parser.varInit() then result.push x
      else break
      space1 = bigSpace()
      col = lineInfo[lineno].indentCol
      if not text[cursor] or text[cursor]==';' or follow 'rightDelimiter' then break
      if lineno==line1 then continue
      if col>indentCol0
        if indentCol1 and col!=indentCol1 then error 'unconsitent indent in var initialization block'
        else if not indentCol1 then indentCol1 = col
      else if col==indentCol0 then break
      else rollbackToken space1
    # if not result.length then error 'expect at least one variable in var statement'
    if not result.length then rollback start, line1; return
    return result

  @importItem = ->
    start = cursor; line1 = lineno
    sym = parser.symbol()
    if sym and (symValue=sym.text)!='#' and symValue!='#/'
      error 'unexpected symbol after "as" in import! statement'
    name = parser.identifier()
    if name
      if name.text=='from'
        if sym
          error 'keyword "from" should not follow "#" or "#/" immediately in import! statement, expect variable name instead'
        else return rollback(start, lineno)
    else if text[cursor]=="'" or text[cursor]=='"'
      if sym
        error 'file path should not follow "#" or "#/" immediately in import! statement, expect variable name instead'
      else return  rollback(start, lineno)
    space()
    start1 = cursor; line2 = lineno
    if (as_=taijiIdentifier())
      if as_.text=='from' then as_ = undefined; rollback start1, line2
      else if as_.text!='as' then error 'unexpected word '+as_.text+', expect "as", "," or "from [module path...]"'
      else
        space()
        sym2 = parser.symbol()
        if sym2 and (symValue2=sym2.text)!='#' and symValue2!='#/'
          error 'unexpected symbol after "as" in import! statement'
        if symValue=='#/'
          if symValue2=='#'
            error 'expect "as #/alias" or or "as alias #alias2" after "#/'+name.text+'"'
        else if symValue=='#'
          if not symValue
            error 'meta variable can not be imported as runtime variable'
          else if symValue=='#/'
            error 'meta variable can not be imported as both meta and runtime variable'
        else if not symValue
          if symValue2=='#'
            error 'runtime variable can not be imported as meta variable'
          else if symValue2=='#/'
            'runtime variable can not be imported as both meta and runtime variable'
        space(); asName = expectIdentifier()
        if symValue=='#/' and not symValue2
          space(); sym3 = parser.symbol()
          if not sym3 then error 'expect # after "#/'+name.text+' as '+asName.text+'"'
          else if sym3.text!='#' then error 'unexpected '+sym3.text+' after "#/'+name.text+'as '+asName.text+'"'
          asName2 = expectIdentifier()
    if not as_
      if symValue=='#/' then return [[name, name], [name, name, 'meta']]
      else if symValue=='#' then return [[name, name, 'meta']]
      else return [[name, name]]
    else
      if symValue=='#/'
        if asName2 then return [[name, asName], [name,asName2, 'meta']]
        else return [[name, asName], [name,asName, 'meta']]
      else if symValue=='#' then return [[name, asName, 'meta']]
      else return [[name, asName]]

  @exportItem = ->
    runtime = undefined
    if text[cursor...cursor+2]=='#/' then cursor+=2; runtime = 'runtime'; meta = 'meta'; space()
    else if (c=text[cursor])=='#' then cursor++; meta = 'meta'; space()
    else runtime = 'runtime'
    if meta then name = expectIdentifier()
    else if not (name = taijiIdentifier()) then return
    space()
    if text[cursor]=='=' and cursor++
      space(); value = parser.spaceClauseExpression(); space()
    [name, value, runtime, meta]

  @spaceComma = spaceComma = -> space(); if text[cursor]==',' then cursor++; space(); return true
  @seperatorList = seperatorList = (item, seperator) ->
    if typeof item=='string' then item = parser[item]
    ->
      result = []
      while x=item()
        result.push x
        if seperator() then continue
        else break
      result

  @importItemList = seperatorList('importItem', spaceComma)

  @exportItemList = seperatorList('exportItem', spaceComma)

  @expectIdentifier = expectIdentifier = (message) ->
    if id=parser.identifier() then return id
    else error message or 'expect identifier'

  @expectOneOfWords = expectOneOfWords = (words...) ->
    space(); token = taijiIdentifier();
    if not token then error 'expect one of the words: '+words.join(' ')
    value = token.value; i = 0; length = words.length;
    while i<length then (if value==words[i] then return words[i] else i++)
    error 'expect one of the words: '+words.join(' ')

  maybeOneOfWords = (words...) ->
    space(); token = taijiIdentifier();
    if not token then return
    value = token.value; i = 0; length = words.length;
    while i<length then (if value==words[i] then return words[i] else i++)
    return
  expectWord = (word) -> space(); (if not (token=taijiIdentifier()) or token.value!=word then error 'expect '+ word); word
  word = (w) ->
    start = cursor; line1 = lineno; space()
    if not token=taijiIdentifier() then return
    if token.value!=w then return rollback(start, line1)
    return token

  @expectChar = expectChar = (c) -> if text[cursor]==c then cursor++ else error 'expect "'+c+'"'

  @endOfDynamicBlock = @eob = ->
    if cursor==endCursorOfDynamicBlockStack[-1] then return true
    else return false

  @keywordToStatementMap =
    '%': (isHeadStatement) ->
      start = cursor; line1 = lineno
      if not space().text then return
      leadClause = parser.clause()
      code = compileExp(['return', ['%/', leadClause]], environment)
      space(); indentCol = lineInfo[lineno].indentCol
      if expectWord('then') or (text[cursor]==':' and cursor++)
        space()
        if newline()
          blockStopLineno = lineno
          while lineInfo[blockStopLineno].indentCol>indentCol and blockStopLineno<maxLine
            blockStopLineno++
          cursorAtEndOfDynamicBlock = lineInfo[blockStopLineno].indentCol or text.length
        else
          blockStopLineno = lineno+1
          cursorAtEndOfDynamicBlock = lineInfo[blockStopLineno].indentCol or text.length
      else error 'expect "then" or ":"'
      endCursorOfDynamicBlockStack.push cursorAtEndOfDynamicBlock
      result = new Function('__$taiji_$_$parser__', code)(parser)
      endCursorOfDynamicBlockStack.pop()
      cursor = cursorAtEndOfDynamicBlock; lineno = blockStopLineno
      if Object::toString.call(result) == '[object Array]'
        extend result, {start: start, stop:cursor, line1: line, lineno:lineno}
      else {value: result, start: start, stop:cursor, line1: line1, lineno:lineno}

    'break': breakContinueStatement('break')
    'continue': breakContinueStatement('continue')
    'throw': throwReturnStatement('throw')
    'return': throwReturnStatement('return')
    'new': throwReturnStatement('new')

    'var': (isHeadStatement) -> ['var'].concat parser.varInitList()
    'extern!': (isHeadStatement) -> ['extern!'].concat parser.identifierList()
    'include!': (isHeadStatement) ->
      space(); filePath = expect('string', 'expect a file path')
      space()
      if word('by')
        space(); parseMethod = expect('taijiIdentifier', 'expect a parser method')
      ['include!', filePath, parseMethod]

    # import [#/]name [as [#/]name] ... from path as [#/]name #name [by method]
    'import!': (isHeadStatement) ->
      space()
      items = parser.importItemList(); space()
      if items.length then from_ = expectWord('from') # or items[0][2]
      else from_ = word('from')
      #if not from_ then return ['import!', names[0][0], names[0][1], []]
      space(); srcModule = parser.string(); space();
      if as_ = literal('as')
        space()
        sym = parser.symbol()
        if sym
          if (symValue=sym.text)!='#' and sym.text!='#/'
            error 'unexpected symbol before import module name', sym
        alias = expectIdentifier('expect an alias for module')
        if symValue=='#' then metaAlias = alias; alias = undefined
        else if symValue=='#/' then metaAlias = alias
        space()
        sym2 = parser.symbol()
        if sym and sym2 then error 'unexpected symbol after meta alias'
        space(); alias2 = parser.identifier()
        # sym is the first symbol # or #/
        if sym  and alias2 then 'unexpected identifier '+alias2+' after '+symValue+alias
        if alias2 then metaAlias = alias2
        space()
      if word('by')
        space(); parseMethod = expect('taijiIdentifier', 'expect a parser method')
      runtimeImportList = []; metaImportList = []
      for item in items
        for x in item
          if x[2] then  metaImportList.push x
          else runtimeImportList.push x
      ['import!'].concat [srcModule, parseMethod, alias, metaAlias, runtimeImportList, metaImportList]

    'export!': (isHeadStatement) -> space(); ['export!'].concat parser.exportItemList()

    'let': letLikeStatement('let')
    'letrec!': letLikeStatement('letrec!')
    'letloop!': letLikeStatement('letloop!')
    'if': keywordThenElseStatement('if')
    'while': keywordThenElseStatement('while')
    'while!': keywordTestExpressionBodyStatement('while!')

    'for': (isHeadStatement) ->
      line1 = lineno; space()
      if text[cursor]=='(' and cursor++
        init = parser.clause(); space(); expectChar(';')
        test = parser.clause(); space(); expectChar(';')
        step = parser.clause(); space(); expectChar(')')
        return ['cFor!', init, test, step, thenClause(line1, isHeadStatement, {})]
      name1 = expectIdentifier(); space()
      if text[cursor]==',' then cursor++; space()
      if (token=jsIdentifier()) and value=token.value
        if value=='in' or value=='of' then inOf = value
        else name2 = value; space(); inOf = expectOneOfWords('in', 'of')
        space(); obj = parser.clause()
      if name2
        if inOf=='in' then kw = 'forIn!!' else kw = 'forOf!!'
        [kw, name1, name2, obj, thenClause(line1, isHeadStatement, {})]
      else
        if inOf=='in' then kw = 'forIn!' else kw = 'forOf!'
        [kw, name1, obj, thenClause(line1, isHeadStatement, {})]

    'do': (isHeadStatement) ->
      line1 = lineno; space(); indentCol = lineInfo[lineno].indentCol
      body = parser.lineBlock()
      if newlineFromLine(line1, lineno) and not isHeadStatement then return body
      if not (conj=maybeOneOfWords('where', 'when', 'until'))
        error 'expect conjunction where, when or until'
      if conj=='where' then tailClause = parser.varInitList()
      else tailClause = parser.clause()
      if conj=='where' then ['let', tailClause, body]
      else if conj=='when' then ['doWhile!', body, tailClause]
      else ['doWhile!', body, ['!x', tailClause]]

    'switch': (isHeadStatement) ->
      line1 = lineno
      if not (test = parser.clause()) then error 'expect a clause after "switch"'
      options = {}; cases = ['list!']
      while case_=caseClauseOfSwitchStatement(line1, isHeadStatement, options) then cases.push case_
      else_ = elseClause(line1, isHeadStatement, options)
      ['switch', test, cases, else_]

    'try': (isHeadStatement) ->
      line1 = lineno;
      if not (test = parser.lineBlock()) then error 'expect a line or block after "try"'
      if atStatementHead and not isHeadStatement
        error 'meet unexpected new line when parsing inline try statement'
      options = {}; #catchClauses = ['list!']
      #while catch_=catchClause(line1, isHeadStatement, options) then catchClauses.push catch_
      #else_ = elseClause(line1, isHeadStatement, options);
      catch_ = catchClause(line1, isHeadStatement, options)
      if not catch_ then error 'expect a catch clause for try-catch statement'
      final = finallyClause(line1, isHeadStatement, options)
      #['try', begin(test), catch_, else_, final]
      ['try', begin(test), catch_[0], catch_[1], final]

    'class': (isHeadStatement) ->
      line1 = lineno; space();
      # class name should be provided explicitly
      name = expect('identifier', 'expect class name'); space()
      if parser.conjunction('extends') then space(); superClass = parser.identifier(); space()
      else supers = undefined
      if followNewline() and newlineFromLine(line1, line1+1) then body = undefined
      else body = parser.lineBlock()
      ['#call!', 'class', [name, superClass, body]]

  @statement = memo ->
    start = cursor; line1 = lineno
    if not (keyword = symbol() or taijiIdentifier()) then return
    if stmtFn = parser.keywordToStatementMap[keyword.text]
      isHeadStatement = atStatementHead; atStatementHead = false
      if stmt = stmtFn(isHeadStatement)
        return extend stmt, {start:start, stop:cursor, line1:line1, line:lineno}
    return rollback start, line1

  @defaultAssignLeftSide = memo ->
    start = cursor; line1 = lineno
    if not (x=parser.spaceClauseExpression()) then return
    if x.type==PAREN or x.type==BRACKET or x.type==DATA_BRACKET or x.type==CURVE
      rollback start, line1; return
    x = getOperatorExpression x
    if not x then  rollback start, line1; return
    if x.type==IDENTIFIER or ((e=entity(x)) and (e[0]=='attribute!' or e[0]=='index!')) then x
    else if x.text=='::' then x
    else if parser.isAssign(x[0]) then rollback x[1].stop, x[1].line; return x[1]
    else  rollback start, line1; return

  @isAssign = (val) -> (op=binaryOperatorDict[val]) and op.assign

  @defaultAssignSymbol = -> (x=parser.symbol()) and parser.isAssign(x.text) and x

  @defaultAssignRightSide = memo ->
    space2 = bigSpace()
    if space2.undent then error 'unexpected undent after assign symbol'+symbol.text
    else if space2.newline then error 'unexpected new line after assign symbol'+symbol.text
    parser.block() or parser.clause()

  @makeAssignClause = (assignLeftSide, assignSymbol, assignRightSide) -> ->
    start = cursor; line1 = lineno
    if not (left=assignLeftSide()) then return
    spac = space()
    if not (token=assignSymbol()) then return rollback start, line1
    right = assignRightSide(spac)
    if left.type==CURVE
      eLeft = entity(left)
      if typeof eLeft=='string'
        if eLeft[0]=='"' then error 'unexpected left side of assign: '+eLeft
        left = [left]
      else if eLeft and eLeft.push
        if eLeft[0]=='begin!' then error 'syntax error: left side of assign should be a list of variable names separated by space'
      else error 'unexpected left side of assign'
      return ['hashAssign!', left, right]
    extend [token, left, right], {start:start, cursor:cursor, line1:line1, line:lineno}

  @defaultAssignClause = @makeAssignClause @defaultAssignLeftSide, @defaultAssignSymbol, @defaultAssignRightSide

  @customAssignClauses = []

  @assignClause = memo ->
    for matcher in parser.customAssignClauses then if x=matcher() then return x
    parser.defaultAssignClause()

  @colonClause = memo ->
    start = cursor; line1 = lineno
    if not (result = parser.sequenceClause()) then return
    space()
    if (x=parser.symbol()) and x.text==':'
      spac = bigSpace()
      if spac.newline then error '":" should not before a new line'
      else if spac.undent then error '":" should not be before undent'
      else if spac.indent
        result.colonAtEndOfLine = true
        return result
      if not result.push or result.isBracket then result = [result]
      result.push.apply result, parser.clauses()
      result.stop = cursor; result.line = lineno
      result
    else return rollback start, line1

  @indentClause = memo ->
    start = cursor; line1 = lineno
    if not (head=parser.sequenceClause()) then return
    spac = bigSpace(); if not spac.indent then return rollback start, line1
    if parser.lineEnd() then return rollback start, line1
    if not (blk=parser.blockWithoutIndentHead()) then return rollback start, line1
    if not head.push then head = [head]; head.start = start; head.line1 = line1
    head.push.apply head, blk
    extend head, {stop:cursor, line:lineno}

  @macroCallClause = memo ->
    start = cursor; line1 = lineno
    if (head=parser.compactClauseExpression())
       if (space1=space()) and not space1.text then return rollback(start, line1)
       if text[cursor]=='#' and cursor++ and ((spac=space()) and spac.text or text[cursor]=='\n' or text[cursor]=='\r')
          if blk = parser.block()
            return extend ['#call!', head, blk], {cursor:start, line1:lineno, stop:cursor, line:lineno}
          else if args = parser.clauses()
            return extend ['#call!', head, args], {cursor:start, line1:lineno, stop:cursor, line:lineno}
    rollback(start, line1)

  # caller and one expression as operand, e.g.
  # print 1 + 2*5
  # console.log x+7 and z or others
  # it's ambiguous while the first item is identifier, caller, accessor, etc
  @unaryExpressionClause = memo ->
    start = cursor; line1 = lineno
    if (head=parser.compactClauseExpression()) and space() and (x=parser.spaceClauseExpression()) and parser.clauseEnd()
      if text[cursor]==',' then cursor++
      return extend [getOperatorExpression(head), getOperatorExpression(x)], {start:start, stop:cursor, line1:line1, line:lineno}
    return rollback start, line1

  # a expression may be not wrapped in parenthesis
  # it's ambiguous while the first item is identifier, caller, accessor, etc
  @expressionClause = memo ->
    start = cursor; line1 = lineno
    if (x=parser.spaceClauseExpression())
      if parser.clauseEnd() then return getOperatorExpression x
      else return rollback start, line1

  @defaultParameterList = ->
    if item=getOperatorExpression(paren(item))
      if params=parser.toParameters(item) then return params
      else
        if followSequence('inlineSpaceComment', 'defaultSymbolOfDefinition')
          error 'illegal parameters list for function definition'
        else rollbackToken item

  @defaultSymbolOfDefinition = ->
    if (x=parser.symbol())
      if (xValue=x.text) and xValue[0]!='\\' and ((xTail=xValue[xValue.length-2...])=='->' or xTail=='=>') then return x
      else rollbackToken(x)

  # a = -> x; b = -> y should be [= a [-> x [= b [-> y]]]]
  @defaultDefinitionBody = -> begin(parser.lineBlock()) or 'undefined'

  @makeDefinition = (parameterList, symbolOfDefinition, definitionBody) -> memo ->
    start = cursor; line1 = lineno
    if not (parameters=parameterList()) then parameters = []
    space()
    if not (token=symbolOfDefinition()) then return rollback start, line1
    space()
    body = definitionBody()
    extend [token, parameters, body], {start:start, stop:cursor, line1:line1, line:lineno}

  @defaultDefinition = @makeDefinition @defaultParameterList, @defaultSymbolOfDefinition, @defaultDefinitionBody

  @customDefinition = []

  @definition = memo ->
    for matcher in parser.customDefinition
      if x=matcher() then break
    if x or (x=parser.defaultDefinition()) then return x

  @clauseItem = ->
    start = cursor; line1 = lineno; spac = bigSpace()
    if not spac.inline then rollbackToken spac; return
    if parser.clauseEnd() then return
    if text[cursor]==':' and text[cursor+1]!=':' then return
    if (item=parser.definition()) then return item
    item = parser.compactClauseExpression()
    if item then return extend getOperatorExpression(item), {start:start, stop:cursor, line1:line1, line:lineno}

  @sequenceClause = memo ->
    start = cursor; line1 = lineno; clause = []
    while item = parser.clauseItem() then clause.push item
    if text[cursor]==',' then meetComma = true; cursor++
    if not clause.length and not meetComma then return
    extend clause, {start:start, stop:cursor, line1:line1, line:lineno}

  @customClauseList = ['statement','labelStatement',
    'leadWordClause', 'assignClause', 'colonClause', 'macroCallClause', 'indentClause',
    'expressionClause', 'unaryExpressionClause']

  @clause = memo ->
    start = cursor; line1 = lineno
    if (parser.clauseEnd()) then return
    for matcher in parser.customClauseList
      if x=parser[matcher]() then return x
    if not(clause = parser.sequenceClause()) then return
    if clause.length==1 then clause = clause[0]
    if typeof clause != 'object' then clause = {value: clause}
    extend clause, {start:start, stop:cursor, line1:line1, line:lineno}

  @clauses = -> result = []; (while clause=parser.clause() then result.push clause); return result

  @sentenceEnd = (spac) ->
    spac = spac or bigSpace()
    if parser.lineEnd() then return true
    if not spac.inline then rollbackToken(spac); return true

  @sentence = memo ->
    start = cursor; line1 = lineno
    if parser.sentenceEnd() then return
    if text[cursor]==';' then cursor++; return []
    extend parser.clauses(), {start:start, stop:cursor, line1:line1, line:lineno}

  @lineCommentBlock = memo ->
    start = cursor
    if comment=parser.lineComment()
      if comment.indent
        if comment.text[...3]=='///' then result = parser.blockWithoutIndentHead(); result.unshift ['directLineComment!', comment.text]; result
        else parser.blockWithoutIndentHead()
      else
        if text[start...start+3]=='///'
          [extend(['directLineComment!', comment.text], {start:start, stop:cursor, line: lineno})]
        else [extend(['lineComment!', comment.text], {start:start, stop:cursor, line: lineno})]

  @codeCommentBlockComment = memo ->
    if cursor!=lineInfo[lineno].start+lineInfo[lineno].indentCol then return
    if text[cursor]!='/' then return
    if (c=text[cursor+1])=='.' or c=='/' or c=='*' then return
    start = cursor; line1 = lineno; cursor++
    code = parser.lineBlock()
    extend [['codeBlockComment!', code]], {start:start, stop:cursor, line1: line1, line: lineno}

  @lineEnd = -> not text[cursor] or follow('conjunction') or follow('rightDelimiter')#  \

  @line = ->
    if parser.lineEnd() then return
    if x=(parser.lineCommentBlock() or parser.codeCommentBlockComment()) then return x
    result = []
    while x = parser.sentence() then result.push.apply result, x
    result

  # a block which must start with a indent
  @block = ->
    indentCol = lineInfo[lineno].indentCol; spac = bigSpace();
    if not spac.indent then return rollbackToken spac
    else
      x = parser.blockWithoutIndentHead()
      spac = bigSpace()
      if lineInfo[lineno].indentCol<indentCol then rollbackToken spac
      x

  # a block with out indent( the indent has been ate before).
  # stop until meet a undent (less indent col than the intent col of the start line)
  @blockWithoutIndentHead = ->
    indentCol = lineInfo[lineno].indentCol; result = []
    while (x=parser.line()) and (spac = bigSpace())
      if x.length!=1 or not (x0=x[0]) or (x0[0]!='lineComment!' and x0[0]!='codeBlockComment!')
        result.push.apply(result, x)
      if lineInfo[lineno].indentCol<indentCol then rollbackToken spac; break
    result

  @lineBlock = ->
    space1 = bigSpace(); if space1.indent then return parser.blockWithoutIndentHead()
    line = parser.line()
    cursor2 = cursor
    space2 = bigSpace()
    if indentCol<=indentCol1 then rollback cursor2
    else line.push.apply line, parser.blockWithoutIndentHead()
    line

  @moduleBody = ->
    body = []
    while 1
      if not x=parser.line() then break
      spac = bigSpace()
      body.push.apply body, x
      clearMemo()
      if lineInfo[lineno].indentCol<indentCol then rollbackToken spac; break
    if text[cursor] then error 'expect end of input, but meet "'+text.slice(cursor)+'"'
    begin body

  @moduleHeader = ->
    if not (literal('taiji') and spaces()  and  literal('language') and spaces() and
        (x=decimal()) and char('.') and (y=decimal()))
      error 'taiji language module should begin with "taiji language x.x"'
    if (x=x.value)!=0 or (y=y.value)!=1 then error 'taiji 0.1 can not process taiji language'+x+'.'+y
    lineno++
    while lineno<=maxLine and (lineInfo[lineno].indentCol>0 or lineInfo[lineno].empty) then lineno++
    if lineno>maxLine then cursor = text.length
    else cursor = lineInfo[lineno].start # lineInfo[lineno].indentCol = 0
    {type: MODULE_HEADER, version: {main:x, minor:y}, value: text[...cursor]}

  @module = ->
    # #!use/bin/node taiji
    if text[cursor...cursor+2]=='#!' then  scriptDirective = ['scriptDirective!', skipLineTail()]
    wrapResult ['module!', scriptDirective, parser.moduleHeader(), parser.moduleBody()], {type: MODULE}

  @init = (data, cur, env) ->
    @text = text = data; cursor = cur; char = text[cursor]; lineno = 1; column = 0
    token = {} # an empty token, {}.next is undefined, so nextToken will call matchToken
    # should not call matchToken() here, because the head of module need be processed differently
    # matchToken() should be called in moduleBody() instead
    memoMap = {}
    atStatementHead = true
    @environment = environment = env
    @meetEllipsis = false
    endCursorOfDynamicBlockStack = []

  @parse = (data, root, cur, env) ->
    parser.init(data, cur, env)
    # should not call matchToken() here, because the head of module need be processed differently
    # matchToken() should be called in moduleBody() instead
    root()

  @lexError = lexError = (message) ->
    throw cursor+'('+lexRow+':'+lexCol+'): '+message+': \n'+text[cursor-40...cursor]+'|   |'+text[cursor...cursor+40]

  @error = error = (message, tkn) ->
    tkn = tkn or token; cur = tkn.cursor
    throw cur+'('+tkn.line+':'+tkn.column+'): '+message+': \n'+text[cur-40...cur]+(text[cur...cur+40].red)

  return @

{compileExp} = require '../compiler'