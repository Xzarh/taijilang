colors = require('colors')

{charset, isArray, str, entity, dict, list2dict, extendSyntaxInfo} = require '../utils'

{extend, firstIdentifierChars, firstIdentifierCharSet, letterDigitSet, identifierChars,
digitCharSet, letterCharSet, identifierCharSet, firstSymbolCharset
taijiIdentifierCharSet, constant} = base = require './base'
digitChars = base.digits
letterChars = base.letters

{NULL, NUMBER,  STRING,  IDENTIFIER, SYMBOL, REGEXP,  HEAD_SPACES, CONCAT_LINE, PUNCTUATION, FUNCTION, C_BLOCK_COMMENT
PAREN, BRACKET, DATA_BRACKET, CURVE, INDENT_EXPRESSION
NEWLINE,  SPACES,  INLINE_COMMENT, SPACES_INLINE_COMMENT,
LINE_COMMENT, BLOCK_COMMENT, CODE_BLOCK_COMMENT,CONCAT_LINE
NON_INTERPOLATE_STRING, INTERPOLATE_STRING, EOI
INDENT, UNDENT, HALF_DENT, MODULE_HEADER, MODULE, SPACE_COMMENT, TAIL_COMMENT
SPACE, HASH, RIGHT_DELIMITER, KEYWORD, CONJUNCTION
CODE_BLOCK_COMMENT_LEAD_SYMBOL
PREFIX, SUFFIX, BINARY
END_INTERPOLATED_STRING

OPERATOR_EXPRESSION, COMPACT_CLAUSE_EXPRESSION, SPACE_CLAUSE_EXPRESSION, INDENT_EXPRESSION, HASH_KEY_EXPRESSION

} = constant

{prefixOperatorDict, suffixOperatorDict, binaryOperatorDict, makeExpression} = require './operator'

exports.escapeNewLine = escapeNewLine = (s) -> (for c in s then (if c=='\n' then '\\n' else '\\r')).join('')

exports.keywordMap = keywordMap =
  'if': 1, 'try':1, 'switch':1, 'while':1, 'while!':1, 'let':1, 'letrec!':1, 'letloop!':1, 'do':1, 'repeat':1
  'return':1, 'break':1, 'continue':1, 'throw':1,'function':1,'for':1, 'import!':1,  'export!':1
  'loop':1, 'class':1, 'var':1, 'for':1

keywordHasOwnProperty = Object.hasOwnProperty.bind(exports.keywordMap)

exports.isKeyword = isKeyword = (item) ->
  item and not item.escaped and keywordHasOwnProperty(item.text)

exports.conjMap = conjMap =
  'then':1, 'else':1, 'catch':1, 'finally':1, 'case':1, 'default':1, 'extends': 1
  'until':1, 'where':1, 'when':1
conjunctionHasOwnProperty = Object.hasOwnProperty.bind(exports.conjMap)

exports.isConjunction = isConjunction = (item) ->
  item and not item.escaped and conjunctionHasOwnProperty(item.text)

hasOwnProperty = Object::hasOwnProperty

begin = (exp) ->
  if not exp or not exp.push then return exp
  if exp.length==0 then ''
  else if exp.length==1 then exp[0]
  else exp.unshift('begin!'); exp

exports.Parser = ->
  parser = @; @predefined = predefined = {}
  unchangeable = ['cursor', 'setCursor', 'lineno', 'setLineno', 'atLineHead', 'atStatementHead', 'setAtStatementHead']

  # global variable used by lexer
  text = '' # text to be parsed
  cursor = 0 # position pointer while do lexical parsing, use cur for local position pointer
  char = '' # current character, should assure char is the value of text[cursor] whenerver entering or leaving a function
  lineno = 0 # current line number, use line for local line number
  lineStart = 0 # start cursor of current line
  lexIndent = 0 # global lexical indent column of current line, use dent for local indent column
  indent = 0 # global indent while parsing, get from tokens including SPACE, NEWLINE, INDENT, UNDENT, EOI
  atLineHead = true # global indicator to tell whether cursor is at the head of a line before any non space character

  # token should have the field: type, value, cursor, stopCursor, line, column
  # token like SPACE, NEWLINE, INDENT, UNDENT should have the field "indent" which means the indent of the end line of the token
  token = undefined # global token generated by lexical parsing and used by the parser

  # global variable used by the syntax parser
  memoMap = {} # memorize the result for syntax matcher
  atStatementHead = true # whether is at head of statement
  environment = null # compiler environment used by dynamic evaluation while parsing
  endCursorOfDynamicBlockStack = [] # used by "then" block of ? clause to identifier end of dynamic block

  memoIndex = 0  # don't need be set in parser.init, memoMap need to be set instead.

  eoi = {type:EOI, value:'', cursor: text.length, column: -1, indent: -1} # line wait to be filled
  eoi.next = eoi  # eoi.next is always itself

  nextToken = ->
    if token.indent!=undefined then indent = token.indent
    switch token.type
      when NEWLINE, INDENT, UNDENT, EOI then atStatementHead = true
    if token.next then token = token.next
    else
      if not char
        if token==eoi then return eoi
        eoi.lineno = lineno+1; lineStart = cursor; lexIndent = -1
        token.next = eoi
        return token = eoi # while reaching the end of input, always return eoi
      else if fn = tokenFnMap[char] then return token=fn(char)
      else return token=tokenOnSymbolChar()

  #  tokenFnMap[char](char) and tokenOnSymbolChar should change the token
  @matchToken = matchToken = ->
    if not char
      if token==eoi then return eoi
      eoi.lineno = lineno+1; lineStart = cursor; lexIndent = -1
      token.next = eoi
      return token = eoi # while reaching the end of input, always return eoi
    else if fn = tokenFnMap[char] then return token=fn(char)
    else return token=tokenOnSymbolChar()

  # while parsing for (i=0; i<10; i++) then ..., we hope
  skipToken = ->
    cursor = token.stopCursor; char = text[cursor]; lexIndent = indent = token.indent or indent; token = nullToken()

  skipSpace = ->
    if char!=' ' and char!='\t' then return
    tokenOnSpaceChar()
    if token.type==SPACE then skipToken()

  nullToken = ->
    {type:NULL, value:'', cursor:cursor, stopCursor:cursor, line:lineno, column:cursor-lineStart}

  @token = -> token

  @tokenFnMap = tokenFnMap = {}

  tokenOnSymbolChar = ->
    cur = cursor
    while char = text[++cursor]
      if symbolStopChars[char] then break

      # //, /*, /!
      # "/!" always start a regexp
      if char=='/' and ((c2=text[cursor+1])=='/' or c2=='*' or c2=='!') then break
      # else if c2=='.' # should not reach here, because this /. is always in the middle of the symbol, not in the front
      # "\" should not be concatenated symbol if following symbol characters
      #else if char=='\\' and ((c2=text[cursor+1])=='\n'  or c2=='\r') then break

    token.next = {type:SYMBOL, value: text.slice(cur, cursor),
    cursor:cur, stopCursor:cursor, line: lineno, column:cursor-lineStart}

  symbolStopChars = {}
  for c in ' \t\v\n\r()[]{},;:#\'\".@\\' then symbolStopChars[c] = true
  for c of firstIdentifierCharSet then symbolStopChars[c] = true
  for c in '0123456789' then symbolStopChars[c] = true

  tokenFnMap['#'] = tokenOnSharpChar = ->
    cur = cursor
    while 1 then if (char=text[++cursor])!='#' then break
    while char
      if symbolStopChars[char] then break

      # //, /*, /!
      # "/!" always start a regexp
      if char=='/' and ((c2=text[cursor+1])=='/' or c2=='*' or c2=='!') then break
      # else if c2=='.' # should not reach here, because this /. is always in the middle of the symbol, not in the front
      # "\" should not be concatenated symbol if following symbol characters
      #else if char=='\\' and ((c2=text[cursor+1])=='\n'  or c2=='\r') then break
      char = text[++cursor]

    token.next = {type:SYMBOL, value: text.slice(cur, cursor),
    cursor:cur, stopCursor:cursor, line: lineno, column:cursor-lineStart}

  tokenFnMap['@'] = tokenFnMap['.'] = tokenOnAtChar = ->
    cur = cursor; column = cursor-lineStart; first = char; char = text[++cursor]
    while char==first then char = text[++cursor]
    token.next = {type: SYMBOL, value: text.slice(cur, cursor),
    cursor:cur, stopCursor:cursor,
    line: lineno, column:column, atom:cursor-cur==1}

  tokenFnMap[':'] = tokenOnColonChar = ->
    cur = cursor; column = cursor-lineStart; first = char; char = text[++cursor]
    while char==first then char = text[++cursor]
    if cursor==cur+1 then type = PUNCTUATION else type = SYMBOL
    token.next = {type:type, value: text.slice(cur, cursor), atom:cursor-cur==2
    cursor:cur, stopCursor:cursor,
    line: lineno, column:column}

    # the word "space" below maybe means not spacebar key or space character ' ' or '\t'
  # it means anything piece like white space, e.g. ' ', '\t', etc.

  concatenateLine = ->
    cur = cursor-1; line = lineno; column = cursor-lineStart; indent = lexIndent
    if char=='\n'
      char = text[++cursor]
      if char=='\r' then char = text[++cursor]
    else if char=='\r'
      char = text[++cursor]
      if char=='\n' then char = text[++cursor]
    lineStart = cursor
    while (char=text[cursor]) and char==' ' then cursor++
    if char=='\t' then lexError 'do not allow use tab character "\t" at the head of line.'
    else if char=='\n' or char=='\r' then lexError 'should not follow empty line as concatenated line'
    else if not char then lexError 'unexpected end of input after concatenated line symbol "\"'
    lexIndent = cursor-lineStart
    if lexIndent<indent then lexError 'expect the same indent or more indent for the concatenated lines'
    skipInlineSpace()
    if (char=text[cursor])=='\n' or char=='\r'
      lexError 'concatenated line should not have only spaces and comments'
    return token.next = {type:SPACE, cursor:cur, stopCursor: cursor, line:line, stopLine:lineno, column:column, indent:lexIndent}

  # token started with ' ' and '\t'
  tokenFnMap[' '] = tokenFnMap['\t'] = tokenOnSpaceChar = ->
    cur = cursor; line = lineno; column = cursor-lineStart; indent = lexIndent
    char = text[++cursor]
    skipInlineSpace(indent)
    if char=='\\'
      char = text[++cursor]
      if char=='\n' or c=='\r'
        token.next = tkn = concatenateLine()
        tkn.cursor = cur; tkn.line = line; tkn.column = column; tkn.value = text[cur...cursor]
        return tkn
      else
        cursor--
        return  token.next = {type:SPACE, value:text[cur...cursor], cursor:cur, stopCursor: cursor,
        line:line, stopLine:lineno, column:column, indent:lexIndent}
    else if char
      if char!='\n' and char!='\r'
        token.next = {type:SPACE, value:text[cur...cursor], cursor:cur, stopCursor: cursor,
        line:line, stopLine:lineno, column:column, indent:lexIndent}
      else
        type = newLineAndEmptyLines()
        token.next = {type:type, value:text[cur...cursor], cursor:cur, line:line, column:column, indent:lexIndent}
    else
      token.next = {type:EOI, value:text[cur...cursor], cursor:cur, line:line, column:column, indent:-1}

  # should be called after a new line
  skipSpaceLines = (dent) ->
    if char=='\n'
      char = text[++cursor]
      if char=='\r' then char = text[++cursor]
    else if char=='\r'
      char = text[++cursor]
      if char=='\n' then char = text[++cursor]
    lineStart = cursor
    while 1
      if not char then return
      while char and char==' ' then cursor++; char = text[cursor]
      if char=='\t' then unexpectedTabCharAtLineHead()
      else if char=='\n'
        if char=='\r' then cursor += 2 else cursor++
        char = text[cursor];  lineno++; lineStart = cursor
        continue
      else if char=='\r'
        if char=='\n' then cursor += 2 else cursor++
        char = text[cursor];  lineno++; lineStart = cursor
        continue
      else if not char then break
      else if (lexIndent=cursor-lineStart)!=dent then break
      else if char=='/'
        if (c2=text[cursor+1])=='/'
          cursor += 2; char = text[cursor]
          # skip line tail
          while (char=text[cursor]) and char!='\n' and char!='\r' then cursor++; char = text[cursor]
          continue
        # indent block comment /. ... /
        else if c2=='.'
          if atLineHead then leftIndentBlockComment(dent); continue
          else break # will be normal symbol
        else if c2=='*'
          cursor += 2; char = text[cursor]; leftCBlockComment()
          skipInlineSpace()
          if char=='\n'
            if char=='\r' then cursor += 2 else cursor++
            char = text[cursor];  lineno++; lineStart = cursor
            continue
          else if char=='\r'
            if char=='\n' then cursor += 2 else cursor++
            char = text[cursor];  lineno++; lineStart = cursor
            continue
          else break

        # regexp /! ... /
        else if c2=='!' then break

        # else if atLineHead then break # switch to tokenOnForwardSlashChar to process code block comment start symbol
        else break
      else break
    return

  # skipInlineSpace is called by tokenOnSpaceChar
  # skiptInlineSpace should not generate independent token and called independently
  skipInlineSpace = (dent) ->
    while 1
      while char==' ' or char=='\t' then char = text[++cursor]
      if char=='/'
        if (c2=text[cursor+1])=='*' then cursor +=2; char = text[cursor]; leftCBlockComment(dent); continue
        if c2=='/'
          # don't need to process column here, because want to skip characters until reaching new line
          cursor += 2; char = text[cursor]          
          while char!='\n' and char!='\r' then char = text[++cursor]; continue
          break
      break

  # \n\r, \r\n, \r, \n, don't eat spaces.
  @newline = newline = ->
    if (c=char)=='\r'
      cursor++;
      if (c2=text[cursor])=='\n' then cursor++; c2 = '\n'
      char = text[cursor]; lineno++; lineStart = cursor
    else if char=='\n'
      cursor++
      if (c2=text[cursor])=='\r' then cursor++; c2 = '\r'
      char = text[cursor]; lineno++; lineStart = cursor
    else return
    c+(c2 or '')

  # left indent block comment started with /., before entering this function, /. has been matched.
  leftIndentBlockComment = (dent) ->
    # skip line tail
    while char and char!='\n' and char!='\r' then char = text[++cursor]

    # skip lines that is empty or indent more spaces at the head
    while 1
      if char=='\n'
        if text[cursor+1]=='\r' then cursor+=2 else cursor++
        char = text[cursor]; lineno++; lineStart = cursor
        while char==' ' then char = text[++cursor]
        if char=='\n' or char=='\r' then continue
        if char=='\t' then lexError 'unexpected tab character "\t" at the head of line'
        if cursor-lineStart<=dent then break
        while char and char!='\n' and char!='\r' then char = text[++cursor]
      else if char=='\r'
        if text[cursor+1]=='\n' then cursor+=2 else cursor+=1
        char = text[cursor]; lineno++; lineStart = cursor
        while char==' ' then cursor++; char = text[cursor]
        if char=='\n' or char=='\r' then continue
        if char=='\t' then lexError 'unexpected tab character "\t" at the head of line'
        if cursor-lineStart<=dent then break
        while char and char!='\n' and char!='\r' then char = text[++cursor]
      else if not char then lexIndent = -1; break
    return

  # default /* some content */, can cross lines
  leftCBlockComment = (dent) ->
    # dent: the indent column of the line of '/*'
    while 1
      if char=='*' and text[cursor+1]=='/' then cursor += 2;  char = text[cursor]; break
      else if char=='\n'
        cursor++;  char = text[cursor]; lineno++
        if char=='\r' then cursor++;  char = text[cursor];
        lineStart = cursor
        while char==' ' then cursor++;  char = text[cursor]
        if char=='\t' then unexpectedTabCharAtLineHead()
        if char=='\n' or char=='\r' then continue
        else if not char then unexpectedEOI('while parsing c style block comment /* */')
        if lineStart-cursor<dent then expectMoreIndent(dent, 'while parsing c style block comment /* */')
      else if char=='\r'
        cursor++;  char = text[cursor]; lineno++
        if char=='\n' then cursor++; char = text[cursor]
        lineStart = cursor
        while char==' ' then cursor++;  char = text[cursor]
        if char=='\t' then unexpectedTabCharAtLineHead()
        if char=='\n' or char=='\r' then continue
        else if not char then unexpectedEOI('while parsing c style block comment /* */')
        if lineStart-cursor<dent then expectMoreIndent(dent)
      else if not char
        unexpectedEOI('while parsing c style block comment /* */')
      else char = text[++cursor]

  leftRegexp = ->
    while char
      if char=='\\'
        if (c2=text[cursor+1]=='/') or c2=='\\' then cursor += 2; char = text[cursor]
        else char = text[cursor++]
      else if char=='\n' or char=='\r'
        lexError 'meet unexpected new line while parsing regular expression'
      else if char=='/'
        i = 0; char = text[++cursor]
        # console.log text.slice(cursor)
        while char
          if char=='i' or char=='g'or char=='m' then char = text[++cursor]; ++i
          else break
          if i>3 then lexError 'too many modifiers "igm" after regexp'
        return
      else char = text[++cursor]
    if not char then lexError 'unexpected end of input while parsing regexp'

  # back slash \ can be used to escape keyword, conjunction, symbol
  tokenFnMap['\\'] = tokenOnBackSlashChar = ->
    cur = cursor; column = cursor-lineStart; char = text[++cursor]
    if char=='\n' or char=='\r'
      token.next = tkn = concatenateLine()
      tkn.cursor = cur; tkn.column = column; tkn.value = text[cur...cursor]
      return tkn
    line = lineno
    if firstIdentifierCharSet[char]
      tkn = tokenOnIdentifierChar()
      tkn.type = IDENTIFIER
      tkn.escaped = true; tkn.cursor = cur
      tkn.atom = true
      return token.next = tkn
    else if firstSymbolCharset[char]
      tkn = tokenOnSymbolChar()
      tkn.escaped = true; tkn.cursor = cur; token.value = '\\'+token.value
      return token.next = tkn
    else if char==':'
      tkn = tokenOnColonChar()
      tkn.value = '\\'+tkn.value
      tkn.escaped = true; tkn.cursor = cur
      return token.next = tkn
    else if char=='@'
      tkn = tokenOnAtChar()
      tkn.value = '\\'+tkn.value
      tkn.escaped = true; tkn.cursor = cur
      return token.next = tkn
    else if char=='.'
      tkn = tokenOnDotChar()
      tkn.value = '\\'+tkn.value
      tkn.escaped = true; tkn.cursor = cur
      return token.next = tkn
    else if char=="'"
      tkn = tokenOnSingleQuoteChar()
      if text[cur+2]=="'" and text[cur+3]=="'"
        # do not escape '''...'''
        char = text[++cursor]
        return token.next = {type:SYMBOL, value:'\\', cursor:cur, stopCursor:cursor
        line:lineno, column:cur-lineStart, indent:lexIndent
        next:tkn}
      else
        for c in text[cur+2...tkn.stopCursor]
          if c=='\n' or c=='\r' then lexError 'unexpected new line characters in escaped string'
        tkn.escaped = true; tkn.cursor = cur; tkn.atom = true
        return token.next = tkn
    # else if char=='"' # don't permit escape interpolated string
    else
      while char=text[++cursor]=='\\' then true
      return token.next = {type:SYMBOL, value:text[cur...cursor], cursor:cur, stopCursor:cursor
      line:lineno, column:cur-lineStart}

  tokenFnMap['/'] = tokenOnForwardSlashChar = ->
    cur = cursor; column = cursor-lineStart; char = text[++cursor]; line = lineno; indent = lexIndent
    # // start a line comment
    if char=='/' # // leading line comment
      # skip line tail
      cursor++; char=text[cursor]
      while char and char!='\n' and char!='\r' then cursor++; char=text[cursor]
      if char
        if char!='\n' and char!='\r'
          token.next = {type:SPACE, value: text[cur...cursor], cursor:cur, stopCursor:cursor, line:line, stopLine:lineno, column:column, indent:lexIndent}
        else
          token.next = {type:newLineAndEmptyLines(), value: text[cur...cursor], cursor:cur, stopCursor:cursor, line:line, column:column, indent:lexIndent}
      else
        token.next = {type:EOI, value: text[cur...cursor], cursor:cur, stopCursor:cursor, line:line, column:column, indent:lexIndent}
    # /* start a c style block comment
    else if char=='*'
      leftCBlockComment()
      skipInlineSpace()
      if char
        if char!='\n' and char!='\r'
          token.next = {type:SPACE, value: text[cur...cursor], cursor:cur, stopCursor:cursor, line:line, stopLine:lineno, column:column, indent:lexIndent}
        else
          token.next = {type:newLineAndEmptyLines(), value: text[cur...cursor], cursor:cur, stopCursor:cursor, line:line, column:column, indent:lexIndent}
      else
        token.next = {type:EOI, value: text[cur...cursor], cursor:cur, stopCursor:cursor, line:line, column:column, indent:lexIndent}
    # /! start a regexp
    else if char=='!'
      cur = cursor; cursor += 2; char = text[cursor]; column = cursor-lineStart
      leftRegexp()
      return token.next = {type:REGEXP, value:['regexp!', '/'+text[cur+1...cursor]], atom:true, cursor:cur, stopCursor:cursor, line:lineno, column: column}
    else if char=='.' # block comment /. multiple indented lines
      # block comment should never be generated at match_here
      # how to assure it?
      # when starting parsing the module body, use tokenOnSpaceChar to generate the first token
      # and then, only parse /. as indented block
      # but with global variable atLineHead, we do defensive style coding and simplify the design
      if atLineHead
        char = text[++cursor]
        leftIndentBlockComment(indent)
        skipSpaceLines(indent)
        if not char then t = EOI
        else if lexIndent>indent then t = INDENT
        else if lexIndent==indent then t = NEWLINE
        else t = UNDENT
        return token.next = {type: t, value: text[cur...cursor], cursor:cur, stopCursor:cursor, line:line, column:column}
      else
        # "/" return as independent symbol, left "." will be processed later, it and following "." maybe will become a symbol too.
        # a possible legal syntax is that "/" is used as a suffix operator and "." or ".." or "..." are used as a binary operator.
        # e.g. a/...b
        return token.next = {type: SYMBOL, value:"/", cursor:cur, stopCursor:cursor, line:line, column:column}
    else if atLineHead
      # the '/' at the head of one line should start a code block comment
      # which should be processed when meeting new line
      return token.next = {type:CODE_BLOCK_COMMENT_LEAD_SYMBOL, value:"/", cursor:cur, stopCursor:cursor, line:line, column:column}
    else
      # a symbol starts with "/"
      char = text[++cursor]; prev = token; tokenOnSymbolChar(); value = "/"+token.value
      token = {type:SYMBOL, value:value, cursor:cur, stopCursor:cursor, line:line, column:column}
      return prev.next = token

  newLineAndEmptyLines = ->
    while 1
      if char=='\n'
        char = text[++cursor]
        if char=='\r' then char = text[++cursor]
        lineStart = cursor
        while char and char==' ' then char = text[++cursor]
        if char=='\t' then lexError 'unexpected tab character "\t" at the head of line'
        if not char or (char!='\n' and char!='\r') then break
      else if char=='\r'
        char = text[++cursor]
        if char=='\n' then char = text[++cursor]
        lineStart = cursor
        while char and char==' ' then char = text[++cursor]
        if char=='\t' then lexError 'unexpected tab character "\t" at the head of line'
        if not char or (char!='\n' and char!='\r') then break
      else break
    if not char
      type = EOI; lexIndent = -1
    else
      lexIndent = cursor-lineStart
      if lexIndent>indent then type = INDENT
      else if lexIndent<indent then type = UNDENT
      else type = NEWLINE
    type

  # the token leaded by '\n', '\r', maybe return token with type NEWLINE, INDENT, UNDENT, EOI
  tokenFnMap['\n'] = tokenFnMap['\r'] = tokenOnNewlineChar = ->
    cur = cursor; line = lineno; column = cursor-lineStart; indent = lexIndent
    type = newLineAndEmptyLines()
    return token.next = {type:type, value:text[cur...cursor],
    cursor:cur, stopCursor:cursor,
    line:line, column:column, indent:lexIndent}

  identifierCharSet = taijiIdentifierCharSet

  tokenOnIdentifierChar = ->
    cur = cursor; char = text[++cursor]; column = cursor-lineStart
    while char and identifierCharSet[char] then char=text[++cursor]
    if char=='=' and text[cursor-1]=='!' then char = text[--cursor]
    txt = text.slice(cur, cursor)
    if keywordHasOwnProperty(txt) then type = KEYWORD; isAtom = false
    else if conjunctionHasOwnProperty(txt) then type = CONJUNCTION; isAtom = false
    else type = IDENTIFIER; isAtom = true
    token.next = {type:type, value:txt, atom:isAtom
    cursor:cur, stopCursor: cursor,
    line: lineno, column: column}

  for c of firstIdentifierCharSet then tokenFnMap[c] = tokenOnIdentifierChar

  tokenOnNumberChar = ->
    cur = cursor; base = 10; column = cursor-lineStart
    if char=='0' and c2 = text[cursor+1]
      if c2=='b' or c2=='B' then base = 2; baseStart = cursor += 2; char = text[cursor]
      else if c2=='x' or c2=='X' then base = 16; baseStart = cursor += 2; char = text[cursor]
      else char = text[++cursor]; meetDigit = true; baseStart = cursor
    else meetDigit = true; baseStart = cursor
    if base==2
      while char
        if char=='0' or char=='1' then char = text[++cursor]
        else break
    else if base==16
      while char
        if  not('0'<=char<='9' or 'a'<=char<='f' or 'A'<=char<='F') then break
        else char = text[++cursor]
    if base==2
      if char=='.' or char=='e' or char=='E' then lexError 'binary number followed by ".eE"'
      else if '2'<=char<='9' then lexError 'binary number followed by 2-9'
    if base==16
      if char=='.' then lexError 'hexadecimal number followed by "."'
      else if letterCharSet[char] then lexError 'hexadecimal number followed by g-z or G-Z'
    if base!=10
      if cursor==baseStart
        # e.g 0x+3, 0x(1+2)
        cursor--; char = text[cursor]
        return token.next = { type: NUMBER, value:parseInt(text[baseStart...cursor], base), atom:true
        cursor:cur, stopCursor:cursor
        line:lineno, column:column}
      else
        return token.next = { type: NUMBER, value:parseInt(text[baseStart...cursor], base), atom:true
        cursor:cur, line:lineno, column: column}
    # base==10
    while char
      if '0'<=char<='9' then meetDigit = true; char = text[++cursor]
      else break
    # if not meetDigit then return symbol() # comment because in no matchToken solution
    if not meetDigit then return
    if char=='.'
      meetDigit = false
      char = text[++cursor]
      while char
        if char<'0' or '9'<char then break
        else meetDigit = true; char = text[++cursor]
    dotCursor = cursor-1
    if not meetDigit and char!='e' and char!='E'
      cursor = dotCursor; char = text[cursor]
      return token.next = { type: NUMBER, value:parseInt(text[baseStart...cursor], base), atom:true
      cursor:cur, stopCursor:cursor
      line:lineno, column: column}
    if char=='e' or char=='E'
      char = text[++cursor]
      if char=='+' or char=='-'
        char = text[++cursor]
        if not char or char<'0' or '9'<char
          cursor = dotCursor; char = text[cursor]
          return token.next = { type: NUMBER, value:parseInt(text[cur...dotCursor], base), atom:true
          cursor:cur, stopCursor:cursor
          line:lineno, column: column}
        else
          while char
            char = text[++cursor]
            if  char<'0' or '9'<char then break
      else if not char or char<'0' or '9'<char
        cursor = dotCursor; char = text[cursor]
        return token.next = { type: NUMBER, value:parseInt(text[cur...dotCursor], base), atom:true
        cursor:cur, stopCursor:cursor
        line:lineno, column: column}
      else while char
          if  char<'0' or '9'<char then break
          char = text[++cursor]
    token.next = { type: NUMBER, value:parseFloat(text[cur...cursor], base), atom:true
    cursor:cur, stopCursor:cursor
    line:lineno, column: column}

  for c in '0123456789' then tokenFnMap[c] = tokenOnNumberChar

  tokenFnMap[','] =tokenOnCommaChar = ->
    cur = cursor; char = text[++cursor]
    token.next = {type:PUNCTUATION, value:',', line:lineno, cursor:cursor, stopCursor:cursor, column: cur-lineStart}

  tokenFnMap[';'] = tokenOnSemiColonChar = ->
    cur = cursor; char = text[++cursor]
    token.next = {value:';', type:PUNCTUATION
    cursor:cursor, stopCursor:cursor, line:lineno, column: cur-lineStart}

  # whether new line character is immediately following a concatenating character '\'
  # this is not affected embedded concatenated line in other structure.
  concatenating = false

  tokenFnMap["'"] = tokenOnSingleQuoteChar = ->
    char = text[++cursor]; column = cursor-lineStart
    if char=="'"
      if text[cursor+1]=="'"
        cursor += 2; char = text[cursor]
        return token.next = leftRawNonInterpolatedString()
      else
        char = text[++cursor]
        return token.next = {value:'""', type:NON_INTERPOLATE_STRING, atom:true, cursor:cursor-2, line:lineno, column:column}
    else return token.next = leftNonInterpolatedString()

  leftRawNonInterpolatedString = ->
    cur = cursor-3; line = lineno
    if cursor==indent+3 then indentInfo = {indent:lexIndent}
    else indentInfo = {}
    str = ''
    # the left characters of the same line after '''
    while char
      if char=="'"
        if text[cursor+1]=="'"
          if text[cursor+2]=="'"
            cursor += 3; char = text[cursor]
            return {type:NON_INTERPOLATE_STRING, value:'"'+str+'"', atom:true, start:cur, stop:cursor, line:line, stopLine: lineno}
          else str += "''"; cursor += 2; char = text[cursor]
        else str += "'"; char = text[++cursor]
      else if char=='\\'
        # the '\' at end of line will not in the result string
        if (c=text[cursor+1])=='\n' or c=='\r'
          char = text[++cursor]; concatenating = true; break
        else str += '\\\\'; char = text[++cursor]
      else if char!='\n' and char!='\r' then str += char; char = text[++cursor]
      else break
    while char
      if char=="'"
        if text[cursor+1]=="'"
          if text[cursor+2]=="'"
            cursor += 3; char = text[cursor]
            return {type: NON_INTERPOLATE_STRING, value: '"'+str+'"', atom:true, start:cur, stop:cursor, line:line, stopLine: lineno}
          else str += "''"; cursor += 2; char = text[cursor]
        else str += "'"; char = text[++cursor]
      else str += rawNonInterpolatedStringLine(indentInfo)
    if not text[cursor] then lexError "expect ''', unexpected end of input while parsing interpolated string"

  rawNonInterpolatedStringLine = (indentInfo) ->
    result = ''
    # new line character must be escaped.
    if char=='\n'
      if not concatenating then result += '\\n'
      char = text[++cursor]
      if char=='\r'
        if not concatenating then result += '\\r'
        char = text[++cursor]
    else
      if not concatenating then result += '\\r'
      char = text[++cursor]
      if char=='\n'
        if not concatenating then result += '\\n'
        char = text[++cursor]
    concatenating = false
    lineno++; cur = cursor
    while char==' ' then char = text[++cursor]
    column = cursor-lineStart
    if char=='\t' then lexError 'unexpected tab character "\t" at the head of line'
    else if char=='\n' or char=='\r' then result += text[cur...cursor]; return result
    else if (ind=indentInfo.value)!=undefined then indentInfo.value = column
    else if ind>column then i = 0; n = column-ind; while i++<n then result += ' '
    else if ind<column then lexError 'expect equal to or more than the indent of first line of the string'
    while char
      if char=="'"
        if text[cursor+1]=="'"
          if text[cursor+2]=="'" then return result
          else result += '\\"\\"'; cursor += 2; char = text[cursor]
        else result += '\\"'; char = text[++cursor]
      else if char=='\n' or char=='\r' then return result
      else if char=='\\'
        char = text[++cursor]
        if char=='\n' or char=='\r' then concatenating = true; return result
        if char then result += '\\\\'
        else lexError 'unexpected end of input while parsing non interpolated string'
      # '"' must be escaped, because all the string is wrapped in "..."
      else result += char; char = text[++cursor]
    lexError 'unexpected end of input while parsing non interpolated string'

  leftNonInterpolatedString = ->
    cur = cursor-1; line = lineno; column = cur-lineStart
    if cursor==indent+1 then indentInfo = {value:indent}
    else indentInfo = {}
    str = ''
    # the left characters of the same line after '''
    while char
      if char=="'"
        char = text[++cursor]
        return {type: NON_INTERPOLATE_STRING, value: '"'+str+'"', atom:true, cursor:cur, stopCursor:cursor, line:line, stopLine:lineno, column:column}
      else if char=='\\'
        # the '\' at end of line will not in the result string
        if (c=text[cursor+1])=='\n' or c=='\r' then char = text[++cursor]; concatenating = true; break
        else if c=="'" then str += "'"; cursor += 2; char = text[cursor]
        else str += '\\'; char = text[++cursor]
      else if char!='\n' and char!='\r' then str += char; char = text[++cursor]
      else break
    while char and char!="'" then str += nonInterpolatedStringLine(indentInfo)
    if char=="'"
      char = text[++cursor]
      return {type: NON_INTERPOLATE_STRING, value: '"'+str+'"', atom:true, cursor:cur, stopCursor:cursor, line:line, stopLine:lineno, column:column}
    else lexError "expect \"'\", unexpected end of input while parsing interpolated string"

  nonInterpolatedStringLine = (indentInfo) ->
    result = ''
    if char=='\n'
      if not concatenating then result += '\\n'
      char = text[++cursor]
      if char=='\r'
        result += '\\r'
        char = text[++cursor]
    else
      if not concatenating then result += '\r'
      char = text[++cursor]
      if char=='\\n'
        if not concatenating then result += '\\n'
        char = text[++cursor]
    concatenating = false
    lineno++; cur = cursor
    while char==' ' then char = text[++cursor]
    column = cursor-lineStart
    if char=='\t' then lexError 'unexpected tab character "\t" at the head of line'
    else if char=='\n' or char=='\r' then result += text[cur...cursor]; return result
    else if (ind=indentInfo.value)!=undefined then indentInfo.value = column
    else if ind>column then i = 0; n = column-ind; while i++<n then result += ' '
    else if ind<column then lexError 'expect equal to or more than the indent of first line of the string'
    while char
      if char=="'" then return result
      else if char=='\n' or char=='\r' then return result
      else if char=='\\'
        char = text[++cursor]
        # '\' at the end of line is omitted
        if char=='\n' or char=='\r' then return result
        else if char=="'" then result += "'"; char = text[++cursor]
        else if char then result += '\\'; result += char; char = text[++cursor]
        else lexError 'unexpected end of input while parsing non interpolated string'
      else if char=='"'  then result += '\\"'; char = text[++cursor]
      else result += char; char = text[++cursor]
    lexError 'unexpected end of input while parsing non interpolated string'

  tokenFnMap['"'] = tokenOnDoubleQuoteChar = ->
    char = text[++cursor]
    if char=='"'
      if text[cursor+1]=='"'
        cursor += 2; char = text[cursor]; tkn = token
        tkn2 = leftRawInterpolateString()
        tkn.next = tkn2
        return tkn2
      else
        char = text[++cursor]
        return token.next = {value:'""', type:NON_INTERPOLATE_STRING, atom:true, line:lineno, cursor:cursor-2, column:cursor-2-lineStart}
    else
      tkn = token
      tkn2 = leftInterpolateString()
      tkn.next = tkn2
      return tkn2

  @leftRawInterpolateString = leftRawInterpolateString = ->
    cur = cursor; line = lineno
    if cursor-lineStart==indent+3 then indentInfo = {value:indent} else indentInfo = {}
    pieces = []; str = '"'
    while char
      if char=='"'
        if text[cursor+1]=='"'
          if text[cursor+2]=='"'
            cursor += 3
            if str!='"' then pieces.push str += '"'
            return {type: INTERPOLATE_STRING, value: ['string!'].concat(pieces), atom:true
            cursor:cur, stopCursor: cursor,
            line:line, stopLine: line}
          else cursor += 2; char = text[cursor]
        else str += '"'; char = text[++cursor]
      else if char=='\n'
        if not concatenating then str += '\\n'
        char = text[++cursor]
        if char=='\r'
          if not concatenating then str += '\\r'
          char = text[++cursor]
        concatenating = false
        while 1
          lineno++
          while char==' ' then str += char; char = text[++cursor]
          if char=='\n'
            str += '\\n'; char = text[++cursor]
            if char=='\r' then str += '\\r'; char = text[++cursor]
            continue
          else if char=='\r'
            str += '\\r'; char = text[++cursor]
            if char=='\n' then str += '\\n'; char = text[++cursor]
            continue
          else break
        column = cursor-lineStart
        if char=='\t' then lexError 'unexpected tab character "\t" in the head of line'
        if indentInfo.value==undefined then indentInfo.value = column
        ind = indentInfo.value
        if ind<column then lexError 'expect equal to or more than the indent of first line of the string'
        else if ind>column then i = 0; n = column-ind; while i++<n then str += ' '
      else if char=='\r'
        if not concatenating then str += '\\r'
        char = text[++cursor]
        if char=='\n'
          if not concatenating then str += '\\n'
          char = text[++cursor]
        concatenating = false
        while 1
          lineno++
          while char==' ' then str += char; char = text[++cursor]
          if char=='\n'
            str += '\\n'; char = text[++cursor]
            if char=='\r' then str += '\\r'; char = text[++cursor]
            continue
          else if char=='\r'
            str += '\\r'; char = text[++cursor]
            if char=='\n' then str += '\\n'; char = text[++cursor]
            continue
          else break
        column = cursor-lineStart
        if char=='\t' then lexError 'unexpected tab character "\t" in the head of line'
        else if (ind=indentInfo.value)!=undefined then indentInfo.value = column
        else if ind>column then i = 0; n = column-ind; while i++<n then str += ' '
        else if ind<column then lexError 'expect equal to or more than the indent of first line of the string'
      else if char=='(' or char=='{' or char=='['
        # for efficiency, do not match next token while matching delimiter token (...), [...], {...} in tokenOnLeftParenChar, tokenOnLeftBracketChar, tokenOnLeftCurveChar
        pieces.push str+'"'
        matchToken()
        pieces.push token
        str = '"'
      else if  char=='$'
        if (char=text[++cursor])
          if not firstIdentifierCharSet[char] then str += '$'
          else char = '$'; --cursor; pieces.push str+'"'; str = '"'
        else break
      else if char=='$'
        literalStart = ++cursor; char = text[cursor]
        if not firstIdentifierCharSet[char] then str += '$'
        else
          x = parser.interpolateExpression()
          if text[cursor]==':'
            char = text[++cursor]
            pieces.push str+text[literalStart...cursor]+'"'; str = '"'
          else if str!='"' then pieces.push str+'"'; str = '"'
          pieces.push x
      else if char=='\\'
        char = text[++cursor]
        if char=='\n' or char=='\r' then concatenating = true
        else if char then str += '\\\\'
        else lexError 'unexpected end of input while parsing interpolated string'
      else str += char; char = text[++cursor]
    if not text[cursor] then lexError 'expect \'"\', unexpected end of input while parsing interpolated string'

  leftInterpolateString = ->
    cur = cursor-1; line = lineno
    if cursor-1-lineStart==indent+1 then indentInfo = {value:indent} else indentInfo = {}
    pieces = []; str = '"'
    while char
      if char=='"'
        if str!='"' then pieces.push str+'"'; char = text[++cursor]
        return {type: INTERPOLATE_STRING, value: ['string!'].concat(pieces), atom:true
        cursor:cur, stopCursor:cursor,
        line:line, stopLine: lineno}
      else if char=='\n'
        if not concatenating then str += char
        char = text[++cursor]
        if char=='\r'
          if not concatenating then str += char
          char = text[++cursor]
        concatenating = false
        while 1
          lineno++
          while char==' ' then str += char; char = text[++cursor]
          if char=='\n'
            str += char; char = text[++cursor]
            if char=='\r' then str += char; char = text[++cursor]
            continue
          else if char=='\r'
            str += char; char = text[++cursor]
            if char=='\n' then str += char; char = text[++cursor]
            continue
          else break
        column = cursor-lineStart
        if char=='\t' then lexError 'unexpected tab character "\t" in the head of line'
        else if indentInfo.value==undefined then indentInfo.value = column
        else
          ind = indentInfo.value
          if ind>column then i = 0; n = column-ind; while i++<n then result += ' '
          else if ind<column then lexError 'expect equal to or more than the indent of first line of the string'
      else if char=='\r'
        if not concatenating then str += char
        char = text[++cursor]
        if char=='\n'
          if not concatenating then str += char
          char = text[++cursor]
        concatenating = false
        while 1
          lineno++
          while char==' ' then str += char; char = text[++cursor]
          if char=='\n'
            str += char; char = text[++cursor]
            if char=='\r' then str += char; char = text[++cursor]
            continue
          else if char=='\r'
            str += char; char = text[++cursor]
            if char=='\n' then str += char; char = text[++cursor]
            continue
          else break
        column = cursor-lineStart
        if char=='\t' then lexError 'unexpected tab character "\t" in the head of line'
        else if indentInfo.value==undefined then indentInfo.value = column
        else
          ind = indentInfo.value
          if ind>column then i = 0; n = column-ind; while i++<n then result += ' '
          else if ind<column then lexError 'expect equal to or more than the indent of first line of the string'
      else if char=='$'
        literalStart = ++cursor; char = text[cursor]
        if not firstIdentifierCharSet[char] then str += '$'
        else
          x = parser.interpolateExpression()
          if text[cursor]==':'
            char = text[++cursor]
            pieces.push str+text[literalStart...cursor]+'"'; str = '"'
          else if str!='"' then pieces.push str+'"'; str = '"'
          pieces.push x
      else if char=='(' or char=='{' or char=='['
        # for efficiency, do not match next token while matching delimiter token (...), [...], {...} in tokenOnLeftParenChar, tokenOnLeftBracketChar, tokenOnLeftCurveChar
        pieces.push str+'"'
        matchToken()
        pieces.push token
        str = '"'
      else if char=='\\'
        if not (char=text[++cursor]) then break
        else if char=='\n' or char=='\r' then char = text[++cursor]; concatenating = true
        else str += '\\'+char; char = text[++cursor]
      else str += char; char = text[++cursor]
    if not text[cursor] then lexError 'expect \'"\', but meet end of input while parsing interpolated string'

  # for efficiency, in tokenOnLeftParenChar, tokenOnLeftBracketChar, tokenOnLeftCurveChar
  # do not match next token while matching delimiter token (...), [...], {...}
  tokenFnMap['('] = tokenOnLeftParenChar = ->
    cur = cursor; line = lineno; column = cursor-lineStart; char = text[++cursor] # skip "("
    prev = token; matchToken()
    if (parenVariantFn=parenVariantMap[token.value])
      prev.next = token = parenVariantFn(); token.cursor = cursor; token.line = line; token.column = column; token.indent = lexIndent
    else
      if (type=token.type)==UNDENT then lexError 'unexpected undent while parsing parenethis "(...)"'
      ind = indent = lexIndent
      if type==SPACE or type==NEWLINE or type==INDENT then matchToken()
      if token.value==')'
        token = {type: PAREN, value:[], atom:true, cursor:cur, stopCursor: cursor, line:lineno, column:column, indent:lexIndent, empty:true, parameters:true }
        prev.next = token
        return token
      exp = parser.operatorExpression()
      if token.type==UNDENT
        if token.indent<ind then lexError 'expect ) indent equal to or more than ('
        else matchToken()
      else
        if token.type==SPACE then nextToken()
        if token.value!=')' then lexError 'expect )'
      # To make interpolated string happy, we can not call nextToken() here
      #else matchToken() # do not match token here, so token.next==undefined, and nextToken() will matchToken instead.
      prev.next = token = {type:PAREN, value:exp, cursor:cur, stopCursor:cursor, line:line, column:column, indent:lexIndent, atom:true, parameters:true}

  parenVariantMap = {
  }

  tokenFnMap['['] = tokenOnLeftBracketChar = ->
    cur = cursor; char = text[++cursor]; line = lineno; column = cursor-lineStart
    prev = token; matchToken()
    if (bracketVariantFn=bracketVariantMap[token.value])
      token = bracketVariantFn(); token.cursor = cursor; token.line = lineno; token.column = column; token.indent = indent
    else
      expList = parser.block() or parser.lineBlock()
      if token.type==UNDENT
        if token.indent<ind then lexError 'unexpected undent while parsing parenethis "[...]"'
        else matchToken()
      if token.value!=']' then lexError 'expect ]'
      # To make interpolated string happy, we can not call nextToken() here
      if expList then expList.unshift 'list!'
      else expList = []
      token = {type: BRACKET, value:expList, cursor:cur, stopCursor: cursor, line:line, column:column, indent:lexIndent}
    prev.next = token; token.atom = true
    token

  bracketVariantMap = {}

  tokenFnMap['{'] = ->
    cur = cursor; char = text[++cursor]; line = lineno; column = cursor-lineStart; ind = lexIndent
    prev = token; matchToken()
    if (curveVariantFn=curveVariantMap[token.value])
      prev.next = token = curveVariantFn()
      token.cursor = cur; token.stopCursor = cursor; token.line = line; token.stopLine = lineno; token.column = column
      token.indent = lexIndent
      return token
    else
      if token.type==SPACE then nextToken()
      if token.value=='}' and tkn=matchToken()
        token = {value:text[cur...cursor], value:['hash!'], cursor:cur, line:line, column:column, indent:lexIndent, next:tkn}
        prev.next = token
        return token
      body = parser.block() or parser.lineBlock()
      if token.type==UNDENT and token.indent<ind then nextToken()
      if token.value!='}' then lexError 'expect }'
      # To make interpolated string happy, we can not call nextToken() here
      if indent<ind then lexError 'unexpected undent while parsing parenethis "{...}"'
      if body.length==0 then return {type: CURVE, value:'', cursor:cur, stopCursor:cursor, line:line, column:column, indent:lexIndent}
      if body.length==1 then body = body[0]
      else body.unshift 'begin!'
    prev.next = token = {type: CURVE, value:body, atom:true, cursor:cur, stopCursor:cursor, line:line, column:column, indent:lexIndent}

  curveVariantMap =
    '.': ->  matchToken(); return parser.hash()

  @hash = ->
    start = token; ind = indent
    if token.type==SPACE
      if token.stopLine==token.line
        matchToken()
        items = hashLineBlock(ind)
      else items = hashBlock(ind)
    else if token.type==INDENT
      matchToken()
      items = parser.hashBlock(ind)
    else items = hashLineBlock(ind)
    if token.type==UNDENT then matchToken()
    if token.indent<ind then lexError "expect the same indent as or more indent as the start line of hash block"
    if token.value!='}' then lexError 'expect }'
    matchToken()
    extendSyntaxInfo {value:['hash!'].concat(items), atom:true}, start, token

  hashLineBlock = (dent) ->
    items = hashLine(dent)
    if token.type==INDENT then nextToken()
    else if token.type==UNDENT
      if token.indent<=dent then return items
      else nextToken()
    items.push.apply items, hashBlock(indent)
    items

  hashLine = ->
    result = []
    while (x=parser.hashItem())
      result.push x
      if (value=token.value)==';' then matchToken(); if token.type==SPACE then matchToken()
      else if (type=token.type)==NEWLINE then matchToken(); break
      else if type==UNDENT or value=='}' then break
      else if type==EOI then lexError "unexpected end of input while parsing hash block"
    return result

  hashBlock = ->
    start = token; result = []
    while (items=hashLine())
      result.push.apply result, items
      if (type=token.type)==EOI then lexError "unexpected end of input while parsing hash block"
      else if type==UNDENT then break
      else if (value=token.value)==';' then matchToken()
      else if value=='}' then break
      if token.type==INDENT
        if token.isComment
          blk = parser.hashBlock()
          result.push.apply result, blk
        else lexError "unexpected indent while parsing hash block"
    result.start = start; result.stop = token; result

  @hashItem = hashItem = ->
    if token.type==UNDENT then return
    start = token
    if key=parser.hashKeyExpression()
      if (type=token.type)==NEWLINE or type==UNDENT then lexError 'unexpected new line after hash key'
      else if type==EOI then "unexpected end of input after hash key"
      else if type==SPACE then matchToken()
      if (value=token.value)==':' and matchToken()
        if (t=key.type)==IDENTIFIER or t==NUMBER or t==NON_INTERPOLATE_STRING then js = true
      else if value=='->' then matchToken()
      else lexError 'expect : or -> for hash item definition'
      if token.type==SPACE then matchToken()
      if token.type==INDENT
        matchToken()
        tkn = token
        blk = hashBlock()
        value = {value:['hash!'].concat(blk), start:tkn, stop:token}
      else value = parser.clause()
      if not value then lexError 'expect value of hash item'
      if js then result = ['jshashitem!', key, value]
      else result = ['pyhashitem!', key, value]
      extendSyntaxInfo result, start, token

  tokenOnRightDelimiterChar = ->
    c = char; cur = cursor; char = text[++cursor]
    token.next = {type:RIGHT_DELIMITER, value:c, cursor:cur, stopCursor:cursor,
    line:lineno, column:cur-lineStart}

  for c in ')]}' then tokenFnMap[c] = tokenOnRightDelimiterChar

  @setText = (x) -> parser.text = text = x; x
  @cursor = -> cursor
  @setCursor = (x) -> cursor = x
  @atStatementHead = -> atStatementHead
  @setAtStatementHead = (x) -> atStatementHead = x
  @endOfInput = -> not text[cursor]

  spaces = ->
    cur = cursor
    while char==' ' or char=='\t' then char = text[++cursor]
    {value:text[cur...cursor]}

  # c should not be \n \r
  matchChar = (c) -> if char==c then char = text[++cursor]; true

  @literal = literal = (string) ->
    length = string.length
    if text[cursor...cursor+length]==string then cursor += length; char = text[cursor]; true

  @decimal = decimal = ->
    cur = cursor
    while '0'<=char<='9' then char = text[++cursor]
    if cursor==cur then return
    {value: text[cur...cursor], cursor:cur}

  # prefix operator don't need to be compared to current global priority
  @prefixOperator = (mode) ->
    # hasOwnProperty.call is necessary in order to avoid error while builtin attribute of object is defined prefix operator
    tokenText = token.value
    if not hasOwnProperty.call(prefixOperatorDict, tokenText) or  not (op=prefixOperatorDict[tokenText]) then return
    if (mode==COMPACT_CLAUSE_EXPRESSION or mode==SPACE_CLAUSE_EXPRESSION) and op.definition then return
    if token.escaped then return
    opToken = token; nextToken()
    if (type=token.type)==INDENT then syntaxError 'unexpected indent after prefix operator'
    else if type==NEWLINE then syntaxError 'unexpected new line after prefix operator'
    else if type==UNDENT then syntaxError 'unexpected undent after prefix operator'
    else if (tokenText=token.value)==")" or tokenText==']' or tokenText=="}" then syntaxError 'unexpected '+tokenText+' after prefix operator'
    else if type==SPACE
      if op.definition and mode==SPACE_CLAUSE_EXPRESSION then token = start; return
      matchToken(); priInc = 300
    else
      priInc = 600
      if token.value=='.'
        nextToken()
        if (type=token.type)==SPACE or type==NEWLINE or type==UNDENT or type==INDENT or type==EOI
          lexError 'unexpected spaces or new lines or end of lines after compact prefix Operaotr and "."'
    opToken.symbol = op.symbol; opToken.priority = op.priority+priInc
    extendSyntaxInfo opToken, opToken

  # suffix operator must be symbol, should follow space, right delimiters or punctuations.
  @suffixOperator = (mode, x) ->
    if token.type!=SYMBOL then return
    if (op=suffixOperatorDict[token.value])
      token.symbol = op.symbol; token.priority = op.priority+600
      opToken = token; matchToken()
      #  can not follow suffirx: SYMBOL IDENTIFIER  REGEXP PAREN BRACKET HASH etc
      if (type=token.type)==SPACE or type==NEWLINE or type==INDENT or type==UNDENT or type==EOI or type==RIGHT_DELIMITER\
          or (value=token.value)==':' or value==',' or value==';'
        extendSyntaxInfo opToken, opToken
      else token = opToken; return

  binaryOperatorMemoIndex = memoIndex
  memoIndex += 5

  @binaryOperator = (mode, x) ->
    if m=token[binaryOperatorMemoIndex+mode] then token = m.next or token; return m.result
    start = token
    switch type1=token.type
      when EOI, RIGHT_DELIMITER then token[binaryOperatorMemoIndex+mode] = {}; return
      when NEWLINE then priInc = 0; nextToken()
      when UNDENT
        if mode!=OPERATOR_EXPRESSION then token[binaryOperatorMemoIndex+mode] = {}; return
        else priInc = 0; nextToken()
      when INDENT
        if mode!=OPERATOR_EXPRESSION and mode!=INDENT_EXPRESSION
          token[binaryOperatorMemoIndex+mode] = {}; return
        else priInc = 0; nextToken()
      when SPACE
        if mode==COMPACT_CLAUSE_EXPRESSION then token[binaryOperatorMemoIndex+mode] = {}; return
        else
          start = token; nextToken()
          if token.type!=IDENTIFIER and token.type!=SYMBOL and token.type!=PUNCTUATION then start[binaryOperatorMemoIndex+mode] = {}; token = start; return
          if token.value=='.'
            if nextToken() and token.type==SPACE and nextToken()
              return {symbol:'attribute!', type: SYMBOL, priority: 800, start:start}
            else token[binaryOperatorMemoIndex+mode] = {}; token = start; return
          else priInc = 300
      when PUNCTUATION
        if mode!=OPERATOR_EXPRESSION and mode!=INDENT_EXPRESSION
          token[binaryOperatorMemoIndex+mode] = {}; return
        else priInc = 600
      when PAREN
        return  {symbol:'call()', type: SYMBOL, priority: 800, start:token}
      when BRACKET then return {symbol:'index[]', type: SYMBOL, priority: 800, start:token}
      when IDENTIFIER
        cur = token.cursor
        if (x.value=='@' and x.stopCursor==cur) or (text[cur-2...cur]=='::' and text[cur-3]!=':')
          return {symbol:'attribute!', type: SYMBOL, priority: 800, start:token}
        else start[binaryOperatorMemoIndex+mode] = {}; return
      when SYMBOL
        tkn = token
        if (value=tkn.value)=='#' and nextToken() then return {symbol:'#()', type: SYMBOL, priority: 800, start:tkn}
        else if value=='::' then return {symbol:'attribute!', type: SYMBOL, start:tkn, priority: 800}
        else if value=="." and (tkn=token) and nextToken()
          if (type=token.type)==IDENTIFIER then return {symbol:'attribute!', type: SYMBOL, start:tkn, priority: 800}
          else if type==SPACE or type==NEWLINE or type==INDENT or type==UNDENT or type==EOI
            if mode==OPERATOR_EXPRESSION then syntaxError 'unexpected space or new line or end of line after "."'
            else token = tkn; return
          else if type==NUMBER or type==NON_INTERPOLATE_STRING or type==INTERPOLATE_STRING
            return {symbol:'index!', type: SYMBOL, start:tkn, priority: 800}
          else priInc = 600
        else priInc = 600
      else priInc = 600
    opValue = token.value
    if (mode==COMPACT_CLAUSE_EXPRESSION or mode==SPACE_CLAUSE_EXPRESSION) and opValue==',' or opValue==';' or opValue==':'
      start[binaryOperatorMemoIndex+mode] = {}
      token = start; return

    if not hasOwnProperty.call(binaryOperatorDict, opValue)
      start[binaryOperatorMemoIndex+mode] = {}
      token = start; return
    op = binaryOperatorDict[opValue]
    if (op.definition or op.assign) and mode==SPACE_CLAUSE_EXPRESSION
      start[binaryOperatorMemoIndex+mode] = {}
      token = start; return
    if op.value=='->' then start[binaryOperatorMemoIndex+mode] = {}; token = start; return

    opToken = token; nextToken()

    if token.value=='.'
      if priInc==300 then syntaxError 'unexpected "." after binary operator '+opToken.value+', here should be spaces, comment or newline'
      else nextToken()

    switch token.type
      when SPACE
        if priInc==600
          if opValue==',' then priInc = 300; nextToken()
          else syntaxError 'unexpected spaces or new lines after binary operator "'+opValue+'" before which there is no space.'
        else if priInc==300 then nextToken()
        else
          nextToken()
          if type1==INDENT then indentExpression()
      when NEWLINE
        if opValue!=',' then syntaxError 'unexpected new line after binary operator '+opValue
        else if priInc==0 then syntaxError 'a single binary operator should not occupy whole line.'
        else priInc = 0
      when UNDENT
        if mode!=OPERATOR_EXPRESSION then syntaxError 'unexpected undent after binary operator '+opValue
        else return
      when INDENT
        if opValue!=',' then syntaxError 'unexpected indent after binary operator '+opValue
        priInc = 0; indentExpression()
      when EOI
        if mode!=OPERATOR_EXPRESSION then syntaxError 'unexpected end of input, expect right operand after binary operator'
      when RIGHT_DELIMITER
        if mode!=OPERATOR_EXPRESSION then  start[binaryOperatorMemoIndex+mode] = {}; return
        else syntaxError 'unexpected '+token.value
      when PUNCTUATION
        if mode!=OPERATOR_EXPRESSION then return
        else if priInc!=0 then syntaxError 'unexpected '+token.value
        if priInc==0
          if opValue==',' or opValue==':' then syntaxError 'binary operator '+op.symbol+' should not be at begin of line'
      else
        if priInc==300
          if mode==OPERATOR_EXPRESSION then syntaxError 'binary operator '+opValue+' should have spaces at its right side.'
          else token = start; start[binaryOperatorMemoIndex+mode] = {}; return
        else if priInc==0
          if opValue=='%' or op.assign then syntaxError 'binary operator '+opValue+' should not be at begin of line'
          if type1==INDENT then indentExpression()

    opToken.symbol = op.symbol; pri = op.priority+priInc
    opToken.assign = op.assign; opToken.rightAssoc = op.rightAssoc
    # any operator near newline always have the priority 300, i.e. compute from up to down
    if pri<300 then pri = 300; opToken.rightAssoc = false
    opToken.priority = pri
    start[binaryOperatorMemoIndex+OPERATOR_EXPRESSION] = {result:opToken, next:token}
    opToken

  indentExpression = ->
    indentExp = parser.expression(INDENT_EXPRESSION, 0, true)
    if (type=token.type)!=UNDENT and type!=EOI and token.value!=')'
      syntaxError 'expect an undent after a indented block expression'
    indentExp.priority = 1000
    indentExp[expressionMemoIndex+OPERATOR_EXPRESSION] = {result:indentExp, next:token}
    token = indentExp

  @prefixExpression = (mode, priority) ->
    start = token
    # current global prority doesn't affect prefixOperator
    if op=parser.prefixOperator(mode)
      pri = if priority>op.priority then priority else op.priority
      x = parser.expression(mode, pri, true)
      if x then extendSyntaxInfo makeExpression(PREFIX, op, x)
      else token = start; return

  expressionMemoIndex = memoIndex
  memoIndex += 5
  @expression = expression = (mode, priority, leftAssoc) ->
    indexMode = expressionMemoIndex+mode; start = token
    if m=start[indexMode] then token = m.next or token; return m.result
    if not x = parser.prefixExpression(mode, priority)
      if not token.atom then start[memoIndex+mode] = {}; return
      else x = token; x.priority = 1000; x.start = x; nextToken()
    while 1
      tkn1 = token
      if (op = parser.suffixOperator(mode, x))
        if op.priority>=priority
          x = makeExpression(SUFFIX, op, x)
        else token = tkn1; break
      else break
    # the priority and association of suffix operator does not affect the following expression
    while 1
      tkn2 = token
      if (op=parser.binaryOperator(mode, x))
        if (opPri=op.priority)>priority  or (opPri==priority and not leftAssoc)
          # should assure that a right operand is here while parsing binary operator
          y = expression(mode, opPri, not op.rightAssoc)
          if y then x = makeExpression(BINARY, op, x, y)
          else token = tkn2; break
        else token = tkn2; break
      else break
    if token!=tkn1
      while 1
        tkn = token
        if (op = parser.suffixOperator(mode, x))
          if op.priority>=priority
            x = makeExpression(SUFFIX, op, x)
          else token = tkn; break
        else break
    start[indexMode] = {result:x, next:token}
    x

  # the priority of operator vary from 0 to 300,
  # if there is no space between them, then add 600, if there is spaces, then add 300.
  # if meet newline, add 0.
  @operatorExpression = operatorExpression = -> parser.expression(OPERATOR_EXPRESSION, 0, true)

  # compact expression as clause item.
  @compactClauseExpression = ->
    result = parser.expression(COMPACT_CLAUSE_EXPRESSION, 600, true)
    if result then result.atom = true
    result

  # compact expression as clause item.
  @hashKeyExpression = -> parser.expression(HASH_KEY_EXPRESSION, 600, true)

  # space expression as clause item.
  @spaceClauseExpression = spaceClauseExpression = ->
    if token.type==SPACE then nextToken()
    parser.expression(SPACE_CLAUSE_EXPRESSION, 300, true)

  # interpolate expression embedded in string
  @interpolateExpression = ->
    exp = tokenOnIdentifierChar()
    exp.start = exp.stop = start = exp
    while 1
      cur = cursor
      if (char=text[cursor])=='.'
        if char=text[++cursor] and firstIdentifierCharSet[char] and (id=tokenOnIdentifierChar())
          exp = ['attribute!', exp, id]
          id.start = id; id.stop = id; exp.start = start; exp.stop = id
        else break
      else if char=='['
        if (tkn=tokenOnLeftBracketChar()) and token.type==BRACKET
          exp = ['index!', exp, tkn]
          exp.start = start; exp.stop = tkn
        else lexError 'error while parsing "[" leading interpolate expression in double qoute string'
      else cursor = cur; break
    exp

  @itemToParameter = itemToParameter = (item) ->
    if item.type==IDENTIFIER then return item
    else if item0=item[0]
      if item0=='attribute!' and item[1].text=='@' then return item
      else if item0.symbol=='x...'
        parser.meetEllipsis = item[1].ellipsis = true
        return item
      else if entity(item0)=='=' # default parameter
        # default parameter should not be ellipsis parameter at the same time
        # and this is the behavior in coffee-script too
        # and (item01[0].symbol!='x...' or not isIdentifier(item01[1]).type==IDENTIFIER)
        if (item1=item[1]) and item1.type==IDENTIFIER then return item
        else if ((item10=item1[0]) and item10=='attribute!' and item1[1].text=='@') then return item
        else return
      # for dynamic parser and writing macro
      else if item0.symbol=='unquote!' or item0.symbol=='unquote-splice'
        return item

  @toParameters = toParameters = (item) ->
    if not item then return []
    if x=itemToParameter(item) then return [x]
    else if item[0]==','
      result = for x in item[1...]
        if not(param=itemToParameter(x)) then meetError = true; break
        if param.ellipsis
          if meetEllipsis then meetError = true; break
          else meetEllipsis = true
        param
      if not meetError then result

  expectThen = (isHeadStatement, clauseIndent) ->
    if token.type==SPACE then nextToken()
    if atStatementHead and not isHeadStatement then syntaxError 'unexpected new line before "then" of inline keyword statement'
    if token.type==INDENT then syntaxError 'unexpected indent before "then"'
    else if token.type==EOI
      syntaxError 'unexpected end of input, expect "then"'
    if token.type==NEWLINE then nextToken()
    else if token.type==UNDENT and token.indent>=clauseIndent then nextToken()
    if atStatementHead and indent!=clauseIndent then syntaxError 'wrong indent before "then"'
    if token.type==CONJUNCTION
      if token.value=="then" then nextToken(); return true
      else syntaxError 'unexpected conjunction "'+token.value+'", expect "then"'
    else syntaxError 'expect "then"'

  maybeConjunction = (conj, isHeadStatement, clauseIndent) ->
    if atStatementHead and not isHeadStatement then return
    if token.type==EOI then return
    if indent<clauseIndent then return
    if indent>clauseIndent then syntaxError 'wrong indent'
    if indent==clauseIndent and token.type==CONJUNCTION and token.value==conj
      conj = token; nextToken(); return conj

  maybeIndentConjunction = (conj, isHeadStatement, parentIndent, myIndent) ->
    ind = myIndent.indent
    if token.type==INDENT then nextToken()
    else if token.type==NEWLINE then nextToken()
    if token.type==SPACE then nextToken()
    if ind
      if indent<ind then return
      else if indent>ind then syntaxError 'wrong indent before matching conjunction'
    else if atStatementHead
      if indent<=parentIndent then return
      else myIndent.indent = indent
    if token.type==CONJUNCTION and token.value==conj then nextToken()

  # if test then action else action
  keywordThenElseStatement = (keyword) -> (isHeadStatement) ->
    start = token; ind = indent; nextToken(); if token.type==SPACE then nextToken()
    if not (test=parser.clause()) then syntaxError 'expect a clause after "'+keyword+'"'
    expectThen(isHeadStatement, ind)
    then_ = parser.block() or parser.line()
    if then_.length==1 then then_ = then_[0]
    else if then_.length==0 then then_ = undefined
    else then_.unshift 'begin!'
    if token.type==NEWLINE then tkn = token; nextToken()
    if maybeConjunction('else', isHeadStatement, ind)
      else_ = parser.block() or parser.line()
      if else_.length==1 then else_ = else_[0]
      else if else_.length==0 then else_ = undefined
      else else_.unshift 'begin!'
    else if tkn then token = tkn
    if else_ then {value:[keyword, test, then_, else_], start:start, stop:token}
    else {value:[keyword, test, then_], start:start, stop:token}

  # whileTestStatement
  whileTestStatement = (keyword) -> (isHeadStatement) ->
    start = token; nextToken()
    if token.type==SPACE then nextToken()
    if not (test=parser.compactClauseExpression())
      error "expect compact clause expression to be used as condition"
    body = parser.block() or parser.line()
    if body.length==1 then body = body[0]
    else if body.length==0 then body = undefined
    else body.unshift 'begin!'
    {value:[keyword, test, body], start:start, stop:token}

  # throw or return value
  throwReturnStatement = (keyword) -> (isHeadStatement) ->
    start = token; nextToken()
    if token.type==SPACE then nextToken()
    if clause = parser.clause() then {value:[keyword, clause], start:start, stop:token}
    else {value:[keyword], start:start, stop:token}

  # break; continue
  breakContinueStatement = (keyword) -> (isHeadStatement) ->
    start = token; nextToken()
    if token.type==SPACE then nextToken()
    if token.type==IDENTIFIER
      label = token; nextToken()
      if token.type==SPACE then nextToken()
      {value:[keyword, label], start:start, stop:token}
    else
      if token.type==SPACE then nextToken()
      {value:[keyword], start:start, stop:token}

  letLikeStatement = (keyword) -> (isHeadStatement) ->
    start = token; nextToken(); ind = indent; if token.type==SPACE then nextToken()
    varDesc = parser.varInitList() or parser.clause()
    expectThen(isHeadStatement, ind)
    body = parser.block() or parser.line()
    if body.length==1 then body = body[0]
    else if body.length==0 then body = 'undefined'
    else body.unshift 'begin!'
    {value:[keyword, varDesc, body], start:start, stop:token}

  # no cursor and lineno is attached in result, so can not be memorized directly.
  @identifierLine = ->
    result = []
    if token.type==SPACE then nextToken()
    while not parser.lineEnd() and not follow('newline') and text[cursor]!=';'
      if x=parser.identifier() then result.push x
      else syntaxError 'expect an identifier'
      if token.type==SPACE then nextToken()
    result

  # no cursor and lineno is attached in result, so can not be memorized directly.
  @identifierList = ->
    line1 = lineno; indentCol = lineInfo[line1].indentCol
    result = parser.identifierLine()
    spac = bigSpace();
    if (col0=lineInfo[lineno].indentCol)<=indentCol
      rollbackToken spac; return result
    if text[cursor]==';' then return result
    while varList=parser.identifierLine()
      result.push.apply result, varList
      spac = bigSpace()
      if (column=lineInfo[lineno].indentCol)<=indentCol then rollbackToken spac; break
      else if column!=col0 then syntaxError 'inconsistent indent of multiple identifiers lines after extern!'
      if text[cursor]==';' then break
    result

  @varInit = ->
    if token.type!=IDENTIFIER then return
    id = token; nextToken()
    if token.type==SPACE then nextToken()
    if token.value=='='
      nextToken()
      if token.type==SPACE then nextToken()
      if value=parser.block() then value = begin(value)
      else if not(value=parser.clause()) then syntaxError 'expect a value after "=" in variable initilization'
    if token.value==',' then nextToken()
    if token.type==SPACE then nextToken()
    if not value then return id
    else return {value:[id, '=', value], start:id, stop:token}

  varInitLine = ->
    result = []
    while 1
      if x=parser.varInit() then result.push x
      else break
    result

  @varInitList = ->
    ind0 = indent
    if token.type==UNDENT then syntaxError 'unexpected undent'
    else if token.type==NEWLINE then syntaxError 'unexpected new line, expect at least one variable in var statement'
    if token.type!=INDENT
      result = varInitLine()
      # if token.value==';' then nextToken() # ";" will be eaten at the end of parsing parser.sentence
    else
      nextToken(); ind1 = indent
      if token.type==SPACE then nextToken()
      result = []
      while 1
        result.push.apply result, varInitLine()
        if token.value = ';' then nextToken(); if token.type==SPACE then nextToken()
        if token.type==EOI then break
        else if token.type==UNDENT
          if indent==ind1 then continue
          else if indent==ind0 then nextToken(); break
          else if indent<ind0 then break
          else syntaxError 'unconsistent indent in var initialization block'
        else break
    result

  @importItem = ->
    start = token
    if token.type==SYMBOL
      sym = token; nextToken()
      if (symValue=sym.value)!='#' and symValue!='#/'
        syntaxError 'unexpected symbol after "as" in import! statement'
    if token.type==IDENTIFIER
      if token.value=='from'
        if sym then syntaxError 'keyword "from" should not follow "#" or "#/" immediately in import! statement, expect variable name'
        else  return
      name = token; nextToken()
    else if token.type==NON_INTERPOLATE_STRING or token.type==INTERPOLATE_STRING
      if sym
        syntaxError 'file path should not follow "#" or "#/" immediately in import! statement, expect variable name'
      else token = start; return
    if token.type==SPACE then nextToken()
    if token.type==IDENTIFIER and token.value!='from'
      if token.value!='as' then syntaxError 'unexpected word '+as_.value+', expect "as", "," or "from [module path...]"'
      as_ = token; nextToken(); if token.type==SPACE then nextToken()
      if token.type==SYMBOL and (sym2=token) and nextToken() and (symValue2=sym2.value)!='#' and symValue2!='#/'
        syntaxError 'unexpected symbol after "as" in import! statement'
      if symValue=='#/'
        if symValue2=='#' then syntaxError 'expect "as #/alias" or or "as alias #alias2" after "#/'+name.value+'"'
      else if symValue=='#'
        if not symValue then syntaxError 'meta variable can not be imported as runtime variable'
        else if symValue=='#/' then syntaxError 'meta variable can not be imported as both meta and runtime variable'
      else if not symValue
        if symValue2=='#' then syntaxError 'runtime variable can not be imported as meta variable'
        else if symValue2=='#/' then 'runtime variable can not be imported as both meta and runtime variable'
      if token.type!=IDENTIFIER then syntaxError "expect identifier"
      asName = token; nextToken(); if token.type==SPACE then nextToken()
      if symValue=='#/' and not symValue2
        if token.type!=SYMBOL then syntaxError 'expect # after "#/'+name.value+' as '+asName.value+'"'
        if token.type==SYMBOL
          sym3 = token
          if sym3.value!='#' then syntaxError 'unexpected '+sym3.value+' after "#/'+name.value+'as '+asName.value+'"'
          nextToken()
          if token.type!=IDENTIFIER then syntaxError "expect identifier"
          asName2 = token; nextToken(); if token.type==SPACE then nextToken()
    if not as_
      if symValue=='#/' then return [[name, name], [name, name, 'meta']]
      else if symValue=='#' then return [[name, name, 'meta']]
      else return [[name, name]]
    else
      if symValue=='#/'
        if asName2 then return [[name, asName], [name,asName2, 'meta']]
        else return [[name, asName], [name,asName, 'meta']]
      else if symValue=='#' then return [[name, asName, 'meta']]
      else return [[name, asName]]

  @exportItem = ->
    runtime = undefined
    if token.value=='#/' then nextToken(); runtime = 'runtime'; meta = 'meta'; if token.type==SPACE then nextToken()
    else if token.value=='#' then nextToken(); meta = 'meta'; if token.type==SPACE then nextToken()
    else runtime = 'runtime'
    if meta
      if token.type==IDENTIFIER then name = token else syntaxError 'expect identifier'
    else if token.type!=IDENTIFIER then return
    else name = token
    if token.type==SPACE then nextToken()
    if token.value=='=' and nextToken()
      if token.type==SPACE then nextToken()
      value = parser.spaceClauseExpression()
      if token.type==SPACE then nextToken()
    [name, value, runtime, meta]

  spaceComma = ->
    if token.type==SPACE then nextToken()
    if token.value==',' then nextToken(); result = true
    if token.type==SPACE then nextToken()
    result

  @seperatorList = seperatorList = (item, seperator) ->
    if typeof item=='string' then item = parser[item]
    ->
      result = []
      while x=item()
        result.push x
        if seperator() then continue
        else break
      result

  @importItemList = seperatorList('importItem', spaceComma)

  @exportItemList = seperatorList('exportItem', spaceComma)

  @keyword2statement = keyword2statement =

    'break': breakContinueStatement('break')
    'continue': breakContinueStatement('continue')
    'throw': throwReturnStatement('throw')
    'return': throwReturnStatement('return')
    'new': throwReturnStatement('new')

    'while!': whileTestStatement('while!')

    'var': (isHeadStatement) ->
      start = token; nextToken()
      if token.type==SPACE then nextToken()
      varList = parser.varInitList()
      if varList.length==0 then syntaxError 'expect variable name'
      if (type=token.type)!=NEWLINE and type!=UNDENT and type!=EOI and type!=CONJUNCTION and type!=RIGHT_DELIMITER and type!=PUNCTUATION
        syntaxError 'unexpected token after var initialization list "' + token.value+'"'
      varList.unshift 'var'
      {value:varList, start:start, stop:token}

    'extern!': (isHeadStatement) -> ['extern!'].concat parser.identifierList()

    'include!': (isHeadStatement) ->
      if token.type==SPACE then nextToken()
      filePath = expect('string', 'expect a file path')
      if token.type==SPACE then nextToken()
      if word('by')
        if token.type==SPACE then nextToken()
        parseMethod = expect('taijiIdentifier', 'expect a parser method')
      ['include!', filePath, parseMethod]

    # import [#/]name [as [#/]name] ... from path as [#/]name #name [by method]
    'import!': (isHeadStatement) ->
      start = token; nextToken()
      if token.type==SPACE then nextToken()
      items = parser.importItemList()
      if token.type==SPACE then nextToken()
      if token.type==IDENTIFIER # keyword "from"
        nextToken(); if token.type==SPACE then nextToken()
      else if items.length then syntaxError 'expect "from"'
      if token.type!=NON_INTERPOLATE_STRING then syntaxError 'expect the path of module file'
      srcModule = token; nextToken()
      if token.type==SPACE then nextToken()
      if token.value=='as'
        nextToken(); if token.type==SPACE then nextToken()
        if token.type==SYMBOL
          if (symValue=token.value) and symValue!='#' and symValue!='#/'
            syntaxError 'unexpected symbol before import module name', token
          sym = token; nextToken()
        if token.type!=IDENTIFIER then syntaxError 'expect an alias for module'
        alias = token; nextToken()
        if token.type==SPACE then nextToken()
        if symValue=='#' then metaAlias = alias; alias = undefined
        else if symValue=='#/' then metaAlias = alias
        if not metaAlias
          if token.type==SYMBOL
            if token.value!='#' then syntaxError 'unexpected symbol'
            else
              nextToken(); if token.type==SPACE then nextToken()
              if token.type==IDENTIFIER and token.value!='by'
                metaAlias = token; nextToken()
                if token.type==SPACE then nextToken()
      if token.value=='by' and nextToken()
        if token.type==SPACE then nextToken()
        if token.type!=IDENTIFIER then syntaxError 'expect parser method'
        if token.type==SPACE then nextToken()
        parseMethod = token
      runtimeImportList = []; metaImportList = []
      for item in items
        for x in item
          if x[2] then  metaImportList.push x
          else runtimeImportList.push x
      {value: ['import!', srcModule, parseMethod, alias, metaAlias, runtimeImportList, metaImportList], start:start, stop:token}

    'export!': (isHeadStatement) ->
      if token.type==SPACE then nextToken()
      ['export!'].concat parser.exportItemList()

    'let': letLikeStatement('let')
    'letrec!': letLikeStatement('letrec!')
    'letloop!': letLikeStatement('letloop!')
    'if': keywordThenElseStatement('if')
    'while': keywordThenElseStatement('while')

    'for': (isHeadStatement) ->
      start = token; ind = indent
      skipToken() # skip "for"
      skipSpace()
      if char=='(' and char=text[++cursor]
        matchToken()
        if token.type==SPACE then nextToken()
        init = parser.clause()
        if token.type==SPACE then nextToken()
        if token.value==';' then nextToken()
        else syntaxError 'expect ";"'
        if token.type==SPACE then nextToken()
        test = parser.clause()
        if token.type==SPACE then nextToken()
        if token.value==';' then nextToken()
        else syntaxError 'expect ";"'
        if token.type==SPACE then nextToken()
        step = parser.clause()
        if token.type==SPACE then nextToken()
        if token.value==')' then nextToken()
        else 'expect ")"'
        if token.type==SPACE then nextToken()
        expectThen(isHeadStatement, ind)
        body = parser.block() or parser.line()
        if body.length==1 then body = body[0]
        else if body.length==0 then body = 'undefined'
        else body.unshift 'begin!'
        return {value:['cFor!', init, test, step, body], start:start, stop:token}
      matchToken()
      if token.type!=IDENTIFIER then syntaxError 'expect identifier'
      name1 = token
      nextToken()
      if token.type==SPACE then nextToken()
      if token.value==',' # optional ","
        nextToken()
        if token.type==SPACE then nextToken()
      if token.type!=IDENTIFIER then syntaxError 'expect "in", "of" or index variable name'
      if (value=token.value)=='in' or value=='of' then inOf = value; nextToken()
      else
        name2 = token; nextToken()
        if token.type==SPACE then nextToken()
        if (value=token.value)=='in' or value=='of' then inOf = value; nextToken()
        else  'expect "in" or "of"'
      if token.type==SPACE then nextToken()
      obj = parser.clause()
      expectThen(isHeadStatement, ind)
      body = parser.block() or parser.line()
      if inOf=='in' then kw = 'forIn!' else kw = 'forOf!'
      if body.length==1 then body = body[0]
      else if body.length==0 then body = 'undefined'
      else body.unshift 'begin!'
      clause = [kw, name1, name2, obj, body]
      clause.start = start; clause.stop = token
      clause

    'do': (isHeadStatement) ->
      start = token; ind = indent; nextToken(); # skip "do"
      if token.type==SPACE then nextToken()
      body = parser.block() or parser.line()
      if body.length==1 then body = body[0]
      else if body.length==0 then body = 'undefined'
      else body.unshift 'begin!'
      if indent==ind
        if token.type==UNDENT then nextToken()
        if atStatementHead and not isHeadStatement then return {value:body, start:start, stop:token}
        if token.type==CONJUNCTION and (conjValue=token.value)=='where' or conjValue=='when' or conjValue=='until'
          conj = token; nextToken(); if token.type==SPACE then nextToken()
      else if indent>ind then syntaxError "wrong indent after the block of do statement"
      if not conj then return {value:body, start:start, stop:token}
      if conjValue=='where' then tailClause = parser.varInitList()
      else tailClause = parser.clause()
      if conjValue=='where' then {value:['let', tailClause, body], start:start, stop:token}
      else if conjValue=='when' then {value:['doWhile!', body, tailClause], start:start, stop:token}
      else {value:['doWhile!', body, ['!x', tailClause]], start:start, stop:token}

    # switch value case 1: body1 case 2 3: body2 else: body
    # switch value
    #   case 1:
    #   case 2 3:
    #   else:
    'switch': (isHeadStatement) ->
      start = token; ind = indent; nextToken(); # skip "do"
      if token.type==SPACE then nextToken()
      if not (test = parser.clause()) then syntaxError 'expect a clause after "switch"'
      cases = []
      if indent>ind then indentInfo = {indent:indent}
      else indentInfo = {}
      while 1
        # case 1 2 3: case body
        if not maybeIndentConjunction('case', isHeadStatement, ind, indentInfo) then break
        if token.type==SPACE then nextToken()
        caseValues = []
        while exp=parser.compactClauseExpression()
          caseValues.push exp
          if token.type==SPACE then nextToken()
          # optional ","
          if token.value==',' then nextToken(); if token.type==SPACE then nextToken()
        if token.value!=':' then 'expect ":" after case values'
        nextToken()
        if token.type==SPACE then nextToken()
        body = parser.block() or parser.line()
        if body.length==1 then body = body[0]
        else if body.length==0 then body = undefined
        else body.unshift 'begin!'
        cases.push [caseValues, body]
      if maybeIndentConjunction('else', isHeadStatement, ind, indentInfo)
        else_ = parser.block() or parser.line()
        if else_.length==1 then else_ = else_[0]
        else if else_.length==0 then else_ = undefined
        else else_.unshift 'begin!'
      {value:['switch', test, cases, else_], start:start, stop:token}

    'try': (isHeadStatement) ->
      start = token; ind = indent; nextToken(); # skip "try"
      if token.type==SPACE then nextToken()
      if not (test = parser.block() or parser.line()) then syntaxError 'expect a line or block after "try"'
      if test.length==1 then test = test[0]
      else if test.length==0 then test = undefined
      else test.unshift 'begin!'
      if atStatementHead and not isHeadStatement
        syntaxError 'meet unexpected new line when parsing inline try statement'
      if maybeConjunction("catch", isHeadStatement, ind)
        if token.type==SPACE then nextToken()
        atStatementHead = false
        if token.type==IDENTIFIER
          catchVar = token; nextToken()
        if token.type==SPACE then nextToken()
        if token.type!=CONJUNCTION or token.value!='then'
          syntaxError('expect "then" after "catch +'+catchVar.value+'"')
        nextToken()
        if token.type==SPACE then nextToken()
        catch_ = parser.block() or parser.line()
        if catch_.length==1 then catch_ = catch_[0]
        else if catch_.length==0 then catch_ = undefined
        else catch_.unshift 'begin!'
      if maybeConjunction("finally", isHeadStatement, ind)
        if token.type==SPACE then nextToken()
        final = parser.block() or parser.line()
        if final.length==1 then final = final[0]
        else if final.length==0 then final = undefined
        else final.unshift 'begin!'
      {value:['try', test, catchVar, catch_, final], start:start, stop:token}

    'class': (isHeadStatement) ->
      nextToken(); if token.type==SPACE then nextToken()
      # class name should be provided explicitly
      if token.type!=IDENTIFIER then syntaxError 'expect class nam'
      name  = token; nextToken()
      if token.type==SPACE then nextToken()
      if token.type==CONJUNCTION and token.value=='extends' and nextToken()
        if token.type==SPACE then nextToken()
        if token.type==IDENTIFIER then superClass = token; nextToken()
        if token.type==SPACE then nextToken()
      else superClass = undefined
      if token.type==NEWLINE or token.type==UNDENT or token.type==EOI then body = undefined
      else body = parser.block() or parser.line()
      ['#call!', 'class', [name, superClass, body]]

  @sequenceClause = ->
    start = token; clause = []
    while 1
      if token.type==SPACE then nextToken()
      if (item=parser.compactClauseExpression()) then clause.push item
      else break
    if not clause.length then return
    {value:clause, start:start, stop:token}

  leadWordClauseMap =
    # eval while parsing, call by %% clause
    # e.g.
    # %% %text()
    # %% %cursor()
    # %% %number()1234
    '%%':  (tkn, clause) ->
      code = compileExp(['return', clause], environment)
      new Function('__$taiji_$_$parser__', code)(parser)

    # the head of clause will be convert to attribute of __$taiji_$_$parser__
    # see exports['%/'] and convertParserAttribute in core.coffee
    # {%/ matcheA(x, y) } will be converted to {%% %matchA(x, y)}
    '%/': (tkn, clause) ->
      # notice the difference between %% and %/
      # here ['%/', clause] is compiled
      code=compileExp(['return', [tkn, clause]], environment)
      new Function('__$taiji_$_$parser__', code)(parser)

    # identifier in clause will be convert to attribute of __$taiji_$_$parser__
    # see exports['%!'] and convertParserAttribute in core.coffee
    # {%! matcheA(x, y) } will be converted to {%% %matchA(%x, %y)}
    '%!': (tkn, clause) ->
      code=compileExp(['return', [tkn, clause]], environment)
      new Function('__$taiji_$_$parser__', code)(parser)

    '~':  (tkn, clause) -> tkn.symbol = 'quote!'; [tkn, clause]
    '`':  (tkn, clause) -> tkn.symbol = 'quasiquote!'; [tkn, clause]
    '^':  (tkn, clause) -> tkn.symbol = 'unquote!'; [tkn, clause]
    '^&': (tkn, clause) -> tkn.symbol = 'unquote-splice'; [tkn, clause]

    # preprocess opertator
    # see # see metaConvertFnMap['#'] and preprocessMetaConvertFnMap for more information
    '#':  (tkn, clause) -> [tkn, clause]

    # evaluate in compile time
    # see metaConvertFnMap['##']
    '##':  (tkn, clause) -> [tkn, clause]

    # evaluate in both compile time and run time
    # see metaConvertFnMap['#/']
    '#/': (tkn, clause) -> [tkn, clause]

    # escape from compile time to runtime
    # see metaConvertFnMap['#-']
    '#-': (tkn, clause) -> [tkn, clause]

    # #& metaConvert exp and get the current expression(not metaConverted raw program)
    # see metaConvertFnMap['#&']
    '#&': (tkn, clause) -> [tkn, clause]

  symbol2clause =
    '%': (isHeadStatement) ->
      ind = indent
      if token.type!=SPACE then return
      leadClause = parser.clause()
      code = compileExp(['return', ['%/', leadClause]], environment)
      if token.type==SPACE then matchToken()
      if token.value=='then' and nextToken()
        result = new Function('__$taiji_$_$parser__', code)(parser)
        if indent<ind then syntaxError 'expect same or less indent after custom parsing'
        result
      else syntaxError 'expect the conjunction "then"'

  leadTokenClause = (fn) -> ->
    start = token
    if (type=matchToken().type)!=SPACE and type!=INDENT then token = start; return
    matchToken()
    if not (fn=leadWordClauseMap[start.value]) then token = start; return
    {value:fn(start, parser.clause()), start:start, stop:token}

  for key, fn of leadWordClauseMap then symbol2clause[key] = leadTokenClause(fn)


  @definitionSymbolBody = definitionSymbolBody = ->
    start = token; nextToken()
    if token.type==SPACE then nextToken()
    if token.type==INDENT then body = parser.block()
    else body = parser.line()
    if body
      if body.length==1 then body = body[0]
      else if body.length==0 then body = 'undefined'
      else body.unshift 'begin!'
    {value: [start, [], body], start:start, stop:token}

  symbol2clause['->'] = definitionSymbolBody
  symbol2clause['|->'] = definitionSymbolBody
  symbol2clause['=>'] = definitionSymbolBody
  symbol2clause['|=>'] = definitionSymbolBody

  @customDefinitionParameterList = ->

  @clause = ->
    if (type=token.type)==SPACE then nextToken(); type = token.type
    start = token
    switch token.type
      when KEYWORD
        isStatementHead = atStatementHead
        atStatementHead = false
        return keyword2statement[token.value](isStatementHead)
      when IDENTIFIER
        nextToken()
        if token.value=='#' and nextToken() and token.value==':' and nextToken()
          # label statement
          if token.type==SPACE then nextToken()
          blk = parser.lineBlock()
          if blk.length==1 then blk = blk[0]
          else if blk.length==0 then blk = undefined
          else blk.unshift 'begin!'
          return {value:['label!', start, blk], start:start, stop:token}
        else token = start
      when SYMBOL
        if (fn=symbol2clause[token.value]) and (result = fn()) then return result
      when NEWLINE, UNDENT, RIGHT_DELIMITER, CONJUNCTION, EOI then return

    head = parser.compactClauseExpression()
    if not head
      # try to parse: prefix exp
      if (op=parser.prefixOperator())
        if token.type==SPACE and nextToken() and (exp=parser.spaceClauseExpression())
          return {value:[op, exp], start:start, stop:token}
        else return op
      else if token.value==',' then nextToken(); return {value:'undefined', start:start, stop:token}
      else return

    # here head is parsed successfully
    if op=parser.binaryOperator(SPACE_CLAUSE_EXPRESSION)
      tokenAfterOperator = token; token = head; head.next = op
      op[binaryOperatorMemoIndex+SPACE_CLAUSE_EXPRESSION] = {result:op, next:tokenAfterOperator}
      if (exp=parser.spaceClauseExpression())
        if (value=token.value)==','
          nextToken(); if token.type==SPACE then nextToken()
          return exp
        else if value!=';' and (type=token.type)!=NEWLINE and type!=UNDENT and type!=EOI
          if exp.priority<600 # spaces was met
            syntaxError 'after space expression clause, expect stop symbol of clause like colon, semicolon, new line, undent or end of input etc.'
          else token = op
        else return exp
      else token = op

    else if (type=head.type)!=NUMBER and type!=NON_INTERPOLATE_STRING and type!=INTERPOLATE_STRING and type!=BRACKET and type!=HASH
      tkn = token
      # here parsing [head spaceClauseExpression]
      if (exp=parser.spaceClauseExpression()) and exp.priority<=600
        if (value=token.value)==','
          nextToken(); if token.type==SPACE then nextToken()
          return {value:[head, exp], start:start, stop:token}
        else if value!=';' and (type=token.type)!=NEWLINE and type!=UNDENT and type!=EOI
          syntaxError 'after caller leading clause, expect stop symbol of clause like colon, semicolon, new line, undent or end of input etc.'
        else return {value:[head, exp], start:start, stop:token}
      else token = tkn

    if token.type==SPACE then nextToken()
    if (op=binaryOperatorDict[token.value]) and op.assign
      nextToken()
      if (type=token.type)==SPACE then nextToken(); type  =token.type
      if type==UNDENT then syntaxError 'unexpected undent after assign symbol'+op.value
      else if type==NEWLINE then syntaxError 'unexpected new line after assign symbol'+op.value
      else if type==EOI then syntaxError 'unexpected end of input'+op.value
      if right = parser.block()
        if right.length==1 then right = right[0]
        else if right.length==0 then right = 'undefined'
        else right.unshift 'begin!'
      else right = parser.clause()
      if head.type==CURVE then return {value:['hashAssign!', op, head, right], start:start, stop:token}
      else if head.type==BRACKET then  return {value:['listAssign!', op, head, right], start:start, stop:token}
      else return {value:[op, head, right], start:start, stop:token}

    else if token.value=='#' and nextToken()
      if token.type==SPACE then clauses = parser.clauses()
      else if token.type==INDENT then clauses = parser.block()
      return [head].concat clauses

    else if token.value==':'
      nextToken()
      if token.type==SPACE then nextToken()
      clause = parser.clauses()
      clause.unshift head
      return {value:clause, start:head.start, stop:token}

    if clause = parser.sequenceClause()
      clause.value.unshift head; clause.start = start
    else clause = head

    if (op=binaryOperatorDict[token.value]) and op.definition
      definition = definitionSymbolBody()
      clauseValue =  clause.value
      if clause.parameters
        if clause.type==PAREN
          if clause.empty
            definition.value[1] = []
            definition.start = start
            clause = definition
          else
            clauseValue = clauseValue.value
            if clauseValue.push
              if clauseValue.length==0
                syntaxError 'unexpected [] in parameter list'
              else if clauseValue[0]!=','
                syntaxError 'syntax error in parameter list'
              else
                clauseValue.shift() # remove "," from list, e.g.(a, b, c) ==> [, a b c] ==> [a b c]
                definition.value[1] = clauseValue
                definition.start = start
                clause = definition
            else
              definition.value[1] = [clause]
              definition.start = start
              clause = definition
        else parser.customDefinitionParameterList(clause, definition)
      else if clauseValue.push and clauseValue.length>1
          params = clauseValue[clauseValue.length-1]
          if params.parameters
            clauseValue.pop()
            definition.value[1] = params
            definition.start = params.start
          clauseValue.push definition
          clause.stop = token
      else
        clause = [clause, definition]
        clause.start = start; clause.stop = token
      return clause

    if (value=token.value)==','
      nextToken()
      #if token.type==SPACE then nextToken()
      clause.stop = token
      clause

    else if value==':'
      # head clause with colon leading clauses or colon leading indented block
      # print: 1 + 2, 3
      # withMethod # openWindow: 100x200 400x500
      # getFn Math name:
      #   abs 1
      #   sin x
      nextToken()
      if token.type==INDENT then clauses = parser.block()
      else clauses = parser.clauses()
      if clauses.length==1
        clause0 = clauses[0]
        if clause0.value.push and clause0.type!=BRACKET then clauses = clause0.value
      else if clauses.length==0 then syntaxError 'expected arguments list after ":"'
      clauses.unshift clause
      clauses.start = start; clauses.stop = token
      clauses

    else if token.type==INDENT
      tkn = token
      nextToken()
      if token.type==CONJUNCTION  # should not match indented conjunction clauses, like switch 1 \n  case 2...
        token = tkn
        atStatementHead = true
        clause.stop = token
        clause
      else
        token = tkn; atStatementHead = true
        # head clause with indented block
        # please pay attention to the difference between clause+':'+INDENT+block and clause+INDENT+block
        clauses = parser.block()
        if clause.value.push
          clause.value.push.apply clause.value, clauses
          clause.stop = token
          clause
        else clauses.unshift clause; clause = {value:clauses, start:start, stop:token}

    else clause

  @clauses = ->
    result = []
    tkn = token
    while clause=parser.clause()
      result.push clause
      # this should be debug code
      if tkn==token then syntaxError 'oops! inifinte loops!!!'
      tkn = token;
    return result

  @sentence = ->
    start = token
    if (type=token.type)==EOI or type==INDENT or type==UNDENT or type==NEWLINE or type==RIGHT_DELIMITER or type==CONJUNCTION
      return
    result = parser.clauses()
    if token.value==';'
      nextToken()
      if token.type==SPACE then nextToken()
    extendSyntaxInfo result, start, token

  @line = ->
    if (type=token.type)==UNDENT or type==RIGHT_DELIMITER or type==CONJUNCTION or type==EOI
      return
    if type==INDENT then return parser.block(indent)
    if type==CODE_BLOCK_COMMENT_LEAD_SYMBOL
      start = token; nextToken()
      if token.type==SPACE then nextToken()
      x = parser.line()
      return [{value:['codeBlockComment!', x], start:start, stop:token}]
    result = []
    tkn = token
    while x=parser.sentence()
      result.push.apply result, x
      if tkn==token then syntaxError 'oops! inifinte loops!!!'
      tkn = token;
    result

  @block = (dent) -> if token.type==INDENT then nextToken(); return parser.blockWithoutIndentHead(indent)

  # a block with out indent( the indent has been ate before).
  # stop until meet a undent (less indent than the intent of the start line)
  @blockWithoutIndentHead = (dent) ->
    result = []
    while (x=parser.line())
      result.push.apply(result, x)
      if token.type==NEWLINE then nextToken(); continue
      if token.type==EOI then break
      else if token.type==UNDENT
        if indent==dent then nextToken(); break
        else if indent>dent then syntaxError 'wrong indent'
        else continue
      else if token.type==CONJUNCTION then syntaxError 'unexpected conjunction "'+token.value+'" following a indent block'
    return result

  @lineBlock = (dent) ->
    result = parser.line()
    if token.type==NEWLINE then nextToken()
    tkn = token
    if token.type==INDENT then nextToken()
    if token.type==SPACE then nextToken()
    if token.type==CONJUNCTION then token = tkn
    else
      token = tkn
      if token.indent>dent
        result.push.apply result, parser.blockWithoutIndentHead()
    result

  @moduleBody = ->
    start = token; matchToken()
    if token.type==NEWLINE then matchToken()
    else if token.type==SPACE then matchToken()
    body = []
    while 1
      if not x=parser.line() then break
      if token.type==NEWLINE then nextToken()
      body.push.apply body, x
    if token.type!=EOI then syntaxError 'expect end of input, but meet "'+text.slice(cursor)+'"'
    if body.length>1 then body.unshift 'begin!'
    else if body.length==1 then body = body[0]
    else body = undefined
    {value:body, start:start, stop:eoi}

  # #!use/bin/node taiji
  @binShellDirective = ->
    if text[cursor...cursor+2]!='#!' then return

    cur = cursor
    while char and char!='\n' and char!='\r' then char = text[++cursor]

    if char=='\n'
      if char=='\r' then cursor += 2
      else cursor++
      lineno++
    else if char=='\r'
      if char=='\n' then cursor += 2
      else cursor++
      lineno++

    lineStart = cursor

    ['binShellDirective!', text[cur...cursor]]

  @moduleHeader = ->
    cur = cursor
    if not (literal('taiji') and spaces()  and  literal('language') and spaces() and
        (x=decimal()) and matchChar('.') and (y=decimal()))
      lexError 'taiji language module should begin with "taiji language x.x"'
    if (x=x.value)!='0' or (y=y.value)!='1' then syntaxError 'taiji 0.1 can not process taiji language'+x+'.'+y

    while char and char!='\n' and char!='\r' then char = text[++cursor]
    while char
      if char=='\n'
        if char=='\r' then cursor += 2
        else cursor++
        lineno++
      else if char=='\r'
        if char=='\n' then cursor += 2
        else cursor++
        lineno++
      if (char=text[cursor])!=' ' and  char!='\t' and char!='\n'  and char!='\r' then break
      while char and char!='\n' and char!='\r' then char = text[++cursor]
    {type: MODULE_HEADER, version: {main:x, minor:y}, value: text[...cursor], cursor:cur, stopCursor:cursor}

  @module = ->
    scriptDirective = ['scriptDirective!', parser.binShellDirective()]
    header = parser.moduleHeader()
    body = parser.moduleBody()
    result = {value:['module!', scriptDirective, header, body],
    cursor:0, stopCursor:text.length, line:1, column:0}
    result.start = result
    result

  @init = (data, cur, env) ->
    @text = text = data; cursor = cur; char = text[cursor]; lineno = 1; lineStart = 0
    token = {} # an empty token, {}.next is undefined, so nextToken will call matchToken
    # should not call matchToken() here, because the head of module need be processed differently
    # matchToken() should be called in moduleBody() instead
    memoMap = {}
    atStatementHead = true
    @environment = environment = env
    @meetEllipsis = false
    endCursorOfDynamicBlockStack = []

  @parse = (data, root, cur, env) ->
    parser.init(data, cur, env)
    # should not call matchToken() here, because the head of module need be processed differently
    # matchToken() should be called in moduleBody() instead
    root()

  @lexError = lexError = (message) ->
    throw cursor+'('+lineno+':'+(cursor-lineStart)+'): '+'lexical error: '+message+': \n'+text[cursor-40...cursor]+'|   |'+text[cursor...cursor+40]

  @syntaxError = syntaxError = (message, tkn) ->
    tkn = tkn or token; cur = tkn.cursor
    str =  cur+'('+tkn.line+':'+tkn.column+'): '+message+", meet \"#{token.value}\"\n"+text[cur-40...cur]+(text[cur...cur+40])
    # todo: the code below works great! add it in some time.
    # console.log str.red
    throw str

  return @

{compileExp} = require '../compiler'